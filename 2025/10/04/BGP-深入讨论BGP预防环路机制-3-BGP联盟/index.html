<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>[BGP]深入讨论BGP预防环路机制(3) BGP联盟 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="好的，这是一个非常核心的BGP进阶概念。我们来详细拆解一下这句话：“BGP通过AS内部使用联盟，以此防止环路”。 为了理解它，我们需要分三步走：  BGP的防环路基础机制 在单个AS内部（iBGP）遇到的问题 联盟如何解决这个问题并防止环路   1. BGP的防环路基础机制：AS_PATHBGP是一种“路径矢量”路由协议，它防环路的核心机制是 AS_PATH 属性。  工作原理：当BGP路由器向外">
<meta property="og:type" content="article">
<meta property="og:title" content="[BGP]深入讨论BGP预防环路机制(3) BGP联盟">
<meta property="og:url" content="http://example.com/2025/10/04/BGP-%E6%B7%B1%E5%85%A5%E8%AE%A8%E8%AE%BABGP%E9%A2%84%E9%98%B2%E7%8E%AF%E8%B7%AF%E6%9C%BA%E5%88%B6-3-BGP%E8%81%94%E7%9B%9F/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="好的，这是一个非常核心的BGP进阶概念。我们来详细拆解一下这句话：“BGP通过AS内部使用联盟，以此防止环路”。 为了理解它，我们需要分三步走：  BGP的防环路基础机制 在单个AS内部（iBGP）遇到的问题 联盟如何解决这个问题并防止环路   1. BGP的防环路基础机制：AS_PATHBGP是一种“路径矢量”路由协议，它防环路的核心机制是 AS_PATH 属性。  工作原理：当BGP路由器向外">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-10-04T01:18:40.000Z">
<meta property="article:modified_time" content="2025-10-16T15:15:08.777Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="BGP">
<meta property="article:tag" content="网络工程师">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="路由协议">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 8.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-BGP-深入讨论BGP预防环路机制-3-BGP联盟" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/04/BGP-%E6%B7%B1%E5%85%A5%E8%AE%A8%E8%AE%BABGP%E9%A2%84%E9%98%B2%E7%8E%AF%E8%B7%AF%E6%9C%BA%E5%88%B6-3-BGP%E8%81%94%E7%9B%9F/" class="article-date">
  <time class="dt-published" datetime="2025-10-04T01:18:40.000Z" itemprop="datePublished">2025-10-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      [BGP]深入讨论BGP预防环路机制(3) BGP联盟
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>好的，这是一个非常核心的BGP进阶概念。我们来详细拆解一下这句话：“BGP通过AS内部使用联盟，以此防止环路”。</p>
<p>为了理解它，我们需要分三步走：</p>
<ol>
<li><strong>BGP的防环路基础机制</strong></li>
<li><strong>在单个AS内部（iBGP）遇到的问题</strong></li>
<li><strong>联盟如何解决这个问题并防止环路</strong></li>
</ol>
<hr>
<h3 id="1-BGP的防环路基础机制：AS-PATH"><a href="#1-BGP的防环路基础机制：AS-PATH" class="headerlink" title="1. BGP的防环路基础机制：AS_PATH"></a>1. BGP的防环路基础机制：AS_PATH</h3><p>BGP是一种“路径矢量”路由协议，它防环路的核心机制是 <strong>AS_PATH</strong> 属性。</p>
<ul>
<li><strong>工作原理</strong>：当BGP路由器向外部的AS通告一条路由时，会把自己的<strong>AS号</strong> 添加到AS_PATH列表的最前面。</li>
<li><strong>环路检测</strong>：当一台BGP路由器收到一条路由更新时，它会检查AS_PATH列表。<strong>如果在这个列表中发现了自己的AS号，它就认为这条路由产生了环路，从而丢弃该路由。</strong></li>
</ul>
<p><strong>举个例子：</strong><br>假设AS 100 -&gt; AS 200 -&gt; AS 300。<br>当路由从AS 100传到AS 200时，AS_PATH是 <code>100</code>。<br>当AS 200再传给AS 300时，AS_PATH变成 <code>200 100</code>。<br>如果AS 300试图把这条路由再传回给AS 200，AS 200会在AS_PATH <code>300 200 100</code> 中看到自己的AS号 <code>200</code>，于是它会拒绝接受这条路由，防止了环路。</p>
<hr>
<h3 id="2-在单个AS内部（iBGP）遇到的问题"><a href="#2-在单个AS内部（iBGP）遇到的问题" class="headerlink" title="2. 在单个AS内部（iBGP）遇到的问题"></a>2. 在单个AS内部（iBGP）遇到的问题</h3><p>在一个AS内部，路由器之间使用<strong>iBGP</strong> 来交换BGP路由信息。iBGP有一个非常重要的规则，叫做：</p>
<p><strong>“从一台iBGP对等体学到的路由，永远不会传递给另一台iBGP对等体。”</strong></p>
<p>这被称为 <strong>BGP Split-Horizon</strong>。</p>
<p><strong>为什么要有这个规则？</strong><br>因为在AS内部，<strong>没有AS号被添加到AS_PATH中</strong>！回想一下防环路机制，它是基于AS_PATH来检测的。如果在同一个AS内，路由器之间互相传递路由，AS_PATH不会改变，BGP就无法通过AS_PATH来检测环路。为了防止在AS内部产生路由环路，所以干脆定下这个“死规矩”：iBGP邻居之间传一次就够了，不许二次传播。</p>
<p><strong>这个规则带来的问题：</strong><br>为了保证AS内所有BGP路由器都能学到完整的路由信息，<strong>所有运行iBGP的路由器之间必须形成全互联的邻居关系</strong>。这在一个大型AS中会带来巨大的管理和性能开销（比如有N台路由器，就需要建立 N*(N-1)&#x2F;2 个iBGP会话）。</p>
<hr>
<h3 id="3-联盟如何解决这个问题并防止环路"><a href="#3-联盟如何解决这个问题并防止环路" class="headerlink" title="3. 联盟如何解决这个问题并防止环路"></a>3. 联盟如何解决这个问题并防止环路</h3><p><strong>联盟（BGP Confederations）</strong> 就是为了解决上述“iBGP全互联”问题而设计的一种方法。</p>
<p><strong>它的核心思想是：</strong> <strong>“化整为零”</strong>。把一个大的AS（我们称之为<strong>联盟AS</strong>）划分成多个小的、更容易管理的AS（我们称之为<strong>子AS</strong> 或 <strong>成员AS</strong>）。</p>
<p><strong>具体做法：</strong></p>
<ol>
<li><strong>划分</strong>：将原来的大AS 65000，划分为几个子AS，例如 AS 65001, AS 65002, AS 65003。</li>
<li><strong>对外表现</strong>：对于<strong>联盟外部</strong>的BGP对等体来说，整个联盟仍然被看作<strong>一个单一的AS 65000</strong>。它们完全不知道内部被划分了。</li>
<li><strong>内部运行</strong>：在<strong>联盟内部</strong>，这些子AS之间使用一种特殊的<strong>eBGP</strong> 来交换路由信息。注意，它不是标准的eBGP，而是经过修改的，我们称之为 ** Confederation eBGP**。</li>
</ol>
<h4 id="联盟如何防止环路？"><a href="#联盟如何防止环路？" class="headerlink" title="联盟如何防止环路？"></a><strong>联盟如何防止环路？</strong></h4><p>这里就是最关键的部分了。联盟通过引入两个概念来防止环路：</p>
<p><strong>a) AS_CONFED_SEQUENCE</strong></p>
<p>这是一个类似于AS_PATH的BGP路径属性，但它只在联盟内部使用。</p>
<ul>
<li>当路由在一个子AS（如AS 65001）内传播时，AS_PATH不会改变。</li>
<li>但当路由从一个子AS（AS 65001）传到另一个子AS（AS 65002）时，<strong>发出路由的子AS号（65001）会被添加到 AS_CONFED_SEQUENCE 这个属性中</strong>。</li>
</ul>
<p><strong>b) 联盟内部的环路检测</strong><br>在联盟内部，路由器会同时检查 <strong>AS_PATH</strong> 和 <strong>AS_CONFED_SEQUENCE</strong>。</p>
<ul>
<li>如果在一台属于AS 65002的路由器收到的路由更新中，在 <strong>AS_CONFED_SEQUENCE</strong> 里看到了自己的子AS号 <code>65002</code>，它就会认为这条路由在联盟内部产生了环路，从而将其丢弃。</li>
</ul>
<p><strong>这样一来，联盟就在大的AS内部，重新创建了一个类似于外部AS之间的防环路机制。</strong></p>
<h4 id="工作流程与好处"><a href="#工作流程与好处" class="headerlink" title="工作流程与好处"></a><strong>工作流程与好处</strong></h4><ul>
<li><strong>流程</strong>：<ul>
<li>子AS内部：使用iBGP，遵循iBGP的规则。</li>
<li>子AS之间：使用 Confederation eBGP。它允许像标准eBGP一样传递路由，从而<strong>打破了iBGP全互联的要求</strong>。你只需要在每个子AS的边界路由器之间建立eBGP对等体关系即可。</li>
</ul>
</li>
<li><strong>好处</strong>：<ol>
<li><strong>解决了全互联问题</strong>：大大减少了需要建立的iBGP会话数量。</li>
<li><strong>防止了AS内部环路</strong>：通过AS_CONFED_SEQUENCE属性，在联盟内部实现了可靠的环路检测。</li>
<li><strong>策略灵活性</strong>：可以在子AS之间应用类似于eBGP的路由策略，提供了更精细的控制。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>根本问题</strong>：iBGP因为AS_PATH在AS内不变，无法防环路，所以只能用“全互联”这个笨办法来规避环路，但这在大型网络中不可行。</li>
<li><strong>联盟的解决方案</strong>：将大AS“伪装”成多个小AS的联合体。</li>
<li><strong>防环路机制</strong>：在内部的小AS（子AS）之间通信时，使用一个<strong>新的、只在联盟内部有效的路径属性 <code>AS_CONFED_SEQUENCE</code></strong> 来记录路径。路由器通过检查这个属性来判断是否在联盟内部形成了环路。</li>
</ul>
<p><strong>一个简单的比喻：</strong><br>把一个有1000人的大公司（大AS）重组，分成10个部门（子AS）。</p>
<ul>
<li><strong>以前</strong>：为了保证信息一致，要求这1000人两两之间都要直接沟通（全互联），这根本做不到。</li>
<li><strong>现在</strong>：部门内部（iBGP）自由沟通。部门之间（Confed eBGP）只派代表（边界路由器）沟通，并且每次跨部门传递消息时，都会在内部备忘录（AS_CONFED_SEQUENCE）上盖章，如果一份文件转了一圈又回到本部门，一看备忘录就知道是循环了，直接扔掉。而对于公司外部的人来说，他们仍然只认为这是一个公司（联盟AS）。</li>
</ul>
<p>那是不是可以说，BGP联盟仅适用于IBGP，而在EBGP上不可行？</p>
<p>这是一个非常好的问题，它触及了BGP联盟设计的核心。</p>
<p>首先给出结论：这个说法完全正确，并且非常精准。我们可以这样来理解：</p>
<p><strong>BGP联盟本质上是一种用于“优化和改造大型AS内部iBGP网络”的技术。它不是为了在eBGP上使用，而是为了解决纯iBGP环境下的问题而诞生的。</strong></p>
<p>下面我来详细解释为什么：</p>
<hr>
<h3 id="1-根本目的：解决iBGP的难题"><a href="#1-根本目的：解决iBGP的难题" class="headerlink" title="1. 根本目的：解决iBGP的难题"></a>1. 根本目的：解决iBGP的难题</h3><p>正如我们之前讨论的，iBGP有两大核心问题：</p>
<ul>
<li><strong>防环路机制缺失</strong>：在AS内部传递时，AS_PATH不变，无法用AS_PATH防环。</li>
<li><strong>全互联要求</strong>：导致管理复杂度和资源消耗巨大。</li>
</ul>
<p><strong>联盟就是为了直接解决这两个iBGP特有的问题而设计的。</strong> 如果一个AS很小，根本不需要iBGP全互联，那么联盟也就没有存在的必要。</p>
<hr>
<h3 id="2-实现方式：在AS内部“模拟”eBGP"><a href="#2-实现方式：在AS内部“模拟”eBGP" class="headerlink" title="2. 实现方式：在AS内部“模拟”eBGP"></a>2. 实现方式：在AS内部“模拟”eBGP</h3><p>联盟的实现手法非常巧妙：<strong>它在一个真实的AS内部，创建了多个逻辑上的“子AS”，然后在它们之间运行一种特殊的、经过修改的eBGP。</strong></p>
<p>这里的关键点是：</p>
<ul>
<li><strong>对“外”</strong>：对于联盟之外的、真正的eBGP对等体来说，它们看到的仍然是一个<strong>单一的、完整的AS号</strong>。它们完全不知道这个AS内部被划分成了多个子AS。在与外部通信时，联盟AS的行为和一个普通AS没有任何区别。</li>
<li><strong>对“内”</strong>：在联盟内部，子AS之间的行为<strong>类似于eBGP</strong>（比如可以正常传递路由，而不需要全互联），但又<strong>不是标准的eBGP</strong>（比如下一跳属性、LOCAL_PREF等属性在子AS间依然保持，不像标准eBGP那样默认重置）。</li>
</ul>
<p>所以，<strong>联盟技术是将eBGP的某些机制“内化”为了一个解决iBGP问题的工具。</strong></p>
<hr>
<h3 id="3-为什么说它“在eBGP上不可行”？"><a href="#3-为什么说它“在eBGP上不可行”？" class="headerlink" title="3. 为什么说它“在eBGP上不可行”？"></a>3. 为什么说它“在eBGP上不可行”？</h3><p>这个说法可以从两个层面理解：</p>
<p><strong>a) 从设计初衷和应用场景来看：</strong><br>联盟的设计目标就不是为了用于两个<strong>真正独立的、不同所属的AS</strong> 之间的eBGP连接。比如，你不可能告诉你的运营商：“我们在我们两个AS之间的eBGP链路上启用联盟吧。” 这是没有意义的，因为eBGP本身已经通过AS_PATH完美地解决了环路问题，并且不需要全互联。</p>
<p><strong>b) 从技术细节来看：</strong><br>如果试图在两个真正的eBGP对等体之间使用联盟，会遇到根本性的矛盾：</p>
<ul>
<li><strong>AS号表示</strong>：联盟使用的子AS号通常属于私有AS号范围（64512-65534）。在真正的eBGP会话中，这些私有AS号是不应该被通告给对方的。</li>
<li><strong>路径属性</strong>：联盟内部使用的<code>AS_CONFED_SEQUENCE</code>路径属性，在传递给真正的eBGP对等体之前<strong>必须被移除</strong>。如果将它泄露给外部AS，会导致路由问题，因为外部AS无法理解这个属性。</li>
<li><strong>失去意义</strong>：eBGP本身工作得很好，引入联盟机制不会带来任何好处，反而会破坏标准的防环路和工作机制。</li>
</ul>
<hr>
<h3 id="总结与类比"><a href="#总结与类比" class="headerlink" title="总结与类比"></a>总结与类比</h3><p>让我们用一个比喻来巩固理解：</p>
<ul>
<li><strong>一个大型公司</strong> &#x3D; 一个大的AS（例如AS 65000）</li>
<li><strong>公司内部的部门（如市场部、技术部）</strong> &#x3D; 子AS（AS 65001， AS 65002）</li>
<li><strong>公司与外部公司沟通</strong> &#x3D; eBGP</li>
<li><strong>公司内部的全员大会</strong> &#x3D; iBGP全互联（效率低下）</li>
<li><strong>联盟</strong> &#x3D; 公司重组，设立部门经理。部门内部自由沟通（子AS内的iBGP），部门经理之间开会沟通（子AS间的Confederation eBGP）。对外，公司仍然是一个整体。</li>
</ul>
<p><strong>结论：</strong></p>
<p><strong>BGP联盟是一种专门为解决大型iBGP网络中的全互联和防环路问题而设计的技术。它通过在一个真实的AS内部引入类似eBGP的逻辑关系来实现这一目标，但它本身并不应用于两个独立AS之间的eBGP会话。</strong> 它是“用于iBGP的eBGP-like机制”，而不是“用于eBGP的技术”。</p>
<p>最后，让我们再对IBGP中的全互联，反射路由器RR，以及BGP联盟三大预防环路机制进行详细对比。</p>
<hr>
<h3 id="对比总览"><a href="#对比总览" class="headerlink" title="对比总览"></a>对比总览</h3><table>
<thead>
<tr>
<th align="left">特性维度</th>
<th align="left">全互联</th>
<th align="left">路由反射器</th>
<th align="left">联盟</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心思想</strong></td>
<td align="left">最直接的方法，遵守基础规则</td>
<td align="left"><strong>打破“不传递”规则</strong>：指定特定路由器（RR）来反射路由</td>
<td align="left"><strong>化整为零</strong>：将大AS划分为小AS，内部使用“特殊eBGP”</td>
</tr>
<tr>
<td align="left"><strong>扩展性</strong></td>
<td align="left"><strong>极差</strong><br>会话数呈O(N²)增长</td>
<td align="left"><strong>优秀</strong><br>会话数呈O(N)线性增长</td>
<td align="left"><strong>良好</strong><br>减少了全互联范围，但比RR稍复杂</td>
</tr>
<tr>
<td align="left"><strong>配置与管理复杂度</strong></td>
<td align="left"><strong>低</strong>（概念简单）<br><strong>高</strong>（实际维护会话多）</td>
<td align="left"><strong>中等</strong><br>需要精心设计RR和客户机的拓扑</td>
<td align="left"><strong>高</strong><br>需要规划子AS，配置边界路由器</td>
</tr>
<tr>
<td align="left"><strong>防环机制</strong></td>
<td align="left"><strong>BGP Split-Horizon</strong><br>（从iBGP学到的路由不传给其他iBGP对等体）</td>
<td align="left"><strong>Cluster_List</strong> 和 <strong>Originator_ID</strong> 属性</td>
<td align="left"><strong>AS_CONFED_SEQUENCE</strong> 属性</td>
</tr>
<tr>
<td align="left"><strong>路径可见性</strong></td>
<td align="left">AS_PATH保持原始状态，清晰明了</td>
<td align="left">AS_PATH保持原始状态</td>
<td align="left">对外隐藏内部子AS结构，AS_PATH中只显示联盟AS号</td>
</tr>
<tr>
<td align="left"><strong>策略控制的灵活性</strong></td>
<td align="left">策略在所有路由器上对等应用</td>
<td align="left"><strong>集中化策略</strong><br>可在RR上应用策略，影响其所有客户机</td>
<td align="left"><strong>分布式策略</strong><br>可在子AS边界应用类似eBGP的策略，更精细</td>
</tr>
<tr>
<td align="left"><strong>网络稳定性与故障域</strong></td>
<td align="left"><strong>无单点故障</strong><br>一个会话断开不影响其他会话</td>
<td align="left"><strong>有单点故障风险</strong><br>一个RR故障会影响其所有客户机（可通过冗余缓解）</td>
<td align="left"><strong>故障域隔离</strong><br>一个子AS的问题更容易被隔离在内部</td>
</tr>
<tr>
<td align="left"><strong>迁移难度</strong></td>
<td align="left">N&#x2F;A（基准）</td>
<td align="left"><strong>相对容易</strong><br>可以逐步部署，将部分路由器设为RR的客户机</td>
<td align="left"><strong>相对困难</strong><br>通常需要规划停机时间，重新划分AS并配置边界</td>
</tr>
</tbody></table>
<hr>
<h3 id="深入分析各自特点"><a href="#深入分析各自特点" class="headerlink" title="深入分析各自特点"></a>深入分析各自特点</h3><h4 id="1-全互联"><a href="#1-全互联" class="headerlink" title="1. 全互联"></a>1. 全互联</h4><ul>
<li><strong>优点</strong>：<ul>
<li><strong>简单可靠</strong>：概念上最简单，符合BGP最基础的设计。</li>
<li><strong>无单点故障</strong>：没有中心节点，任何一个iBGP会话的中断只会影响直接相连的两个路由器。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>无法扩展</strong>：这是其致命弱点。当路由器数量超过几十台时，会话数量会变得难以管理，消耗大量内存和CPU资源。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li>小型网络或实验室环境。</li>
<li>作为衡量其他方案优劣的基准。</li>
</ul>
</li>
</ul>
<h4 id="2-路由反射器"><a href="#2-路由反射器" class="headerlink" title="2. 路由反射器"></a>2. 路由反射器</h4><ul>
<li><strong>优点</strong>：<ul>
<li><strong>极佳的扩展性</strong>：大幅减少了iBGP会话数量。是当前大型网络中最主流的解决方案。</li>
<li><strong>易于部署和迁移</strong>：可以从现有全互联网络中逐步引入RR，无需大规模重构网络。</li>
<li><strong>保持逻辑拓扑</strong>：整个AS在逻辑上仍然是一个统一的实体，对外部网络没有影响。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>可能引入单点故障</strong>：如果RR发生故障，其下所有客户机将无法学习到完整的BGP路由。解决方案是部署多个冗余的RR。</li>
<li><strong>潜在的子最优路径</strong>：RR会向所有客户机反射最佳路径，但客户机到该路径的下一跳可能不是最优的，需要依赖IGP的收敛或开启“下一跳自我”功能。</li>
<li><strong>配置复杂性</strong>：需要精心设计RR的层级（如分层RR）和Cluster，配置不当容易引起环路。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li><strong>绝大多数中大型企业和服务提供商网络</strong>。是目前事实上的标准。</li>
</ul>
</li>
</ul>
<h4 id="3-联盟"><a href="#3-联盟" class="headerlink" title="3. 联盟"></a>3. 联盟</h4><ul>
<li><strong>优点</strong>：<ul>
<li><strong>天然的故障域隔离</strong>：将一个大的网络问题分解到多个子AS中，便于管理和故障排查。</li>
<li><strong>策略灵活性强</strong>：在子AS边界，可以像使用eBGP一样应用丰富的路由策略（如MED、AS_PATH预挂等），提供了比RR更精细的控制粒度。</li>
<li><strong>无单点故障</strong>：类似于全互联，在子AS内部是全互联或RR，但子AS之间是网状连接，没有中心化的反射器。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>配置和管理最复杂</strong>：需要规划子AS的划分、分配私有AS号，并配置所有子AS边界路由器。</li>
<li><strong>迁移困难</strong>：从现有网络迁移到联盟架构通常需要详细的计划和可能的业务中断。</li>
<li><strong>调试复杂度增加</strong>：在排查问题时，需要同时关注AS_PATH和AS_CONFED_SEQUENCE。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li>规模极其庞大、结构复杂且由多个独立管理区域组成的网络（例如超大型运营商、经历了多次合并的网络）。</li>
<li>对策略控制有极高要求的特殊场景。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h3><p>在实际网络中，这三种方案并非互斥，经常被<strong>组合使用</strong>以发挥最大效益。</p>
<p><strong>最常见的组合是：路由反射器 + 联盟</strong></p>
<ul>
<li>在一个超大型的联盟AS内，每个子AS的内部可能仍然很大。</li>
<li>此时，可以在<strong>每个子AS内部使用路由反射器</strong>来进一步减少iBGP会话数量。</li>
<li>这样既获得了联盟的故障隔离和策略灵活性，又享受了RR在子AS内部的扩展性优势。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>全互联</strong>是“教科书式”的基准，但不可用于生产大型网络。</li>
<li><strong>路由反射器</strong>是当今的“主流选择”，在扩展性和易用性之间取得了最佳平衡。</li>
<li><strong>联盟</strong>是“高级武器”，提供了最强的控制力和隔离性，但代价是极高的复杂性。</li>
</ul>
<p>选择哪种方案取决于您的网络规模、增长预期、运维团队的技术能力和对网络控制力的具体要求。对于绝大多数网络而言，<strong>路由反射器</strong>都是首选方案。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/04/BGP-%E6%B7%B1%E5%85%A5%E8%AE%A8%E8%AE%BABGP%E9%A2%84%E9%98%B2%E7%8E%AF%E8%B7%AF%E6%9C%BA%E5%88%B6-3-BGP%E8%81%94%E7%9B%9F/" data-id="cuidkL-fu2dKa7tgkITYYZVb7" data-title="[BGP]深入讨论BGP预防环路机制(3) BGP联盟" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BGP/" rel="tag">BGP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" rel="tag">网络工程师</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/" rel="tag">路由协议</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/10/11/OSPF-OSPF%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          [OSPF]OSPF路由协议基本概念
        
      </div>
    </a>
  
  
    <a href="/2025/10/04/BGP-%E6%B7%B1%E5%85%A5%E8%AE%A8%E8%AE%BABGP%E9%A2%84%E9%98%B2%E7%8E%AF%E8%B7%AF%E6%9C%BA%E5%88%B6-2-EBGP/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">[BGP]深入讨论BGP预防环路机制(2) EBGP</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BGP/" rel="tag">BGP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IS-IS/" rel="tag">IS-IS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OSPF/" rel="tag">OSPF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RIP/" rel="tag">RIP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/" rel="tag">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" rel="tag">网络工程师</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/" rel="tag">路由协议</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BGP/" style="font-size: 15px;">BGP</a> <a href="/tags/IS-IS/" style="font-size: 10px;">IS-IS</a> <a href="/tags/OSPF/" style="font-size: 12.5px;">OSPF</a> <a href="/tags/RIP/" style="font-size: 10px;">RIP</a> <a href="/tags/github/" style="font-size: 12.5px;">github</a> <a href="/tags/hexo/" style="font-size: 12.5px;">hexo</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" style="font-size: 20px;">网络工程师</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 20px;">计算机网络</a> <a href="/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/" style="font-size: 17.5px;">路由协议</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/10/">October 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">September 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/10/16/%E6%B5%85%E6%9E%90%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E4%B8%8E%E7%9B%B4%E8%BF%9E%E8%B7%AF%E7%94%B1/">浅析静态路由与直连路由</a>
          </li>
        
          <li>
            <a href="/2025/10/16/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2025/10/13/IS-IS-IS-IS%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">[IS-IS]IS-IS路由协议基本概念</a>
          </li>
        
          <li>
            <a href="/2025/10/13/RIP-RIP%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">[RIP]RIP路由协议基本概念</a>
          </li>
        
          <li>
            <a href="/2025/10/11/OSPF-%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%AE%B2%E6%B8%85%E6%A5%9AOSPF%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%83%E6%AD%A5%E9%82%BB%E6%8E%A5%E5%85%B3%E7%B3%BB%E5%BB%BA%E7%AB%8B%E6%AD%A5%E9%AA%A4/">[OSPF]一篇文章讲清楚OSPF路由协议的七步邻接关系建立步骤</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>