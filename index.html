<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 8.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-对比RIP，IS-IS，OSPF，BGP四大路由协议（2）路由聚合" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/23/%E5%AF%B9%E6%AF%94RIP%EF%BC%8CIS-IS%EF%BC%8COSPF%EF%BC%8CBGP%E5%9B%9B%E5%A4%A7%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%EF%BC%882%EF%BC%89%E8%B7%AF%E7%94%B1%E8%81%9A%E5%90%88/" class="article-date">
  <time class="dt-published" datetime="2025-10-23T15:40:11.000Z" itemprop="datePublished">2025-10-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/23/%E5%AF%B9%E6%AF%94RIP%EF%BC%8CIS-IS%EF%BC%8COSPF%EF%BC%8CBGP%E5%9B%9B%E5%A4%A7%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%EF%BC%882%EF%BC%89%E8%B7%AF%E7%94%B1%E8%81%9A%E5%90%88/">对比RIP，IS-IS，OSPF，BGP四大路由协议（2）路由聚合</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一-什么是路由聚合？"><a href="#一-什么是路由聚合？" class="headerlink" title="一. 什么是路由聚合？"></a>一. 什么是路由聚合？</h3><p><strong>路由聚合</strong>，也常被称为<strong>路由汇总</strong> 或<strong>超网</strong>，是一种网络设计技术。它的核心思想是：<strong>将多个连续的、更小的IP地址网络（子网）合并成一个更大的、单一的地址块，并在网络中只通告这个汇总后的路由。</strong></p>
<p>你可以把它想象成现实生活中的邮政系统：</p>
<ul>
<li>没有聚合：邮局需要知道<strong>每一个</strong>具体的门牌号（如：北京路1号、2号、3号…）才能送信，路由表会非常庞大。</li>
<li>使用聚合：邮局只需要知道“所有寄往北京路的信都扔到这个分拣中心”即可。这个“北京路”就是一个聚合后的路由。</li>
</ul>
<p><strong>技术上的实现：</strong><br>路由聚合依赖于<strong>无类域间路由（CIDR）</strong> 的思想。它通过缩短IP地址的网络前缀（即子网掩码变短）来实现。</p>
<p><strong>举个例子：</strong><br>假设一个路由器后面连接着以下四个子网：</p>
<ul>
<li>192.168.0.0&#x2F;24</li>
<li>192.168.1.0&#x2F;24</li>
<li>192.168.2.0&#x2F;24</li>
<li>192.168.3.0&#x2F;24</li>
</ul>
<p>如果我们不进行聚合，路由器需要向网络中的其他路由器分别通告这4条路由条目。</p>
<p>但如果我们进行聚合：</p>
<ol>
<li>将这些地址写成二进制，观察它们的前缀。</li>
<li>我们发现这四个子网的前24位是相同的，但从第25位开始有变化。</li>
<li>我们可以找到一个更短的公共前缀：<strong>&#x2F;22</strong>。</li>
<li>计算后，这个聚合后的路由就是：<strong>192.168.0.0&#x2F;22</strong>。</li>
</ol>
<p>这个 <code>/22</code> 的网络包含了从 <code>192.168.0.0</code> 到 <code>192.168.3.255</code> 的所有地址，完美覆盖了原来的四个 <code>/24</code> 子网。现在，路由器只需要向外通告 <strong>192.168.0.0&#x2F;22</strong> 这一条路由，就代表了背后的所有四个子网。</p>
<hr>
<h3 id="为什么路由协议中要使用路由聚合？"><a href="#为什么路由协议中要使用路由聚合？" class="headerlink" title="为什么路由协议中要使用路由聚合？"></a>为什么路由协议中要使用路由聚合？</h3><p>在路由协议（如OSPF, EIGRP, BGP等）中部署路由聚合，主要是为了解决以下几个核心问题，并带来巨大的网络效益：</p>
<p><strong>1. 大幅减小路由表规模</strong><br>这是最直接、最重要的好处。互联网的核心路由器和大型企业网络的核心设备承载着数十万甚至百万条路由。通过聚合，可以将成百上千条具体路由压缩成几条汇总路由，极大地减轻了路由器内存的负担。</p>
<p><strong>2. 提高路由效率和转发性能</strong><br>路由表越小，路由器查询“最佳路径”的速度就越快。这直接提升了数据包的转发效率，降低了处理延迟。</p>
<p><strong>3. 限制路由波动的影响，增强网络稳定性</strong><br>在大型网络中，某一条具体链路的“翻动”（频繁Up&#x2F;Down）会导致该路由信息在网络中被反复通告和撤销。这种现象称为<strong>路由抖动</strong>。</p>
<ul>
<li><strong>没有聚合</strong>：一个子网的抖动会传播到整个网络，导致所有路由器不停地重新计算路由表，消耗CPU资源，甚至引发网络震荡。</li>
<li><strong>使用聚合</strong>：由于外部路由器只知道聚合后的路由（如上面的192.168.0.0&#x2F;22），而不知道内部具体的子网（如192.168.1.0&#x2F;24）。因此，内部某个子网的抖动被限制在了聚合边界之内，不会影响到外部网络。这极大地提升了整个网络的稳定性。</li>
</ul>
<p><strong>4. 节省网络带宽</strong><br>更少的路由条目意味着路由协议在邻居之间发送的路由更新报文体积更小，占用的链路带宽也更少。</p>
<p><strong>5. 隐藏网络细节，提升安全性</strong><br>聚合对外部网络隐藏了内部寻址的具体结构。从外部看，你只知道有一个大的地址块（如192.168.0.0&#x2F;22），但无法知晓其内部具体划分了多少个子网以及它们的拓扑结构。这在一定程度上增加了网络攻击的难度。</p>
<p><strong>6. 简化网络设计和维护</strong><br>通过将网络设计成层次化结构（核心、汇聚、接入），并在汇聚层进行路由聚合，可以使网络逻辑更清晰，故障排查和日常维护也更加容易。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">未使用路由聚合</th>
<th align="left">使用路由聚合</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>路由表大小</strong></td>
<td align="left">庞大，包含所有明细路由</td>
<td align="left">精简，只有汇总路由</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">查询慢，转发效率较低</td>
<td align="left">查询快，转发效率高</td>
</tr>
<tr>
<td align="left"><strong>稳定性</strong></td>
<td align="left">路由抖动易传播，不稳定</td>
<td align="left">隔离路由抖动，更稳定</td>
</tr>
<tr>
<td align="left"><strong>带宽占用</strong></td>
<td align="left">路由更新信息多，占用带宽大</td>
<td align="left">路由更新信息少，节省带宽</td>
</tr>
<tr>
<td align="left"><strong>网络设计</strong></td>
<td align="left">扁平化，复杂难维护</td>
<td align="left">层次化，清晰易维护</td>
</tr>
</tbody></table>
<p>简单来说，<strong>路由聚合是构建大规模、可扩展、稳定高效网络的一项基础且至关重要的技术。</strong> 它通过“抓大放小”的策略，用一条汇总信息代表一系列明细网络，从而解决了网络规模增长带来的诸多挑战。</p>
<h3 id="二-RIP路由聚合详解"><a href="#二-RIP路由聚合详解" class="headerlink" title="二. RIP路由聚合详解"></a>二. RIP路由聚合详解</h3><p>RIP的路由聚合主要作用在于<strong>减少路由表规模</strong>和<strong>提升网络稳定性</strong>。华为设备支持两种聚合方式：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">自动路由聚合 (有类聚合)</th>
<th align="left">手动路由聚合 (无类聚合)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>配置视图</strong></td>
<td align="left">RIP视图</td>
<td align="left">接口视图</td>
</tr>
<tr>
<td align="left"><strong>聚合原则</strong></td>
<td align="left">按<strong>自然网络边界</strong>（主类网络）聚合</td>
<td align="left">按<strong>自定义网络边界</strong>（无类别地址）聚合</td>
</tr>
<tr>
<td align="left"><strong>优先级</strong></td>
<td align="left">低</td>
<td align="left">高</td>
</tr>
<tr>
<td align="left"><strong>主要命令</strong></td>
<td align="left"><code>summary</code> 或 <code>summary always</code></td>
<td align="left"><code>rip summary-address ip-address mask</code></td>
</tr>
</tbody></table>
<h4 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h4><ol>
<li><p><strong>配置自动路由聚合</strong><br>在系统视图下进入RIP进程，并确保版本为RIP-2，然后使能聚合功能。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;HUAWEI&gt; system-view</span><br><span class="line">[HUAWEI] rip 1</span><br><span class="line">[HUAWEI-rip-1] version 2</span><br><span class="line">[HUAWEI-rip-1] summary</span><br></pre></td></tr></table></figure>
<p>如果配置了水平分割或毒性反转，普通<code>summary</code>命令会失效，此时可以使用<code>summary always</code>命令强制开启聚合。</p>
</li>
<li><p><strong>配置手动路由聚合</strong><br>手动聚合提供了更精细的控制，可以在指定接口上发布一条聚合后的路由。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;HUAWEI&gt; system-view</span><br><span class="line">[HUAWEI] interface GigabitEthernet 0/0/1</span><br><span class="line">[HUAWEI-GigabitEthernet0/0/1] rip summary-address 192.168.0.0 255.255.0.0</span><br></pre></td></tr></table></figure>
<p>添加<code>avoid-feedback</code>参数可以防止从该接口再学习到相同的聚合路由，避免潜在环路。</p>
</li>
</ol>
<h4 id="⚠️-核心注意事项"><a href="#⚠️-核心注意事项" class="headerlink" title="⚠️ 核心注意事项"></a>⚠️ 核心注意事项</h4><ul>
<li><p><strong>与防环机制的冲突</strong>：这是RIP聚合配置中最关键的一点。<strong>水平分割</strong>和<strong>毒性反转</strong>功能会阻止在同一个接口发送从该接口学来的路由，这导致自动聚合在配置了这些功能的接口上<strong>失效</strong>。解决方案是：</p>
<ul>
<li>在需要发送聚合路由的接口上<strong>关闭水平分割和毒性反转</strong>。</li>
<li>或者，直接使用<code>summary always</code>命令，此命令能无视防环机制，强制进行聚合。</li>
</ul>
</li>
<li><p><strong>优先级规则</strong>：当同时配置了自动聚合和接口手动聚合时，<strong>手动聚合的优先级更高</strong>。只有当某些子网路由超出了手动聚合的地址范围时，RIP的自动聚合路由才会被发布出去。</p>
</li>
<li><p><strong>版本要求</strong>：路由聚合是<strong>RIP-2</strong>的特性，RIP-1不支持。在配置前请确保已执行<code>version 2</code>命令。</p>
</li>
<li><p><strong>防止路由环路</strong>：在NBMA（非广播多路访问）网络等复杂拓扑中配置聚合时，使用<code>avoid-feedback</code>参数是防止路由环路的有效手段。</p>
</li>
</ul>
<h2 id="三-IS-IS路由聚合详解"><a href="#三-IS-IS路由聚合详解" class="headerlink" title="三. IS-IS路由聚合详解"></a>三. IS-IS路由聚合详解</h2><p>IS-IS的路由聚合是一项关键功能，主要用于<strong>缩减路由表规模</strong>、<strong>优化网络资源利用</strong>并<strong>提升网络稳定性</strong>。</p>
<p>在华为设备上，配置IS-IS路由聚合的核心命令是 <strong><code>summary ip-address mask</code></strong> 。你还可以通过一些可选参数来精确控制聚合行为：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>level-1</code></strong></td>
<td align="left">仅对引入到<strong>Level-1</strong>区域的路由进行聚合。</td>
</tr>
<tr>
<td align="left"><strong><code>level-2</code></strong></td>
<td align="left">仅对引入到<strong>Level-2</strong>区域（骨干区域）的路由进行聚合。此为<strong>缺省</strong>级别。</td>
</tr>
<tr>
<td align="left"><strong><code>level-1-2</code></strong></td>
<td align="left">同时对向<strong>Level-1和Level-2</strong>区域引入的路由进行聚合。</td>
</tr>
<tr>
<td align="left"><strong><code>avoid-feedback</code></strong></td>
<td align="left">避免设备通过路由计算再学习到自身发布的聚合路由。</td>
</tr>
<tr>
<td align="left"><strong><code>generate_null0_route</code></strong></td>
<td align="left">生成一条<strong>Null0</strong>路由，用于防止路由环路。</td>
</tr>
<tr>
<td align="left"><strong><code>tag tag</code></strong></td>
<td align="left">为聚合路由分配一个管理标签，常用于通过路由策略匹配路由。</td>
</tr>
</tbody></table>
<h3 id="📝-配置步骤与查看结果"><a href="#📝-配置步骤与查看结果" class="headerlink" title="📝 配置步骤与查看结果"></a>📝 配置步骤与查看结果</h3><p>配置IS-IS路由聚合的基本步骤如下：</p>
<ol>
<li>进入系统视图：<code>system-view</code>。</li>
<li>进入IS-IS视图：<code>isis [ process-id ]</code>。</li>
<li>配置路由聚合：<code>summary ip-address mask [ 可选参数 ] *</code>，例如 <code>summary 192.168.0.0 255.255.248.0 level-2</code>。</li>
<li>提交配置：<code>commit</code>。</li>
</ol>
<p>配置完成后，可以使用 <strong><code>display isis route</code></strong> 命令查看IS-IS路由表中的聚合路由，或使用 <strong><code>display ip routing-table verbose</code></strong> 命令查看IP路由表中的聚合路由。</p>
<h3 id="🏗️-理解IS-IS路由聚合的应用"><a href="#🏗️-理解IS-IS路由聚合的应用" class="headerlink" title="🏗️ 理解IS-IS路由聚合的应用"></a>🏗️ 理解IS-IS路由聚合的应用</h3><p>理解IS-IS路由聚合，关键在于把握其<strong>应用场景</strong>和<strong>生效特点</strong>。</p>
<ul>
<li><p><strong>应用场景与好处</strong><br>在大中型IS-IS网络中，配置路由聚合能<strong>有效减少路由表中的条目数量</strong>，节省设备内存和网络资源。同时，<strong>当被聚合地址范围内的某条具体链路发生震荡时，这种变化不会被传播到聚合范围之外</strong>，从而避免了频繁的LSP扩散和SPF计算，提升了网络的稳定性。</p>
</li>
<li><p><strong>生效特点与位置</strong><br>IS-IS路由聚合<strong>只对本地设备生成的LSP（链路状态报文）中的路由生效</strong>。这意味着，<strong>配置聚合的设备，其本地路由表仍然会显示所有具体路由</strong>；但接收到该设备发出的聚合LSP的其他设备，其路由表中则<strong>只会出现聚合后的路由</strong>。</p>
<p>通常，<strong>在作为Level-1-2路由器并负责将Level-1路由泄漏到Level-2区域的设备上配置聚合</strong>非常有效。这可以防止Level-1区域内的链路抖动影响到整个骨干区域。</p>
</li>
</ul>
<h3 id="⚠️-重要注意事项"><a href="#⚠️-重要注意事项" class="headerlink" title="⚠️ 重要注意事项"></a>⚠️ 重要注意事项</h3><p>配置IS-IS路由聚合时，有几点需要特别留意：</p>
<ul>
<li><strong>聚合路由的开销值</strong>：聚合后路由的开销值（Cost）<strong>取所有被聚合的具体路由中的最小开销值</strong>。</li>
<li><strong>避免路由环路</strong>：在特定网络拓扑中（如NBMA网络），合理使用 <strong><code>avoid-feedback</code></strong> 和 <strong><code>generate_null0_route</code></strong> 参数有助于防止路由环路。</li>
<li><strong>IPv6支持</strong>：对于IPv6网络，IS-IS也支持路由聚合，配置命令为 <strong><code>ipv6 summary ipv6-address prefix-length</code></strong>。</li>
</ul>
<h3 id="💎-总结"><a href="#💎-总结" class="headerlink" title="💎 总结"></a>💎 总结</h3><p>总的来说，IS-IS路由聚合通过将多条具体路由汇总为更粗略的路由，有效提升了大规模网络的效率和稳定性。配置时，关键在于<strong>选择合适的聚合位置（通常是Level-1-2路由器）和精细控制聚合参数</strong>。</p>
<h2 id="四-OSPF路由聚合详解"><a href="#四-OSPF路由聚合详解" class="headerlink" title="四.OSPF路由聚合详解"></a>四.OSPF路由聚合详解</h2><p>下面这个表格汇总了OSPF路由聚合的主要特点和华为设备的配置命令：</p>
<table>
<thead>
<tr>
<th>特性维度</th>
<th>ABR路由聚合 (区域间路由聚合)</th>
<th>ASBR路由聚合 (外部路由聚合)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>配置视图</strong></td>
<td>OSPF区域视图 (<code>area area-id</code>)</td>
<td>OSPF进程视图 (<code>ospf [process-id]</code>)</td>
</tr>
<tr>
<td><strong>核心配置命令</strong></td>
<td><code>abr-summary ip-address mask</code></td>
<td><code>asbr-summary ip-address mask</code></td>
</tr>
<tr>
<td><strong>聚合对象</strong></td>
<td>同一OSPF区域内的<strong>内部路由</strong> (Type-3 LSA)</td>
<td>通过重分发引入的<strong>外部路由</strong> (Type-5&#x2F;Type-7 LSA)</td>
</tr>
<tr>
<td><strong>主要目的</strong></td>
<td>减少区域间传播的LSA数量，缩小其他区域路由表</td>
<td>减少引入OSPF域内的外部路由数量，抑制外部路由波动</td>
</tr>
<tr>
<td><strong>可选参数举例</strong></td>
<td><code>cost</code>、<code>not-advertise</code>、<code>generate-null0-route</code></td>
<td><code>cost</code>、<code>not-advertise</code>、<code>tag</code></td>
</tr>
</tbody></table>
<h3 id="🔧-配置步骤与说明"><a href="#🔧-配置步骤与说明" class="headerlink" title="🔧 配置步骤与说明"></a>🔧 配置步骤与说明</h3><p><strong>ABR路由聚合</strong> 在ABR（区域边界路由器）上进行配置。它的主要目的是将来自某个区域内部的一组连续路由，在ABR向其他区域发送路由信息时，聚合成一条汇总路由。这样可以减少其他区域中LSDB的规模。</p>
<p>具体配置步骤如下：</p>
<ol>
<li>进入系统视图：<code>system-view</code>。</li>
<li>进入OSPF进程视图：<code>ospf [process-id]</code>。</li>
<li>进入特定的OSPF区域视图：<code>area area-id</code>。</li>
<li>配置ABR路由聚合命令：<code>abr-summary ip-address mask [ [ cost { cost | inherit-minimum } | [ advertise [ generate-null0-route ] | not-advertise | generate-null0-route [ advertise ] ] ] * ]</code>。</li>
</ol>
<p><strong>ASBR路由聚合</strong> 在ASBR（自治系统边界路由器）上进行配置。当大量外部路由被引入到OSPF时，ASBR路由聚合可以对引入的路由进行聚合，这样可确保每次发布的聚合路由信息携带更多的有效路由，避免由于不正确的路由信息造成的网络振荡。</p>
<p>具体配置步骤如下：</p>
<ol>
<li>进入系统视图：<code>system-view</code>。</li>
<li>进入OSPF进程视图：<code>ospf [process-id]</code>。</li>
<li>配置ASBR路由聚合命令：<code>asbr-summary ip-address mask [ not-advertise | tag tag | cost cost | distribute-delay interval ] *</code>。</li>
</ol>
<h3 id="⚠️-配置要点与注意事项"><a href="#⚠️-配置要点与注意事项" class="headerlink" title="⚠️ 配置要点与注意事项"></a>⚠️ 配置要点与注意事项</h3><ul>
<li><p><strong>聚合路由的开销值（Cost）</strong>：</p>
<ul>
<li>对于<strong>ABR聚合</strong>，默认情况下，聚合路由的开销取所有被聚合的具体路由中的<strong>最大开销值</strong>。你也可以通过<code>cost</code>参数手动指定一个开销值。</li>
<li>对于<strong>ASBR聚合</strong>，默认情况下，聚合路由的开销取所有被聚合的外部路由中的<strong>最大开销值</strong>。如果是Type2外部路由，则聚合路由的开销值是所有被聚合路由中的最大开销值再加上1。同样，你也可以通过<code>cost</code>参数手动指定。</li>
</ul>
</li>
<li><p><strong><code>not-advertise</code>参数的使用</strong>：</p>
<ul>
<li>在<code>abr-summary</code>或<code>asbr-summary</code>命令中配置<code>not-advertise</code>参数，可以<strong>抑制聚合路由的通告</strong>。这意味着符合该聚合地址范围的路由将不会被发布出去。这个功能可以用于精确控制路由的传播范围。</li>
</ul>
</li>
<li><p><strong>生成Null0路由以防止环路</strong>：</p>
<ul>
<li>在配置ABR路由聚合时，可以使用 <strong><code>generate-null0-route</code></strong> 参数。这会在本地生成一条指向Null0接口的聚合路由，作为一种防环机制。当匹配到聚合路由但找不到更精确的具体路由时，数据包会被丢弃，从而避免形成路由环路。</li>
</ul>
</li>
<li><p><strong>聚合与网络规划</strong>：</p>
<ul>
<li>为了更有效地实施路由聚合，在规划网络时，应尽量<strong>为同一区域分配连续的网络地址</strong>。连续的地址块更容易被聚合，能充分发挥路由聚合的优势。</li>
</ul>
</li>
</ul>
<h3 id="📝-参考配置实例"><a href="#📝-参考配置实例" class="headerlink" title="📝 参考配置实例"></a>📝 参考配置实例</h3><p>以下是一个在华为设备上配置OSPF ASBR路由聚合的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">ospf 2</span><br><span class="line"> asbr-summary 192.168.2.0 255.255.254.0  // 聚合192.168.2.0/24和192.168.3.0/24等连续路由</span><br><span class="line"> import-route direct  // 引入直连路由</span><br><span class="line"> area 0.0.0.0</span><br><span class="line">  network 192.168.0.0 0.0.0.255</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p>此配置将引入的直连路由（例如192.168.2.0&#x2F;24和192.168.3.0&#x2F;24）聚合为一条路由<strong>192.168.2.0&#x2F;23</strong>发布到OSPF网络中。</p>
<h2 id="五-BGP路由聚合详解"><a href="#五-BGP路由聚合详解" class="headerlink" title="五. BGP路由聚合详解"></a>五. BGP路由聚合详解</h2><p>BGP的路由聚合是控制路由表规模和优化网络稳定性的关键手段，主要分为<strong>自动聚合</strong>和<strong>手动聚合</strong>两种方式。下面这个表格汇总了它们的核心特性，方便你快速了解：</p>
<table>
<thead>
<tr>
<th align="left">特性维度</th>
<th align="left">自动聚合</th>
<th align="left">手动聚合</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>配置命令</strong></td>
<td align="left"><code>summary automatic</code></td>
<td align="left">&#96;aggregate ipv4-address { mask</td>
</tr>
<tr>
<td align="left"><strong>生效对象</strong></td>
<td align="left">仅对通过 <code>import-route</code> 命令引入的路由有效（如直连、静态、OSPF等）</td>
<td align="left">对BGP本地路由表中<strong>已存在</strong>的明细路由有效</td>
</tr>
<tr>
<td align="left"><strong>聚合方式</strong></td>
<td align="left">按IP地址的<strong>自然网段</strong>（Classful）进行聚合</td>
<td align="left">按配置的<strong>无类别</strong>地址块进行聚合，更为灵活</td>
</tr>
<tr>
<td align="left"><strong>优先级</strong></td>
<td align="left">低于手动聚合</td>
<td align="left">更高</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">快速简化路由，但<strong>在现代网络中不推荐使用</strong></td>
<td align="left"><strong>推荐使用</strong>，提供精细控制</td>
</tr>
</tbody></table>
<h3 id="🔧-配置要点与步骤"><a href="#🔧-配置要点与步骤" class="headerlink" title="🔧 配置要点与步骤"></a>🔧 配置要点与步骤</h3><h4 id="自动聚合配置"><a href="#自动聚合配置" class="headerlink" title="自动聚合配置"></a><strong>自动聚合配置</strong></h4><p>自动聚合的配置相对直接，但需要注意其局限性。</p>
<ol>
<li><strong>进入系统视图和BGP视图</strong>：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;HUAWEI&gt; system-view</span><br><span class="line">[HUAWEI] bgp 100</span><br><span class="line">[HUAWEI-bgp] ipv4-family unicast  // 进入IPv4单播地址族视图</span><br></pre></td></tr></table></figure></li>
<li><strong>（可选）引入路由</strong>：如果尚未引入，可配置例如 <code>import-route direct</code> 引入直连路由。</li>
<li><strong>使能自动聚合</strong>：在对应的地址族视图下执行 <code>summary automatic</code>。</li>
</ol>
<h4 id="手动聚合配置"><a href="#手动聚合配置" class="headerlink" title="手动聚合配置"></a><strong>手动聚合配置</strong></h4><p>手动聚合提供了强大的控制能力，通过为 <code>aggregate</code> 命令添加不同的关键字，可以实现复杂的聚合策略：</p>
<table>
<thead>
<tr>
<th align="left">命令关键字</th>
<th align="left">功能说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>detail-suppressed</code></strong></td>
<td align="left"><strong>只发布聚合路由</strong>，抑制所有明细路由的通告。</td>
</tr>
<tr>
<td align="left"><strong><code>suppress-policy route-policy-name</code></strong></td>
<td align="left"><strong>有选择地抑制部分明细路由</strong>，匹配路由策略的明细路由被抑制，其他的仍可通告。</td>
</tr>
<tr>
<td align="left"><strong><code>as-set</code></strong></td>
<td align="left">生成携带 <strong><code>AS_SET</code></strong> 属性的聚合路由，该属性包含了所有被聚合明细路由的AS路径信息，<strong>用于防止路由环路</strong>，但在明细路由频繁变化时可能导致路由振荡。</td>
</tr>
<tr>
<td align="left"><strong><code>attribute-policy route-policy-name</code></strong></td>
<td align="left">通过路由策略来<strong>设置聚合路由的属性</strong>（如Community、MED等）。</td>
</tr>
<tr>
<td align="left"><strong><code>origin-policy route-policy-name</code></strong></td>
<td align="left"><strong>只根据通过路由策略筛选出的明细路由</strong>来生成聚合路由。</td>
</tr>
</tbody></table>
<p>配置手动聚合的基本步骤为：</p>
<ol>
<li>进入系统视图和BGP视图，并选择合适的地址族视图（如 <code>ipv4-family unicast</code>）。</li>
<li>使用 <code>aggregate</code> 命令并组合所需的关键字，例如：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[HUAWEI-bgp-af-ipv4] aggregate 10.1.0.0 255.255.0.0 detail-suppressed</span><br><span class="line">// 这将聚合10.1.0.0/16的路由，并抑制所有明细路由。</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="⚠️-重要注意事项-1"><a href="#⚠️-重要注意事项-1" class="headerlink" title="⚠️ 重要注意事项"></a>⚠️ 重要注意事项</h3><ul>
<li><strong>手动聚合的前提</strong>：BGP本地路由表中<strong>必须至少存在一条属于该聚合地址范围的明细路由</strong>，手动聚合才能生效并生成聚合路由。例如，BGP路由表中不存在 <code>10.1.1.0/24</code> 这样的明细路由，那么配置 <code>aggregate 10.1.0.0 255.255.0.0</code> 是无效的。</li>
<li><strong>聚合路由的下一跳</strong>：手动聚合产生的聚合路由，其<strong>出接口默认为 <code>Null0</code></strong>。这是一种防环机制，但需要注意确保该聚合路由不会成为设备自身的优选路由，否则可能导致流量被错误丢弃。</li>
<li><strong><code>as-set</code> 属性的权衡</strong>：使用 <code>as-set</code> 可以保留AS路径信息以防环，但会<strong>导致聚合路由携带的AS_PATH变为无序的AS集合</strong>。当聚合范围内的任何一条明细路由发生抖动时，都会引起整个聚合路由的更新，因此<strong>在聚合大量AS路径或明细路由频繁变化时需谨慎使用</strong>。</li>
</ul>
<h3 id="📊-四大路由协议聚合方式概览"><a href="#📊-四大路由协议聚合方式概览" class="headerlink" title="📊 四大路由协议聚合方式概览"></a>📊 四大路由协议聚合方式概览</h3><p>下表简要对比了RIP、OSPF、IS-IS和BGP的路由聚合特性，帮助你建立一个整体的认识。</p>
<table>
<thead>
<tr>
<th align="left">协议</th>
<th align="left">聚合类型</th>
<th align="left">主要特点与说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>RIP</strong></td>
<td align="left">自动&#x2F;手动</td>
<td align="left">如前述，手动聚合优先级高，需注意与防环机制配合。</td>
</tr>
<tr>
<td align="left"><strong>OSPF</strong></td>
<td align="left">手动</td>
<td align="left">主要在<strong>区域边界路由器（ABR）</strong> 上进行<strong>区域间路由聚合</strong>，以及在<strong>自治系统边界路由器（ASBR）</strong> 上进行<strong>外部路由聚合</strong>。</td>
</tr>
<tr>
<td align="left"><strong>IS-IS</strong></td>
<td align="left">手动</td>
<td align="left">通常在<strong>Level-1-2路由器</strong>上将Level-1路由聚合后发布到Level-2区域，也可以在Level-2路由器上进行聚合。支持通过路由策略精细控制。</td>
</tr>
<tr>
<td align="left"><strong>BGP</strong></td>
<td align="left">手动</td>
<td align="left">聚合灵活性最高，可通过<code>aggregate</code>命令生成聚合路由，并灵活控制是否抑制具体路由、是否携带AS_SET属性等，常用于优化庞大的互联网路由表。</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/23/%E5%AF%B9%E6%AF%94RIP%EF%BC%8CIS-IS%EF%BC%8COSPF%EF%BC%8CBGP%E5%9B%9B%E5%A4%A7%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%EF%BC%882%EF%BC%89%E8%B7%AF%E7%94%B1%E8%81%9A%E5%90%88/" data-id="cuideGh3vuNAp75RKanu0uSv9" data-title="对比RIP，IS-IS，OSPF，BGP四大路由协议（2）路由聚合" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" rel="tag">网络工程师</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-对比RIP，IS-IS，OSPF，BGP四大路由协议（1）宣告路由" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/21/%E5%AF%B9%E6%AF%94RIP%EF%BC%8CIS-IS%EF%BC%8COSPF%EF%BC%8CBGP%E5%9B%9B%E5%A4%A7%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%EF%BC%881%EF%BC%89%E5%AE%A3%E5%91%8A%E8%B7%AF%E7%94%B1/" class="article-date">
  <time class="dt-published" datetime="2025-10-21T15:50:21.000Z" itemprop="datePublished">2025-10-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/21/%E5%AF%B9%E6%AF%94RIP%EF%BC%8CIS-IS%EF%BC%8COSPF%EF%BC%8CBGP%E5%9B%9B%E5%A4%A7%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%EF%BC%881%EF%BC%89%E5%AE%A3%E5%91%8A%E8%B7%AF%E7%94%B1/">对比RIP，IS-IS，OSPF，BGP四大路由协议（1）宣告路由</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、RIP路由协议"><a href="#一、RIP路由协议" class="headerlink" title="一、RIP路由协议"></a>一、RIP路由协议</h3><p>RIP是一种基于距离矢量的内部网关协议，它通过UDP 520端口进行路由信息交换。在华为设备上，其宣告方式相对直接。</p>
<h4 id="1-宣告命令"><a href="#1-宣告命令" class="headerlink" title="1. 宣告命令"></a>1. 宣告命令</h4><p>在华为设备上，你需要在RIP进程视图下使用 <code>network</code> 命令来宣告直连网络。<strong>关键点在于：<code>network</code> 后面跟的是主类网络号（即A、B、C类网络），RIP会自动将该主类网络下的所有直连接口启用RIP。</strong></p>
<p><strong>基本配置步骤：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] rip [process-id]          <span class="comment"># 启动RIP进程，进程ID默认为1</span></span><br><span class="line">[Huawei-rip-1] version 2           <span class="comment"># 强烈建议使用RIPv2，支持VLSM和认证</span></span><br><span class="line">[Huawei-rip-1] network 192.168.1.0 <span class="comment"># 宣告主类网络。例如，如果接口IP是192.168.1.1/24，则宣告192.168.1.0</span></span><br><span class="line">[Huawei-rip-1] network 10.0.0.0    <span class="comment"># 宣告另一个主类网络，例如A类网络10.0.0.0</span></span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong><br>假设路由器有一个接口G0&#x2F;0&#x2F;0，IP地址为 <code>192.168.1.1/24</code>，另一个接口G0&#x2F;0&#x2F;1，IP地址为 <code>10.1.1.1/24</code>。配置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Huawei] rip 1</span><br><span class="line">[Huawei-rip-1] version 2</span><br><span class="line">[Huawei-rip-1] network 192.168.1.0</span><br><span class="line">[Huawei-rip-1] network 10.0.0.0</span><br><span class="line"><span class="comment"># 注意：即使接口地址是10.1.1.1，也只需宣告其主类网络号 10.0.0.0</span></span><br></pre></td></tr></table></figure>

<h4 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2. 注意事项"></a>2. 注意事项</h4><ol>
<li><p><strong>宣告主类网络</strong>：这是最核心也最容易出错的地方。<code>network</code> 命令后跟的是<strong>有类网络地址</strong>，而不是子网或接口IP。RIP进程会检查所有直连接口的IP地址，只要落在该主类网络范围内，该接口就会：</p>
<ul>
<li>开始发送和接收RIP更新。</li>
<li>将该接口的IP网络地址宣告给邻居。</li>
</ul>
</li>
<li><p><strong>RIP版本</strong>：</p>
<ul>
<li><strong>RIPv1</strong>：广播更新、不支持VLSM、不支持认证。<strong>基本已淘汰</strong>。</li>
<li><strong>RIPv2</strong>：组播更新（224.0.0.9）、<strong>支持VLSM和CIDR</strong>、支持明文&#x2F;MD5认证。<strong>当前标准配置</strong>。</li>
<li>在与其他厂商设备互操作时，可能需要使用 <code>undo summary</code> 命令关闭自动汇总。</li>
</ul>
</li>
<li><p><strong>自动汇总</strong>：RIPv2默认开启<strong>自动汇总</strong>（在边界路由器上会将子网路由汇总为主类网络宣告出去）。在不连续子网环境中，这会导致路由问题，需要使用 <code>undo summary</code> 命令关闭。</p>
<p>好的，您的理解非常准确。与RIP、OSPF需要明确宣告网络范围不同，IS-IS的“宣告”方式确实非常独特，它<strong>不直接宣告IP网段</strong>，而是<strong>宣告路由器本身</strong>。</p>
<hr>
<h3 id="二、IS-IS路由协议"><a href="#二、IS-IS路由协议" class="headerlink" title="二、IS-IS路由协议"></a>二、IS-IS路由协议</h3><p>IS-IS是一个链路状态协议，最初为OSI（开放式系统互联）网络设计，后来被扩展以支持IP。它的核心思想是：每台路由器在链路状态协议数据单元中通告自己的链路状态信息，而不是直接宣告IP网络。</p>
<h4 id="1-“宣告”方式：启用IS-IS并分配NET地址"><a href="#1-“宣告”方式：启用IS-IS并分配NET地址" class="headerlink" title="1. “宣告”方式：启用IS-IS并分配NET地址"></a>1. “宣告”方式：启用IS-IS并分配NET地址</h4><p>在IS-IS中，所谓的“宣告”包含两个关键步骤：</p>
<ol>
<li><strong>在路由器上全局启用IS-IS进程，并为其分配一个网络实体名称。</strong></li>
<li><strong>在特定接口上启用IS-IS协议，使该接口参与IS-IS路由计算和邻接关系建立。</strong></li>
</ol>
<p><strong>基本配置步骤：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] isis [process-id]                  <span class="comment"># 启动IS-IS进程，进程ID默认为1</span></span><br><span class="line">[Huawei-isis-1] network-entity 49.0001.0010.0100.1001.00 <span class="comment"># 配置NET地址，这是路由器的唯一标识</span></span><br><span class="line">[Huawei-isis-1] quit</span><br><span class="line">[Huawei] interface gigabitethernet 0/0/0    <span class="comment"># 进入需要运行IS-IS的接口</span></span><br><span class="line">[Huawei-GigabitEthernet0/0/0] isis <span class="built_in">enable</span> [process-id] <span class="comment"># 在该接口上启用IS-IS</span></span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong><br>假设我们要在接口G0&#x2F;0&#x2F;0和G0&#x2F;0&#x2F;1上运行IS-IS。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Huawei] isis 1</span><br><span class="line">[Huawei-isis-1] network-entity 49.0001.0000.0000.0001.00</span><br><span class="line">[Huawei-isis-1] quit</span><br><span class="line">[Huawei] interface gigabitethernet 0/0/0</span><br><span class="line">[Huawei-GigabitEthernet0/0/0] isis <span class="built_in">enable</span> 1</span><br><span class="line">[Huawei-GigabitEthernet0/0/0] quit</span><br><span class="line">[Huawei] interface gigabitethernet 0/0/1</span><br><span class="line">[Huawei-GigabitEthernet0/0/1] isis <span class="built_in">enable</span> 1</span><br></pre></td></tr></table></figure>

<h4 id="2-核心机制与注意事项"><a href="#2-核心机制与注意事项" class="headerlink" title="2. 核心机制与注意事项"></a>2. 核心机制与注意事项</h4><ol>
<li><p><strong>NET地址</strong>：</p>
<ul>
<li>这是IS-IS中<strong>最重要</strong>的标识符，相当于OSPF中的Router-ID加上区域ID的结合体。</li>
<li><strong>格式</strong>：<code>AA.AAAA.BBBB.BBBB.BBBB.CC</code><ul>
<li><code>AA.AAAA</code>：区域地址（Area ID）。</li>
<li><code>BBBB.BBBB.BBBB</code>：系统ID（System ID），在一个域内必须唯一。通常由Loopback接口的MAC地址或IP地址转换而来。</li>
<li><code>CC</code>：SEL，对于IP路由而言，总是<code>00</code>。</li>
</ul>
</li>
<li>路由器通过NET地址来识别彼此和计算SPF树。</li>
</ul>
</li>
<li><p><strong>接口启用</strong>：</p>
<ul>
<li>在接口视图下使用 <code>isis enable</code> 命令后，该接口就会：<ul>
<li>发送和接收IS-IS Hello报文，与同一链路上的邻居建立邻接关系。</li>
<li>将该接口的<strong>IP地址和掩码</strong>作为<strong>TLV</strong>信息放入其LSP中，并泛洪给其他邻居。</li>
</ul>
</li>
<li><strong>间接宣告</strong>：路由器A在接口G0&#x2F;0&#x2F;0上配置了IP地址 <code>192.168.1.1/24</code> 并启用了IS-IS。那么，A会在自己生成的LSP中携带信息：“我连接到了一个IP网络 <code>192.168.1.0/24</code>”。其他路由器收到这个LSP后，就能学习到这条路由。</li>
</ul>
</li>
<li><p><strong>层级与网络类型</strong>：</p>
<ul>
<li><strong>层级</strong>：IS-IS有两级层级。<ul>
<li><code>is-level</code>： 可以配置为 <code>level-1</code>（类似OSPF的完全末节区域）、<code>level-2</code>（骨干路由器）或 <code>level-1-2</code>（默认，边界路由器）。</li>
</ul>
</li>
<li><strong>网络类型</strong>： 类似于OSPF，需要在接口下指定网络类型，如 <code>isis circuit-type p2p</code> 用于点对点链路，这对于正确建立邻接至关重要。</li>
</ul>
</li>
<li><p><strong>与RIP&#x2F;OSPF的对比总结</strong>：</p>
<ul>
<li><strong>RIP&#x2F;OSPF</strong>：<code>network &lt;IP网络&gt;</code> -&gt; <strong>宣告一个网络范围</strong>，落在该范围内的接口被激活。</li>
<li><strong>IS-IS</strong>：<code>network-entity &lt;NET&gt;</code> + <code>interface下 isis enable</code> -&gt; <strong>宣告路由器本身</strong>，并明确指定哪些接口参与通信。</li>
</ul>
</li>
</ol>
<p><strong>简单来说，IS-IS的“宣告”逻辑是：</strong> “大家好，我是路由器 <code>[NET]</code>，我连接到了以下这些IP网络…”，而这些网络信息是通过在接口上启用IS-IS来自动收集和分发的。</p>
</li>
</ol>
<hr>
<h3 id="三、OSPF路由协议"><a href="#三、OSPF路由协议" class="headerlink" title="三、OSPF路由协议"></a>三、OSPF路由协议</h3><p>OSPF是一种基于链路状态的内部网关协议。它的核心思想是：每台路由器通过泛洪LSA来描述自己周围的网络拓扑，所有路由器共同维护一个相同的链路状态数据库，然后各自独立地使用SPF算法计算出无环的最短路径树。</p>
<h4 id="1-宣告方式：在区域中宣告精确的网络范围"><a href="#1-宣告方式：在区域中宣告精确的网络范围" class="headerlink" title="1. 宣告方式：在区域中宣告精确的网络范围"></a>1. 宣告方式：在区域中宣告精确的网络范围</h4><p>与RIP宣告主类网络不同，OSPF使用 <code>network</code> 命令来<strong>精确地匹配接口</strong>，并将匹配成功的接口放入指定的OSPF区域中。宣告的本质是：“让这个接口参与OSPF路由进程，并将其连接的网段信息以LSA的形式发布出去。”</p>
<p><strong>基本配置步骤：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] ospf [process-id] router-id router-id  <span class="comment"># 启动OSPF进程并配置Router-ID</span></span><br><span class="line">[Huawei-ospf-1] area area-id                    <span class="comment"># 进入区域视图（通常是区域0）</span></span><br><span class="line">[Huawei-ospf-1-area-0.0.0.0] network ip-address wildcard-mask  <span class="comment"># 宣告网络（反掩码方式）</span></span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong><br>假设路由器有一个接口G0&#x2F;0&#x2F;0，IP地址为 <code>192.168.1.1/24</code>，另一个接口G0&#x2F;0&#x2F;1，IP地址为 <code>10.1.1.1/24</code>。我们希望G0&#x2F;0&#x2F;0在区域0，G0&#x2F;0&#x2F;1在区域1。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Huawei] ospf 1 router-id 1.1.1.1</span><br><span class="line">[Huawei-ospf-1] area 0</span><br><span class="line">[Huawei-ospf-1-area-0.0.0.0] network 192.168.1.0 0.0.0.255</span><br><span class="line">[Huawei-ospf-1] area 1</span><br><span class="line">[Huawei-ospf-1-area-0.0.0.1] network 10.1.1.0 0.0.0.255</span><br></pre></td></tr></table></figure>

<p><strong>关键点：反掩码</strong></p>
<ul>
<li>反掩码也叫通配符掩码，与子网掩码相反。</li>
<li><strong>0</strong> 表示需要精确匹配的位。</li>
<li><strong>1</strong> 表示忽略的位。</li>
<li>所以，对于 <code>192.168.1.0/24</code> 网段，其反掩码是 <code>0.0.0.255</code>。这条命令的意思是：将所有IP地址前24位（即192.168.1）匹配的接口激活OSPF，并放入相应区域。</li>
</ul>
<p><strong>更现代的宣告方式：在接口下直接启用OSPF</strong><br>华为设备也支持一种更直观、更精确的配置方式，推荐使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Huawei] ospf 1 router-id 1.1.1.1</span><br><span class="line">[Huawei-ospf-1] area 0</span><br><span class="line">[Huawei-ospf-1-area-0.0.0.0] quit</span><br><span class="line">[Huawei-ospf-1] quit</span><br><span class="line">[Huawei] interface gigabitethernet 0/0/0</span><br><span class="line">[Huawei-GigabitEthernet0/0/0] ospf <span class="built_in">enable</span> 1 area 0  <span class="comment"># 在该接口上直接启用OSPF并指定区域</span></span><br></pre></td></tr></table></figure>
<p>这种方式避免了反掩码的计算，更加清晰，不易出错。</p>
<h4 id="2-核心机制与注意事项-1"><a href="#2-核心机制与注意事项-1" class="headerlink" title="2. 核心机制与注意事项"></a>2. 核心机制与注意事项</h4><ol>
<li><p><strong>Router-ID</strong>：</p>
<ul>
<li>这是OSPF中路由器的唯一标识，格式类似于IP地址（如 <code>1.1.1.1</code>）。</li>
<li><strong>必须唯一</strong>，否则会导致路由计算混乱。通常手动配置为Loopback接口的IP地址，以确保稳定性。</li>
<li>选择顺序：手动配置 &gt; 最大Loopback接口IP &gt; 最大物理接口IP。</li>
</ul>
</li>
<li><p><strong>区域概念</strong>：</p>
<ul>
<li>OSPF通过<strong>区域</strong>来实现层次化设计和规模扩展。<strong>Area 0是骨干区域，是必需的</strong>，所有非骨干区域必须直接与Area 0相连。</li>
<li>宣告时必须指定接口所在的区域，这是RIP所没有的概念。</li>
</ul>
</li>
<li><p><strong>网络类型</strong>：</p>
<ul>
<li>OSPF接口有不同的网络类型（如Broadcast、P2P、NBMA、P2MP），这会直接影响邻居发现和DR&#x2F;BDR的选举。需要根据实际链路类型进行正确配置。</li>
</ul>
</li>
<li><p><strong>引入外部路由</strong>：与RIP类似，使用 <code>import-route</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-ospf-1] import-route static  <span class="comment"># 引入静态路由，默认为Type-2外部路由</span></span><br><span class="line">[Huawei-ospf-1] import-route rip 1    <span class="comment"># 引入RIP路由</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>总结比喻：</strong></p>
<ul>
<li><strong>RIP</strong> 像一个<strong>传令兵</strong>，每隔一段时间就跑到邻居那里告诉他：“我听说去往某某地方要经过X跳”。信息是二手、三手的，且相对模糊（只宣告主类网络）。</li>
<li><strong>OSPF</strong> 像一个<strong>测绘团队</strong>，每台路由器都会绘制自己周围的精确地图（LSA），然后大家互相交换地图碎片，最终每台路由器都拼出一张完整的网络地图（LSDB），并自己计算去往所有目的地的最短路径。宣告的接口就是地图上的精确坐标。</li>
</ul>
<hr>
<p>好的，我们来讲解BGP，并最后对RIP、OSPF和BGP的宣告方式进行对比总结。</p>
<hr>
<h3 id="四、BGP路由协议"><a href="#四、BGP路由协议" class="headerlink" title="四、BGP路由协议"></a>四、BGP路由协议</h3><p>BGP是一种路径矢量协议，也是事实上的互联网外部网关协议标准。与IGP（内部网关协议，如RIP、OSPF）不同，BGP的核心设计目标是<strong>在不同自治系统之间提供可控的、策略驱动的路由交换</strong>，而不是简单地寻找最短路径。</p>
<h4 id="1-宣告方式：手动、精确地发布网络"><a href="#1-宣告方式：手动、精确地发布网络" class="headerlink" title="1. 宣告方式：手动、精确地发布网络"></a>1. 宣告方式：手动、精确地发布网络</h4><p>BGP的宣告哲学与IGP完全不同。它<strong>不会自动宣告任何路由</strong>。你必须明确地告诉BGP进程：”请将这条路由发布给我的BGP邻居”。这种设计赋予了网络管理员极大的控制权。</p>
<p><strong>BGP路由注入的两种主要方式：</strong></p>
<ol>
<li><strong><code>network</code> 命令</strong></li>
<li><strong>重分发</strong></li>
</ol>
<p><strong>基本配置步骤：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] bgp as-number                    <span class="comment"># 启动BGP进程，指定本地AS号</span></span><br><span class="line">[Huawei-bgp] router-id router-id          <span class="comment"># 配置Router-ID（必须唯一）</span></span><br><span class="line">[Huawei-bgp] peer ip-address as-number as-number <span class="comment"># 配置BGP邻居（对等体）</span></span><br><span class="line">[Huawei-bgp] ipv4-family unicast          <span class="comment"># 进入IPv4单播地址族视图</span></span><br><span class="line">[Huawei-bgp-af-ipv4] network ip-address mask mask <span class="comment"># 精确宣告网络（必须带掩码）</span></span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong><br>假设公司AS号为65001，需要向BGP邻居（IP为2.2.2.2，AS号为65002）宣告网络 <code>192.168.1.0/24</code> 和 <code>10.1.0.0/16</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Huawei] bgp 65001</span><br><span class="line">[Huawei-bgp] router-id 1.1.1.1</span><br><span class="line">[Huawei-bgp] peer 2.2.2.2 as-number 65002</span><br><span class="line">[Huawei-bgp] ipv4-family unicast</span><br><span class="line">[Huawei-bgp-af-ipv4] network 192.168.1.0 mask 255.255.255.0</span><br><span class="line">[Huawei-bgp-af-ipv4] network 10.1.0.0 mask 255.255.0.0</span><br></pre></td></tr></table></figure>

<h4 id="2-核心机制与注意事项-2"><a href="#2-核心机制与注意事项-2" class="headerlink" title="2. 核心机制与注意事项"></a>2. 核心机制与注意事项</h4><ol>
<li><p><strong><code>network</code> 命令的条件</strong>：</p>
<ul>
<li>这是BGP中最重要也最容易混淆的一点。使用 <code>network</code> 命令宣告一条路由时，<strong>该路由必须已经存在于本地的IP路由表中</strong>（可以是直连路由、静态路由或IGP学习到的路由）。</li>
<li>BGP的 <code>network</code> 命令是 <strong>“发布”</strong> 命令，而非OSPF&#x2F;RIP的 <strong>“激活”</strong> 命令。它不激活任何接口，只是将IP路由表中已有的路由复制到BGP表中，然后发送给邻居。</li>
</ul>
</li>
<li><p><strong>重分发</strong>：</p>
<ul>
<li>另一种常见方式是将IGP路由或静态路由重分发到BGP中。</li>
<li><strong>命令</strong>：<code>[Huawei-bgp-af-ipv4] import-route ospf 1</code> 或 <code>import-route static</code></li>
<li><strong>注意</strong>：重分发需要非常小心，因为它可能意外地将内部路由泄露到互联网上。通常建议使用精确的 <code>network</code> 命令来控制要宣告的路由。</li>
</ul>
</li>
<li><p><strong>邻居关系</strong>：</p>
<ul>
<li>BGP邻居（对等体）必须<strong>手动指定</strong>，这与IGP的自动发现邻居截然不同。</li>
<li>邻居可以是不同AS的（EBGP），也可以是同一AS内的（IBGP）。两者行为有显著差异（如EBGP默认跳数、IBGP的水平分割规则）。</li>
</ul>
</li>
<li><p><strong>策略驱动</strong>：</p>
<ul>
<li>BGP的强大之处在于其丰富的路径属性（如AS_PATH、NEXT_HOP、LOCAL_PREF、MED等）。</li>
<li>宣告路由时，通常会配合路由策略来修改这些属性，以影响入站和出站的流量路径。例如，使用 <code>filter-policy</code> 或 <code>route-policy</code> 来过滤或设置属性。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="RIP、OSPF、BGP宣告方式对比总结"><a href="#RIP、OSPF、BGP宣告方式对比总结" class="headerlink" title="RIP、OSPF、BGP宣告方式对比总结"></a>RIP、OSPF、BGP宣告方式对比总结</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">RIP</th>
<th align="left">OSPF</th>
<th align="left">BGP</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>协议类型</strong></td>
<td align="left">距离矢量IGP</td>
<td align="left">链路状态IGP</td>
<td align="left">路径矢量EGP</td>
</tr>
<tr>
<td align="left"><strong>宣告哲学</strong></td>
<td align="left"><strong>激活接口</strong>以宣告其所在主类网络</td>
<td align="left"><strong>激活接口</strong>到特定区域以宣告其精确网络</td>
<td align="left"><strong>发布</strong>IP路由表中已存在的特定路由</td>
</tr>
<tr>
<td align="left"><strong>宣告命令</strong></td>
<td align="left"><code>network 10.0.0.0</code></td>
<td align="left"><code>network 10.1.1.0 0.0.0.255 area 0</code> 或 <code>接口下 ospf enable</code></td>
<td align="left"><code>network 10.1.0.0 mask 255.255.0.0</code></td>
</tr>
<tr>
<td align="left"><strong>关键参数</strong></td>
<td align="left">主类网络号</td>
<td align="left"><strong>区域ID</strong>、网络地址+<strong>反掩码</strong></td>
<td align="left"><strong>AS号</strong>、网络地址+<strong>掩码</strong></td>
</tr>
<tr>
<td align="left"><strong>自动性</strong></td>
<td align="left">自动宣告匹配接口的<strong>主类网络</strong></td>
<td align="left">自动宣告匹配接口的<strong>精确网络</strong></td>
<td align="left"><strong>完全不自动</strong>，必须手动发布每条路由</td>
</tr>
<tr>
<td align="left"><strong>控制粒度</strong></td>
<td align="left">粗（按主类网络）</td>
<td align="left">细（按接口&#x2F;精确网络）</td>
<td align="left"><strong>最精细</strong>（按任意前缀&#x2F;掩码）</td>
</tr>
<tr>
<td align="left"><strong>邻居建立</strong></td>
<td align="left">自动（广播&#x2F;组播）</td>
<td align="left">自动（组播）</td>
<td align="left"><strong>手动</strong>指定每个邻居</td>
</tr>
<tr>
<td align="left"><strong>设计目标</strong></td>
<td align="left">简单互通，找”跳数少”的路径</td>
<td align="left">快速收敛，找”成本低”的最优路径</td>
<td align="left"><strong>策略控制</strong>，找”符合策略”的路径</td>
</tr>
</tbody></table>
<p><strong>总结比喻：</strong></p>
<ul>
<li><strong>RIP</strong> 像一个<strong>社区广播</strong>：”我们小区（主类网络）的人可以互相串门了！” 信息比较模糊。</li>
<li><strong>OSPF</strong> 像一个<strong>城市规划局</strong>，将城市划分为不同的<strong>区域</strong>，并精确绘制每条街道（接口网络）的地图，让大家都能找到最优路径。</li>
<li><strong>BGP</strong> 像一个<strong>国家间的外交官</strong>，他不会自动透露任何信息。只有当本国政府（IP路由表）明确授权，并且他手动准备好外交照会（<code>network</code>命令）后，他才会<strong>有选择地、附带各种条件地</strong>将特定信息（路由）告知给<strong>手动指定</strong>的外国大使（BGP邻居）。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/21/%E5%AF%B9%E6%AF%94RIP%EF%BC%8CIS-IS%EF%BC%8COSPF%EF%BC%8CBGP%E5%9B%9B%E5%A4%A7%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%EF%BC%881%EF%BC%89%E5%AE%A3%E5%91%8A%E8%B7%AF%E7%94%B1/" data-id="cuidJUNFcsj9aFN11W8W9blQ_" data-title="对比RIP，IS-IS，OSPF，BGP四大路由协议（1）宣告路由" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" rel="tag">网络工程师</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-对比策略路由和路由策略的不同" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/19/%E5%AF%B9%E6%AF%94%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1%E5%92%8C%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5%E7%9A%84%E4%B8%8D%E5%90%8C/" class="article-date">
  <time class="dt-published" datetime="2025-10-19T11:15:39.000Z" itemprop="datePublished">2025-10-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/19/%E5%AF%B9%E6%AF%94%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1%E5%92%8C%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5%E7%9A%84%E4%B8%8D%E5%90%8C/">对比路由策略和策略路由的不同</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>简单来说，核心区别在于：</p>
<ul>
<li><strong>路由策略</strong>：控制<strong>路由信息</strong>的流动路径，影响的是<strong>路由表</strong>。它回答的问题是：“哪些路由信息可以被学习、发布或接收？”</li>
<li><strong>策略路由</strong>：控制<strong>数据包</strong>的转发路径，影响的是<strong>数据包的转发行为</strong>。它回答的问题是：“对于特定的数据包，我应该走哪条路径，而不是根据路由表？”</li>
</ul>
<p>下面我们通过一个详细的对比表格和解释来深入理解它们的差异。</p>
<hr>
<h3 id="策略路由-vs-路由策略-详细对比"><a href="#策略路由-vs-路由策略-详细对比" class="headerlink" title="策略路由 vs. 路由策略 详细对比"></a><strong>策略路由 vs. 路由策略 详细对比</strong></h3><table>
<thead>
<tr>
<th align="left">对比维度</th>
<th align="left"><strong>策略路由</strong></th>
<th align="left"><strong>路由策略</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心本质</strong></td>
<td align="left"><strong>“路”不由“表”定</strong></td>
<td align="left"><strong>“表”由“策”定</strong></td>
</tr>
<tr>
<td align="left"><strong>英文术语</strong></td>
<td align="left">Policy-Based Routing</td>
<td align="left">Route Policy &#x2F; Routing Policy</td>
</tr>
<tr>
<td align="left"><strong>操作对象</strong></td>
<td align="left"><strong>数据包</strong></td>
<td align="left"><strong>路由信息</strong></td>
</tr>
<tr>
<td align="left"><strong>工作层次</strong></td>
<td align="left">数据转发层面</td>
<td align="left">路由控制层面</td>
</tr>
<tr>
<td align="left"><strong>决策依据</strong></td>
<td align="left">源IP地址、目的IP地址、协议类型、端口号、报文大小、入接口等<strong>丰富的条件</strong></td>
<td align="left">通常基于<strong>目的地址</strong>（以及路由属性如AS-Path、Community、MED等）</td>
</tr>
<tr>
<td align="left"><strong>优先级</strong></td>
<td align="left"><strong>高于</strong> 传统路由表。当PBR生效时，它会<strong>绕过</strong>标准路由表进行转发决策。</td>
<td align="left"><strong>影响</strong> 传统路由表。它决定了哪些路由能进入路由表，从而间接影响转发。</td>
</tr>
<tr>
<td align="left"><strong>主要工具</strong></td>
<td align="left"><strong>Route-map</strong>（在接口下通过 <code>ip policy route-map</code> 调用）</td>
<td align="left"><strong>Route-map, Filter-list, Prefix-list, AS-Path ACL</strong> 等</td>
</tr>
<tr>
<td align="left"><strong>应用场景</strong></td>
<td align="left">1. <strong>基于源IP的选路</strong>（如不同网段走不同ISP）<br>2. <strong>负载分担</strong>（非基于目的地址的）<br>3. <strong>服务质量</strong>（将特定流量引向防火墙、优化器等）</td>
<td align="left">1. <strong>路由过滤</strong>（只接收或发布特定路由）<br>2. <strong>路由属性修改</strong>（如BGP的Local_Pref, MED, AS_Path）<br>3. <strong>路由引入</strong>（在路由协议间重分布时进行过滤和属性设置）</td>
</tr>
<tr>
<td align="left"><strong>配置位置</strong></td>
<td align="left">通常在<strong>入方向接口</strong>上应用</td>
<td align="left">通常在<strong>路由协议</strong>的配置中（如 <code>neighbor</code> 语句下）或<strong>重分布</strong>点时应用</td>
</tr>
<tr>
<td align="left"><strong>资源消耗</strong></td>
<td align="left"><strong>较高</strong>。因为需要对每个数据包进行复杂的策略匹配。</td>
<td align="left"><strong>较低</strong>。仅在路由信息更新时进行计算。</td>
</tr>
</tbody></table>
<hr>
<h3 id="通俗比喻"><a href="#通俗比喻" class="headerlink" title="通俗比喻"></a><strong>通俗比喻</strong></h3><p>为了更好地理解，我们可以用一个<strong>快递分拣系统</strong>来比喻：</p>
<ul>
<li><p><strong>路由策略</strong> 就像是<strong>快递公司的总部规则</strong>：</p>
<ul>
<li>规则决定了哪些地区的包裹信息（路由）可以被接收和发送到各个分拣中心（路由器）。</li>
<li>例如，“我们不接收来自A地区的包裹信息”，或者“所有发往B地区的包裹信息，都标记为高优先级”。</li>
<li>最终，每个分拣中心都形成了一张“我们能派送的区域表”（路由表）。</li>
</ul>
</li>
<li><p><strong>策略路由</strong> 就像是<strong>某个特定分拣中心的自定义流水线</strong>：</p>
<ul>
<li>尽管总部的“区域表”上说“发往B地区的包裹都走陆路”，但这个分拣中心额外规定：“<strong>所有从X小区来的</strong>，发往B地区的包裹，全部走<strong>空运</strong>”。</li>
<li>这个规定<strong>凌驾于</strong>总部的“区域表”之上，它不看目的地是否相同，而是看更具体的来源等特征。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="典型配置示例"><a href="#典型配置示例" class="headerlink" title="典型配置示例"></a><strong>典型配置示例</strong></h3><p>假设一个网络场景：路由器有两个出口，一个连接到ISP1 (10.1.1.1)，另一个连接到ISP2 (20.1.1.1)。</p>
<h4 id="1-路由策略场景"><a href="#1-路由策略场景" class="headerlink" title="1. 路由策略场景"></a><strong>1. 路由策略场景</strong></h4><p><strong>目标</strong>：在运行BGP时，只从ISP1学习关于 <code>192.168.0.0/16</code> 网段的路由。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">! 创建一个前缀列表，定义我们感兴趣的路由</span><br><span class="line">ip prefix-list FROM-ISP1 permit 192.168.0.0/16</span><br><span class="line"></span><br><span class="line">! 创建一个Route-map来调用这个前缀列表</span><br><span class="line">route-map ROUTE-POLICY permit 10</span><br><span class="line"> match ip address prefix-list FROM-ISP1</span><br><span class="line"></span><br><span class="line">! 在BGP进程中，对来自ISP1邻居的路由应用这个策略</span><br><span class="line">router bgp 100</span><br><span class="line"> neighbor 10.1.1.1 route-map ROUTE-POLICY <span class="keyword">in</span></span><br></pre></td></tr></table></figure>
<p><strong>效果</strong>：只有 <code>192.168.0.0/16</code> 这条路由会被放入路由表，其他从ISP1发来的路由将被过滤掉。</p>
<h4 id="2-策略路由场景"><a href="#2-策略路由场景" class="headerlink" title="2. 策略路由场景"></a><strong>2. 策略路由场景</strong></h4><p><strong>目标</strong>：将所有来自 <code>172.16.1.0/24</code> 网段的流量，强制发送到ISP2，即使路由表指出最佳路径是ISP1。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">! 创建一个ACL来匹配感兴趣的流量（基于源IP）</span><br><span class="line">access-list 100 permit ip 172.16.1.0 0.0.0.255 any</span><br><span class="line"></span><br><span class="line">! 创建一个Route-map来定义动作</span><br><span class="line">route-map PBR permit 10</span><br><span class="line"> match ip address 100</span><br><span class="line"> <span class="built_in">set</span> ip next-hop 20.1.1.1  ! 强制设置下一跳为ISP2</span><br><span class="line"></span><br><span class="line">! 在接收到流量的入口接口上应用PBR</span><br><span class="line">interface GigabitEthernet0/0</span><br><span class="line"> ip policy route-map PBR</span><br></pre></td></tr></table></figure>
<p><strong>效果</strong>：当数据包从 <code>GigabitEthernet0/0</code> 进入，且源IP是 <code>172.16.1.0/24</code> 时，路由器会忽略自己的路由表，直接将其转发给 <code>20.1.1.1</code> (ISP2)。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">策略路由</th>
<th align="left">路由策略</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心</strong></td>
<td align="left">控制数据包路径</td>
<td align="left">控制路由信息</td>
</tr>
<tr>
<td align="left"><strong>对象</strong></td>
<td align="left">数据包</td>
<td align="left">路由</td>
</tr>
<tr>
<td align="left"><strong>优先级</strong></td>
<td align="left">高（覆盖路由表）</td>
<td align="left">低（生成路由表）</td>
</tr>
<tr>
<td align="left"><strong>资源消耗</strong></td>
<td align="left">高</td>
<td align="left">低</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">精细化的流量工程</td>
<td align="left">路由协议的管理和优化</td>
</tr>
</tbody></table>
<p>简单来说，<strong>路由策略是“管理地图”，而策略路由是“指挥司机”</strong>。前者决定了你手里地图上画了哪些路，后者则是在实际开车时，命令司机无视地图，直接开向某条特定的路。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/19/%E5%AF%B9%E6%AF%94%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1%E5%92%8C%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5%E7%9A%84%E4%B8%8D%E5%90%8C/" data-id="cuid9ircXoipknYPpKwMw22iZ" data-title="对比路由策略和策略路由的不同" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-探讨反掩码的作用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/19/%E6%8E%A2%E8%AE%A8%E5%8F%8D%E6%8E%A9%E7%A0%81%E7%9A%84%E4%BD%9C%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2025-10-19T10:37:03.000Z" itemprop="datePublished">2025-10-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/19/%E6%8E%A2%E8%AE%A8%E5%8F%8D%E6%8E%A9%E7%A0%81%E7%9A%84%E4%BD%9C%E7%94%A8/">探讨反掩码的作用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>普通掩码（子网掩码）和反掩码虽然都使用32位二进制格式，但它们的设计目的和逻辑是完全相反的。普通掩码用于IP地址划分，用连续的1和0表示，而反掩码是匹配工具，用0和1表示要检查或忽略的位。</strong></p>
<p>因此，在ACL和OSPF宣告这种需要“匹配”或“指定范围”的场景下，反掩码比普通掩码更灵活、更精确。</p>
<p>下面我们来详细解释为什么。</p>
<hr>
<h3 id="1-核心概念：目的不同"><a href="#1-核心概念：目的不同" class="headerlink" title="1. 核心概念：目的不同"></a>1. 核心概念：目的不同</h3><ul>
<li><p><strong>普通掩码（子网掩码）</strong></p>
<ul>
<li><strong>目的：</strong> 定义一个IP地址中哪部分是<strong>网络位</strong>，哪部分是<strong>主机位</strong>。</li>
<li><strong>逻辑：</strong> 掩码中的 <code>1</code> 表示网络位，<code>0</code> 表示主机位。它必须是<strong>连续的</strong>1和0。</li>
<li><strong>例子：</strong> <code>255.255.255.0</code> (<code>/24</code>) 表示前24位是网络地址，后8位是主机地址。它定义的是一个<strong>连续的、完整的</strong>IP地址段。</li>
</ul>
</li>
<li><p><strong>反掩码</strong></p>
<ul>
<li><strong>目的：</strong> 作为一个<strong>通配符掩码</strong>，用来匹配一个或多个IP地址。</li>
<li><strong>逻辑：</strong> 掩码中的 <code>0</code> 表示“<strong>必须精确匹配</strong>”，<code>1</code> 表示“<strong>不关心，可以任意</strong>”。</li>
<li><strong>例子：</strong> <code>0.0.0.255</code> 表示前24位必须精确匹配，后8位可以是任意值。</li>
</ul>
</li>
</ul>
<h3 id="2-为什么在ACL中使用反掩码？"><a href="#2-为什么在ACL中使用反掩码？" class="headerlink" title="2. 为什么在ACL中使用反掩码？"></a>2. 为什么在ACL中使用反掩码？</h3><p>访问控制列表的核心功能是<strong>匹配数据包的源&#x2F;目标IP地址，并执行允许或拒绝操作</strong>。这种匹配通常不是针对单个主机，而是针对一个网段，甚至是多个不连续的IP。</p>
<ul>
<li><p><strong>场景1：匹配一个完整的子网</strong></p>
<ul>
<li>你想允许 <code>192.168.1.0/24</code> 这个网段的所有主机。</li>
<li><strong>ACL语句：</strong> <code>permit 192.168.1.0 0.0.0.255</code></li>
<li><strong>解释：</strong><ul>
<li>IP地址： <code>192.168.1.0</code> (这是一个代表网段的参考点)</li>
<li>反掩码： <code>0.0.0.255</code> (二进制为 <code>00000000.00000000.00000000.11111111</code>)</li>
<li>匹配规则：前三个八位组 (<code>192.168.1</code>) 必须精确匹配 (<code>0</code>)，最后一个八位组可以是任何值 (<code>255</code>)。所以它匹配从 <code>192.168.1.0</code> 到 <code>192.168.1.255</code> 的所有IP。</li>
</ul>
</li>
<li><strong>这里用普通掩码 <code>255.255.255.0</code> 是无法实现这种“匹配”逻辑的。</strong></li>
</ul>
</li>
<li><p><strong>场景2：匹配一个特定主机</strong></p>
<ul>
<li>你想拒绝主机 <code>192.168.1.10</code>。</li>
<li><strong>ACL语句：</strong> <code>deny 192.168.1.10 0.0.0.0</code></li>
<li><strong>解释：</strong> 反掩码全是 <code>0</code>，表示所有32位都必须精确匹配。这等同于 <code>host 192.168.1.10</code> 命令。</li>
</ul>
</li>
<li><p><strong>场景3：匹配不连续的IP（反掩码的超级优势）</strong></p>
<ul>
<li>假设你想匹配 <code>192.168.1.1</code> 和 <code>192.168.1.3</code> 这两个IP。用普通掩码无法定义一个包含这两个IP的连续网段。</li>
<li><strong>ACL语句：</strong> <code>permit 192.168.1.1 0.0.0.2</code></li>
<li><strong>解释：</strong><ul>
<li>IP地址： <code>192.168.1.1</code> (二进制最后8位: <code>000000**01**</code>)</li>
<li>反掩码： <code>0.0.0.2</code> (二进制最后8位: <code>000000**10**</code>)</li>
<li>匹配规则：前24位精确匹配，最后8位中，只有对应反掩码为 <code>0</code> 的位需要匹配。看最后一位：<ul>
<li>第1位 (最低位)：反掩码是 <code>0</code>，必须匹配IP地址的 <code>1</code>。</li>
<li>第2位：反掩码是 <code>1</code>，不关心。</li>
<li>其他位都是 <code>0</code>，必须匹配IP地址的 <code>0</code>。</li>
</ul>
</li>
<li>所以可能的组合是：<ul>
<li><code>...00000001</code> (十进制 1) -&gt; <strong>匹配</strong></li>
<li><code>...00000011</code> (十进制 3) -&gt; <strong>匹配</strong></li>
</ul>
</li>
<li>这样就巧妙地匹配了两个不连续的IP。<strong>这是普通掩码绝对做不到的。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-为什么在OSPF宣告中使用反掩码？"><a href="#3-为什么在OSPF宣告中使用反掩码？" class="headerlink" title="3. 为什么在OSPF宣告中使用反掩码？"></a>3. 为什么在OSPF宣告中使用反掩码？</h3><p>在OSPF中，使用 <code>network</code> 命令时，反掩码的作用是<strong>告诉路由器，哪些接口的IP地址应该被“宣告”到OSPF进程中</strong>。</p>
<ul>
<li><strong>场景：</strong> 你有一个路由器，接口1的IP是 <code>10.1.1.1/24</code>，接口2的IP是 <code>172.16.1.1/24</code>。你只想把 <code>10.1.1.0/24</code> 这个网段宣告到OSPF区域0。</li>
<li><strong>OSPF配置：</strong> <code>network 10.1.1.0 0.0.0.255 area 0</code></li>
<li><strong>解释：</strong><ul>
<li>路由器会检查它所有接口的IP地址。</li>
<li>对于每个接口IP，用它和 <code>network</code> 命令中的 <code>IP + 反掩码</code> 进行运算。</li>
<li>如果 <code>(接口IP) XOR (network命令中的IP)</code> 然后 <code>AND (反掩码)</code> 的结果为 <code>0</code>，则该接口被激活OSPF。</li>
<li>简单理解就是：接口IP的前24位如果是 <code>10.1.1</code>，那么这个接口就会加入OSPF进程，并在区域0中宣告其连接的网段 <code>10.1.1.0/24</code>。</li>
</ul>
</li>
</ul>
<p>这里使用反掩码，同样是为了提供<strong>精确控制</strong>，让你可以灵活地选择将哪个精确的网段（甚至是不连续的网段）宣告到OSPF中，而不是只能宣告一个主类网络。</p>
<hr>
<h3 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">普通掩码（子网掩码）</th>
<th align="left">反掩码（通配符掩码）</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>设计目的</strong></td>
<td align="left"><strong>定义</strong>一个IP地址的网络和主机部分。</td>
<td align="left"><strong>匹配</strong>一个或多个IP地址。</td>
</tr>
<tr>
<td align="left"><strong>逻辑</strong></td>
<td align="left"><code>1</code> &#x3D; 网络位， <code>0</code> &#x3D; 主机位。</td>
<td align="left"><code>0</code> &#x3D; 精确匹配， <code>1</code> &#x3D; 不关心（任意）。</td>
</tr>
<tr>
<td align="left"><strong>连续性</strong></td>
<td align="left"><strong>必须</strong>是连续的1和0。</td>
<td align="left"><strong>可以是任意组合</strong>的0和1。</td>
</tr>
<tr>
<td align="left"><strong>灵活性</strong></td>
<td align="left">较低，只能定义标准的、连续的IP网段。</td>
<td align="left"><strong>极高</strong>，可以匹配单个主机、连续网段、甚至不连续的IP。</td>
</tr>
<tr>
<td align="left"><strong>主要应用</strong></td>
<td align="left">IP地址规划、子网划分、路由器接口配置。</td>
<td align="left">ACL、OSPF&#x2F;BGP的 <code>network</code> 命令、NAT等需要精确匹配的场景。</td>
</tr>
</tbody></table>
<p><strong>结论：</strong> 不是普通的掩码不能起作用，而是因为它“起作用”的方式（定义网络）与ACL和OSPF宣告所需要的“匹配”功能不匹配。反掩码凭借其“通配符”的特性，为网络匹配操作提供了无与伦比的灵活性和精确度，因此成为了这些场景下的标准选择。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/19/%E6%8E%A2%E8%AE%A8%E5%8F%8D%E6%8E%A9%E7%A0%81%E7%9A%84%E4%BD%9C%E7%94%A8/" data-id="cuidpKbuz0P_m-HB_FuEN5bqp" data-title="探讨反掩码的作用" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" rel="tag">网络工程师</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-浅析路由的控制层面与转发层面" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/19/%E6%B5%85%E6%9E%90%E8%B7%AF%E7%94%B1%E7%9A%84%E6%8E%A7%E5%88%B6%E5%B1%82%E9%9D%A2%E4%B8%8E%E8%BD%AC%E5%8F%91%E5%B1%82%E9%9D%A2/" class="article-date">
  <time class="dt-published" datetime="2025-10-19T09:38:54.000Z" itemprop="datePublished">2025-10-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/19/%E6%B5%85%E6%9E%90%E8%B7%AF%E7%94%B1%E7%9A%84%E6%8E%A7%E5%88%B6%E5%B1%82%E9%9D%A2%E4%B8%8E%E8%BD%AC%E5%8F%91%E5%B1%82%E9%9D%A2/">浅析路由的控制层面与转发层面</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一-关于控制层面和转发层面"><a href="#一-关于控制层面和转发层面" class="headerlink" title="一.关于控制层面和转发层面"></a>一.关于控制层面和转发层面</h2><p>路由器的控制层面和转发层面。这个概念是现代路由器架构的基石，理解了它，就能理解路由器如何工作、如何进行故障排查以及SDN（软件定义网络）的革命性意义。</p>
<hr>
<h3 id="核心概念：一个形象的比喻"><a href="#核心概念：一个形象的比喻" class="headerlink" title="核心概念：一个形象的比喻"></a>核心概念：一个形象的比喻</h3><p>为了更好地理解，我们可以把<strong>路由器</strong>比作一个<strong>城市的交通管理系统</strong>：</p>
<ul>
<li><strong>控制层面</strong>：相当于<strong>交通管理局</strong>。它负责制定全市的交通规则、绘制道路地图（路由表）、根据实时事故（网络拓扑变化）更新导航APP。它进行的是全局性的、智能的决策。</li>
<li><strong>转发层面</strong>：相当于<strong>每个路口的交警或交通信号灯</strong>。他们不关心城市整体路况，只负责根据现有的交通规则和目的地指示牌，指挥每一辆到达路口的车（数据包）应该往哪个方向走。他们进行的是局部的、高速的、重复性的执行。</li>
</ul>
<hr>
<h3 id="1-控制层面"><a href="#1-控制层面" class="headerlink" title="1. 控制层面"></a>1. 控制层面</h3><p>控制层面是路由器的“大脑”，负责<strong>学习和生成路由信息</strong>，并最终构建出路由表。</p>
<h4 id="主要功能："><a href="#主要功能：" class="headerlink" title="主要功能："></a>主要功能：</h4><ol>
<li><p><strong>运行路由协议</strong>：</p>
<ul>
<li>与相邻的路由器通过OSPF、BGP、EIGRP等路由协议进行通信。</li>
<li>互相交换和学习网络拓扑信息（如链路状态、路径属性等）。</li>
</ul>
</li>
<li><p><strong>维护路由信息库</strong>：</p>
<ul>
<li>将从各个路由协议学到的、以及直连路由、静态路由等所有路由信息存储在一个数据库中。</li>
</ul>
</li>
<li><p><strong>执行路由决策</strong>：</p>
<ul>
<li>根据特定的算法（如SPF算法 for OSPF）或策略（如BGP路径属性），从RIB中选择出到达每个目标网络的最佳路径。</li>
</ul>
</li>
<li><p><strong>生成转发信息库</strong>：</p>
<ul>
<li>将最终确定的最佳路径信息安装到<strong>路由表</strong> 中，这个表就是转发层面实际使用的“地图”。在高端路由器上，控制平面会将这个表优化后生成一个更适合硬件快速查找的表，即<strong>转发信息库</strong>，并下发给转发层面。</li>
</ul>
</li>
</ol>
<h4 id="关键特点："><a href="#关键特点：" class="headerlink" title="关键特点："></a>关键特点：</h4><ul>
<li><strong>智能的、决策性的</strong>：它负责思考和计算。</li>
<li><strong>基于CPU和软件</strong>：运行复杂的路由算法，消耗CPU和内存资源。</li>
<li><strong>异步工作</strong>：路由更新和计算是事件驱动的（如链路up&#x2F;down），不是定时发生的。</li>
<li><strong>全局视角</strong>：了解网络的整体拓扑结构。</li>
</ul>
<hr>
<h3 id="2-转发层面"><a href="#2-转发层面" class="headerlink" title="2. 转发层面"></a>2. 转发层面</h3><p>转发层面是路由器的“肌肉”，负责<strong>根据控制层面生成的FIB，对每一个到达的数据包执行转发操作</strong>。</p>
<h4 id="主要功能：-1"><a href="#主要功能：-1" class="headerlink" title="主要功能："></a>主要功能：</h4><ol>
<li><strong>数据包接收</strong>：在入接口接收数据链路层帧，解封装出IP数据包。</li>
<li><strong>查找FIB</strong>：提取数据包中的<strong>目标IP地址</strong>，在FIB中进行最长前缀匹配查找，确定出接口和下一跳IP地址。</li>
<li><strong>重写数据链路层头</strong>：根据ARP表或邻居发现协议，将下一跳IP地址解析为MAC地址，并重写数据帧的源&#x2F;目标MAC地址。</li>
<li><strong>数据包发送</strong>：将重新封装好的数据帧从确定的出接口发送出去。</li>
</ol>
<h4 id="关键特点：-1"><a href="#关键特点：-1" class="headerlink" title="关键特点："></a>关键特点：</h4><ul>
<li><strong>无状态的、执行性的</strong>：它不做决策，只执行命令。</li>
<li><strong>基于专用硬件</strong>：为了达到线速转发，现代路由器使用<strong>ASIC</strong>、<strong>NPU</strong> 等专用芯片进行查找和转发，速度极快（纳秒级）。</li>
<li><strong>同步工作</strong>：对每一个数据包都执行相同的、流水线式的操作。</li>
<li><strong>局部视角</strong>：只关心当前数据包的目标地址和FIB中的对应条目，不关心网络全局。</li>
</ul>
<hr>
<h3 id="两者关系总结"><a href="#两者关系总结" class="headerlink" title="两者关系总结"></a>两者关系总结</h3><table>
<thead>
<tr>
<th align="left">特性维度</th>
<th align="left">控制层面</th>
<th align="left">转发层面</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>功能</strong></td>
<td align="left"><strong>路由</strong>：学习和决策，生成“地图”</td>
<td align="left"><strong>交换</strong>：查找和执行，按照“地图”行驶</td>
</tr>
<tr>
<td align="left"><strong>处理对象</strong></td>
<td align="left">路由协议报文</td>
<td align="left">用户数据包</td>
</tr>
<tr>
<td align="left"><strong>工作频率</strong></td>
<td align="left">低频、异步</td>
<td align="left">高频、同步（每个数据包）</td>
</tr>
<tr>
<td align="left"><strong>性能关键</strong></td>
<td align="left">CPU、内存</td>
<td align="left">吞吐量、延迟、丢包率</td>
</tr>
<tr>
<td align="left"><strong>资源依赖</strong></td>
<td align="left">软件、通用处理器</td>
<td align="left">专用硬件、ASIC&#x2F;TCAM</td>
</tr>
<tr>
<td align="left"><strong>视角</strong></td>
<td align="left">全局网络拓扑</td>
<td align="left">单个数据包的目的地</td>
</tr>
</tbody></table>
<p><strong>关系流程</strong>：<br><code>路由协议通信</code> -&gt; <code>控制层面计算最佳路径</code> -&gt; <code>更新路由表和FIB</code> -&gt; <code>转发层面查询FIB</code> -&gt; <code>转发数据包</code></p>
<hr>
<h3 id="故障排查中的应用"><a href="#故障排查中的应用" class="headerlink" title="故障排查中的应用"></a>故障排查中的应用</h3><p>理解这两个层面可以极大地帮助网络故障排查：</p>
<ol>
<li><p><strong>连通性故障</strong>：PC无法访问服务器。</p>
<ul>
<li><strong>检查控制层面</strong>：在沿途路由器上使用 <code>show ip route &lt;server_ip&gt;</code> 命令。如果路由表中没有相应的路由条目，问题出在控制层面（路由协议未学习到、静态路由缺失等）。</li>
<li><strong>检查转发层面</strong>：如果路由表中有正确的路由条目，但数据包还是过不去，问题可能出在转发层面（ACL拦截、策略路由、硬件故障等）。</li>
</ul>
</li>
<li><p><strong>路径异常</strong>：数据包走了错误的路径。</p>
<ul>
<li>这通常是<strong>控制层面</strong>的问题，因为路径选择是由控制层面决定的（如BGP策略配置错误、OSPF成本值设置不当）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="与SDN的关联"><a href="#与SDN的关联" class="headerlink" title="与SDN的关联"></a>与SDN的关联</h3><p>软件定义网络（SDN）的核心思想正是<strong>将控制层面与转发层面彻底分离</strong>。</p>
<ul>
<li><strong>传统网络</strong>：每个路由器都集成了自己的控制层面和转发层面，是分布式的大脑。</li>
<li><strong>SDN网络</strong>：<ul>
<li><strong>控制层面</strong>被集中到一个独立的、逻辑上的<strong>SDN控制器</strong>中。控制器拥有全网视图，并向所有交换机下发流表。</li>
<li><strong>转发层面</strong>保留在交换机上（称为<strong>数据平面</strong>），但变得非常“笨”，它只负责根据控制器下发的<strong>流表</strong> 来转发数据包。</li>
</ul>
</li>
</ul>
<p>这种分离带来了网络的集中管理、灵活编程和自动化等巨大优势。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>控制层面决定“去哪走”，转发层面负责“怎么走”</strong>。这两个层面各司其职，一个负责全局的、智能的路径计算，一个负责局部的、高速的数据包转发，共同构成了路由器高效、可靠工作的基础。理解它们的区别和联系，是掌握路由技术和现代网络架构的关键。</p>
<h2 id="二-ACL与IP前缀列表中的应用理念"><a href="#二-ACL与IP前缀列表中的应用理念" class="headerlink" title="二.ACL与IP前缀列表中的应用理念"></a>二.ACL与IP前缀列表中的应用理念</h2><p>那么，在ACL和IP前缀列表两大应用中，ACL可以用于数据过滤和网段匹配，IP前缀列表只可用于网段匹配。这两个哪些对应控制层面，哪些对应转发层面？</p>
<p>我们首先需要理解ACL（访问控制列表）和IP前缀列表在网络设备中的常见应用场景。</p>
<ul>
<li>ACL：通常用于过滤数据包，可以基于源&#x2F;目标IP、协议、端口等。它既可以用在控制层面过滤路由信息（如过滤路由更新），也可以用在前向转发层面过滤数据包。</li>
<li>IP前缀列表：通常用于匹配IP网段（即路由前缀），一般用于控制层面，例如在路由策略中匹配特定的路由前缀，从而进行路由的过滤或属性修改。</li>
</ul>
<p>现在，问题问的是这两个工具分别对应控制层面和转发层面。注意，ACL可以用于两个层面，而IP前缀列表只用于控制层面。</p>
<p>具体来说：</p>
<ul>
<li>在控制层面，ACL可以用于过滤路由更新（例如，在OSPF或BGP中，使用ACL来匹配路由前缀，从而决定接受或拒绝某些路由）。但ACL在控制层面的使用不如IP前缀列表灵活，因为ACL不能直接匹配前缀长度（掩码），而IP前缀列表可以同时匹配前缀和掩码长度。</li>
<li>在转发层面，ACL用于过滤数据包（例如，在接口上应用ACL来允许或拒绝数据包通过）。IP前缀列表一般不用于转发层面，因为它设计的目的就是为路由策略服务的。</li>
</ul>
<p>因此，我们可以总结：</p>
<ul>
<li>ACL：既可用于控制层面（路由过滤），也可用于转发层面（数据包过滤）。</li>
<li>IP前缀列表：仅用于控制层面（路由过滤）。</li>
</ul>
<p>所以，回答这个问题：</p>
<ul>
<li>对应控制层面的有：ACL（部分功能）和IP前缀列表。</li>
<li>对应转发层面的有：ACL（部分功能）。</li>
</ul>
<p>但是，问题表述是“这两个那些对应控制层面，那些对应转发层面”，所以我们分别说明：</p>
<ul>
<li>ACL：在控制层面和转发层面都有应用。</li>
<li>IP前缀列表：只用于控制层面。</li>
</ul>
<p>注意：在具体设备上，ACL和IP前缀列表的应用可能略有不同，但这是通用概念。</p>
<h2 id="三-各种路由协议的详细体现"><a href="#三-各种路由协议的详细体现" class="headerlink" title="三.各种路由协议的详细体现"></a>三.各种路由协议的详细体现</h2><p>另一个问题，各种路由协议（RIP，IS-IS，OSPF，BGP等）体现的是路由的控制层面还是转发层面？</p>
<p><strong>先说结论：所有路由协议（RIP，IS-IS，OSPF，BGP等）本身都属于控制层面。</strong></p>
<p>它们是控制层面最核心、最活跃的组成部分，是路由器“大脑”中进行思考和交流的部分。</p>
<hr>
<h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><p>我们可以把控制层面想象成一个公司的“战略决策部门”，而不同的路由协议就像是部门内部不同的沟通和决策机制。</p>
<h4 id="为什么它们属于控制层面？"><a href="#为什么它们属于控制层面？" class="headerlink" title="为什么它们属于控制层面？"></a>为什么它们属于控制层面？</h4><ol>
<li><strong>处理的对象是路由信息，而非数据包</strong>：<ul>
<li>路由协议之间互相发送和接收的是<strong>路由更新报文</strong>（例如OSPF的LSA、BGP的Update消息）。这些报文的内容是“我已知哪些网络，路径成本是多少”等信息。</li>
<li>它们<strong>不处理</strong>用户的真实数据流量（如你浏览的网页、下载的文件）。用户数据是由<strong>转发层面</strong>处理的。</li>
</ul>
</li>
<li><strong>核心功能是构建和更新路由表</strong>：<ul>
<li>所有路由协议的最终目的，都是通过各自的算法（如RIP的跳数、OSPF的SPF算法、BGP的路径属性比较），计算出到达所有已知目标网络的最佳路径。</li>
<li>计算出的最优路径最终会被安装到路由器的<strong>路由表</strong>中。这个路由表就是控制层面输出给转发层面的“最终指令集”。</li>
</ul>
</li>
<li><strong>工作方式是异步和事件驱动的</strong>：<ul>
<li>它们通常在后台运行，定期发送keepalive消息，或者在网络拓扑发生变化时（如链路故障）触发更新。这不是对每个数据包都进行的操作。</li>
</ul>
</li>
</ol>
<h3 id="不同路由协议在控制层面的特点"><a href="#不同路由协议在控制层面的特点" class="headerlink" title="不同路由协议在控制层面的特点"></a>不同路由协议在控制层面的特点</h3><p>尽管都属于控制层面，但它们在控制层面内部扮演的角色和运作方式有所不同：</p>
<table>
<thead>
<tr>
<th align="left">路由协议</th>
<th align="left">在控制层面中的角色与特点</th>
<th align="left">控制层面交互方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>RIP</strong></td>
<td align="left">一种简单的“距离矢量”协议。路由器之间互相告知“我到某网的距离是X跳”。</td>
<td align="left">周期性地向邻居广播整个路由表。</td>
</tr>
<tr>
<td align="left"><strong>OSPF</strong></td>
<td align="left">一种复杂的“链路状态”协议。路由器之间同步整个区域的网络拓扑地图，然后各自独立计算最短路径。</td>
<td align="left">通过组播发送链路状态通告，只在拓扑变化时进行增量更新。</td>
</tr>
<tr>
<td align="left"><strong>IS-IS</strong></td>
<td align="left">另一种“链路状态”协议，在机制上与OSPF类似，但源于OSI模型，通常用于大型运营商网络。</td>
<td align="left">与OSPF类似，使用LSP进行链路状态信息的同步。</td>
</tr>
<tr>
<td align="left"><strong>BGP</strong></td>
<td align="left">一种“路径矢量”协议，用于在不同自治系统之间交换路由信息。其决策基于丰富的策略和路径属性。</td>
<td align="left">通过可靠的TCP会话与对等体建立连接，进行增量更新。</td>
</tr>
</tbody></table>
<h3 id="与控制层面和转发层面的关系"><a href="#与控制层面和转发层面的关系" class="headerlink" title="与控制层面和转发层面的关系"></a>与控制层面和转发层面的关系</h3><ol>
<li><strong>控制层面</strong>：路由协议作为核心引擎，通过互相通信，生成路由表（RIB），并最终生成转发信息库（FIB）。</li>
<li><strong>转发层面</strong>：不运行任何路由协议。它只做一件事：当数据包到达时，查询控制层面下发的FIB，然后执行转发动作。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>路由协议是控制层面的核心引擎</strong>：没有它们，控制层面就无法自动学习路由，路由器就只能依靠手工配置的静态路由来工作。</li>
<li><strong>它们为转发层面提供“导航地图”</strong>：路由协议辛勤工作的最终产物，就是一张详尽且最优的“路径地图”（FIB），转发层面则依赖这张地图来高效地转发每一个数据包。</li>
</ul>
<p>所以，当您在想RIP、IS-IS、OSPF、BGP时，您应该立即联想到它们是在<strong>控制层面</strong>负责“路由决策”的智能协议。而IP转发、ACL过滤等操作，则是在<strong>转发层面</strong>负责“数据包搬运”的执行过程。</p>
<h2 id="四-静态路由与默认路由的体现"><a href="#四-静态路由与默认路由的体现" class="headerlink" title="四.静态路由与默认路由的体现"></a>四.静态路由与默认路由的体现</h2><p><strong>静态路由和默认路由也同样属于控制层面。</strong></p>
<p>它们同样是控制层面用于“决策”和“生成路由表”的一种方式，只不过其“智能”的来源不同。</p>
<hr>
<h3 id="详细分析-1"><a href="#详细分析-1" class="headerlink" title="详细分析"></a>详细分析</h3><p>让我们回到那个“交通管理系统”的比喻：</p>
<ul>
<li><strong>动态路由协议（OSPF&#x2F;BGP等）</strong>：像是一个<strong>实时的交通信息网络</strong>。每个路由器（交通节点）自动与邻居交换路况信息，共同计算并实时更新出最优路径。这是<strong>分布式、自动的智能</strong>。</li>
<li><strong>静态路由</strong>：则像是<strong>交通管理员手动绘制在地图上的固定路线</strong>。管理员明确指定：“要去往目的地A，必须从X路口出去。” 路由器无需与其他路由器通信，直接听从这条指令。</li>
<li><strong>默认路由</strong>：是一种特殊的静态路由，它像是<strong>指向“主干道”或“高速公路”的通用指示牌</strong>，上面写着：“所有没有明确指示目的地的车辆，请全部驶入此路。” 它是一个捕获所有未知流量的最后手段。</li>
</ul>
<h3 id="为什么它们属于控制层面？-1"><a href="#为什么它们属于控制层面？-1" class="headerlink" title="为什么它们属于控制层面？"></a>为什么它们属于控制层面？</h3><ol>
<li><p><strong>它们直接影响路由表（RIB）的生成</strong>：</p>
<ul>
<li>当您在路由器上输入 <code>ip route 192.168.2.0 255.255.255.0 10.1.1.1</code> 这条静态路由命令后，这条路径信息会<strong>直接被安装到路由表</strong>中。</li>
<li>控制层面的核心任务就是“构建路由表”。无论是通过动态协议学来的，还是通过手工配置输入的，都是路由条目的来源。</li>
</ul>
</li>
<li><p><strong>它们是转发层面的“指令”来源</strong>：</p>
<ul>
<li>控制层面将静态路由和默认路由加入到路由表后，同样会将其最优路径<strong>下发到转发信息库（FIB）</strong> 中。</li>
<li>转发层面在转发数据包时，并不会区分这条路由是来自OSPF还是静态配置。它只是盲目地查询FIB并执行转发。</li>
<li><strong>例如</strong>：一个去往 <code>192.168.2.10</code> 的数据包到达路由器，转发层面在FIB中查找到匹配的静态路由条目，然后就会从指定接口转发给下一跳 <code>10.1.1.1</code>。</li>
</ul>
</li>
<li><p><strong>它们参与控制层面的决策过程</strong>：</p>
<ul>
<li>路由器可能会从多个来源学到通往同一目的地的路由（如同时从OSPF和静态路由学到）。这时，控制层面会根据<strong>管理距离</strong> 这个值来决策哪个来源更可信，并将最可信的路由安装到路由表中。</li>
<li>静态路由通常拥有一个很小的管理距离（例如1或更小），这意味着它比大多数动态路由协议（如OSPF的管理距离是110）更受信任。</li>
</ul>
</li>
</ol>
<h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">动态路由协议 (OSPF&#x2F;BGP等)</th>
<th align="left">静态路由 &#x2F; 默认路由</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>本质</strong></td>
<td align="left"><strong>自动、分布式智能</strong></td>
<td align="left"><strong>手动、集中式智能</strong></td>
</tr>
<tr>
<td align="left"><strong>控制层面工作</strong></td>
<td align="left">与邻居通信、运行算法、计算路径</td>
<td align="left">网络管理员直接输入路径信息</td>
</tr>
<tr>
<td align="left"><strong>路由信息来源</strong></td>
<td align="left">其他路由器</td>
<td align="left">本机配置（config）</td>
</tr>
<tr>
<td align="left"><strong>开销与灵活性</strong></td>
<td align="left">占用CPU、内存资源；灵活，能自动适应拓扑变化</td>
<td align="left">无运行时开销；不灵活，拓扑变化需手动修改</td>
</tr>
<tr>
<td align="left"><strong>在控制层面的角色</strong></td>
<td align="left"><strong>自动路由发现与计算</strong></td>
<td align="left"><strong>手动路由注入</strong></td>
</tr>
</tbody></table>
<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>您可以这样理解控制层面的构成：</p>
<p><strong>控制层面 &#x3D; 动态路由协议（负责自动学习） + 静态&#x2F;默认路由（负责手动指定） + 其他来源（如直连路由）</strong></p>
<p>它们共同协作，有时也相互竞争（通过管理距离），最终汇集成一张完整的“网络地图”——<strong>路由表</strong>。这张地图随后被交给转发层面去执行。</p>
<p>所以，无论是动态路由协议还是静态路由，它们都是<strong>控制层面</strong>用于回答“数据包应该往哪去？”这个核心问题的方法。它们的区别在于<strong>获取答案的方式</strong>是自动还是手动，而它们<strong>所属的逻辑层面</strong>是完全一致的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/19/%E6%B5%85%E6%9E%90%E8%B7%AF%E7%94%B1%E7%9A%84%E6%8E%A7%E5%88%B6%E5%B1%82%E9%9D%A2%E4%B8%8E%E8%BD%AC%E5%8F%91%E5%B1%82%E9%9D%A2/" data-id="cuidsjJKpI4zwe6h6Am73EkvK" data-title="浅析路由的控制层面与转发层面" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" rel="tag">网络工程师</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-浅析静态路由与直连路由" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/16/%E6%B5%85%E6%9E%90%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E4%B8%8E%E7%9B%B4%E8%BF%9E%E8%B7%AF%E7%94%B1/" class="article-date">
  <time class="dt-published" datetime="2025-10-16T15:22:31.000Z" itemprop="datePublished">2025-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/16/%E6%B5%85%E6%9E%90%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E4%B8%8E%E7%9B%B4%E8%BF%9E%E8%B7%AF%E7%94%B1/">浅析静态路由与直连路由</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一.关于直连路由</p>
<p>路由器访问直连网段时使用直连路由。直连路由的接口配置了IP地址并且处于up状态，<br>直连路由会自动产生，不需要任何配置。</p>
<p>二.静态路由</p>
<p>静态路由一般用于小型网络规模，不能根据网络的变更进行动态路由学习。配置形式<br>一般为：<em>目标网段 目标网段掩码 下一跳地址（本地出接口）</em></p>
<p>三.缺省路由</p>
<p>缺省路由是静态路由的一种特殊形态，一般用在内网三层设备需要访问互联网。配置<br>形式一般为：<em>0.0.0.0 0.0.0.0 下一跳地址（本地出接口）</em></p>
<p>多说一句，个人其实一般习惯把缺省路由叫做默认路由，以便于理解。</p>
<p>关于“缺省”这个专有名词的翻译，之前还特意和AI讨论过这方面问题，关于“缺省”是否可以同义替换为“默认”这个词。以下是AI对此的分析：</p>
<ol>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">### 一、为什么是“缺省”？—— 词源探秘</span><br><span class="line"></span><br><span class="line">“缺省”是一个典型的**意译词**，它翻译自英文术语 **“Default”**。</span><br><span class="line"></span><br><span class="line">要理解这个古怪的翻译，我们需要拆解一下“Default”在英文中的核心含义：</span><br><span class="line"></span><br><span class="line">- **De-**： 一个前缀，有“否定”、“离开”、“向下”的意思。</span><br><span class="line">- **-fault**： 来自拉丁语 *fallere*，意思是“欺骗、失败、辜负期望”。（和“fault”错误同源）</span><br><span class="line"></span><br><span class="line">所以，“Default”的本质是：</span><br><span class="line">**“由于（用户）未能做出（某个选择或提供某个信息），而由系统自动采用的一个预先设定好的（退而求其次的）选项或行为。”**</span><br><span class="line"></span><br><span class="line">中文译者当年在翻译时，抓住了这个“未能”和“缺失”的核心，将其拆解为：</span><br><span class="line"></span><br><span class="line">- **缺**： 缺失、缺乏、缺少。对应“未能提供”。</span><br><span class="line">- **省**： 省略、省去。对应“（用户）省略了操作”或“（系统）省去了判断”。</span><br><span class="line"></span><br><span class="line">因此，“缺省”直译过来就是 **“因缺失而省略”** 或 **“在用户缺位/未指定时，系统省去询问环节而采用的方案”** 。虽然逻辑上能自洽，但确实非常拗口，不符合日常语言习惯。相比之下，“默认”（默默地承认/认定）这个词就形象和自然得多。</span><br><span class="line"></span><br><span class="line">**结论：** 在绝大多数情况下，**“缺省” = “默认”**。你可以放心地在脑海里进行替换。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### 二、除了“缺省路由”，还有哪些地方会用到“缺省”？</span><br><span class="line"></span><br><span class="line">“缺省”这个概念在计算机科学中无处不在，只要有一个地方需要预设一个“保底”的、或“当用户不指定时”就启用的值或行为，就会用到它。以下是一些常见的例子：</span><br><span class="line"></span><br><span class="line">#### 1. 缺省路由</span><br><span class="line"></span><br><span class="line">这你已经提到了。它是路由表中的最后一条“保底”规则，当所有其他路由规则都不匹配目标IP地址时，数据包就会被发送到缺省路由所指向的**下一跳地址**（通常是网关路由器）。可以理解为“不知道去哪的数据包都往这儿送”。</span><br><span class="line"></span><br><span class="line">#### 2. 缺省网关</span><br><span class="line"></span><br><span class="line">这个概念和缺省路由紧密相关。**缺省网关**就是一个设备的**缺省路由所指的那个IP地址**。在你的电脑上，网络设置里填写的“默认网关”就是你这台电脑的缺省网关。你的电脑要访问互联网，所有非本地的流量都会先发给这个网关。</span><br><span class="line"></span><br><span class="line">#### 3. 缺省值</span><br><span class="line"></span><br><span class="line">这是最广泛的应用。指在用户没有显式提供值时，程序或系统自动使用的那个预设值。</span><br><span class="line"></span><br><span class="line">- **编程中**： 函数参数可以设置缺省值。例如 `function greet(name = &quot;Guest&quot;)`，如果你调用 `greet()` 不传参数，`name` 的缺省值就是 `&quot;Guest&quot;`。</span><br><span class="line">- **数据库中**： 可以为表的字段设置缺省值。例如一个 `users` 表的 `create_date` 字段，可以设置缺省值为 `CURRENT_TIMESTAMP`，这样当插入新数据没指定时间时，数据库会自动填入当前时间。</span><br><span class="line">- **软件设置中**： 软件的“恢复默认设置”功能，就是将所有配置重置为出厂时的**缺省值**。</span><br><span class="line"></span><br><span class="line">#### 4. 缺省配置 / 配置文件</span><br><span class="line"></span><br><span class="line">许多软件在启动时会加载一个 `default.conf` 或 `config.default.yml` 之类的**缺省配置文件**。如果用户没有创建自己的配置文件，或者自己的配置里缺少某些选项，系统就会使用这些缺省配置中的值。</span><br><span class="line"></span><br><span class="line">#### 5. 缺省构造函数</span><br><span class="line"></span><br><span class="line">在面向对象编程（如C++、Java、C#）中，指一个不需要提供任何参数的构造函数。当程序员没有为类编写任何构造函数时，编译器会自动生成一个缺省构造函数。</span><br><span class="line"></span><br><span class="line">#### 6. 缺省参数</span><br><span class="line"></span><br><span class="line">在函数调用或API请求中，如果某些参数是可选的，当调用者省略它们时，这些参数就会使用预先定义好的**缺省参数**。</span><br><span class="line"></span><br><span class="line">#### 7. 法律和金融领域的延伸</span><br><span class="line"></span><br><span class="line">甚至在计算机领域之外，“default”这个词也广泛使用，并同样被（生硬地）翻译为“缺省”。</span><br><span class="line"></span><br><span class="line">- **缺省判决**： 法律术语。指在庭审中，一方（通常是被告）未能出庭或未能答辩，法官据此作出的对其不利的判决。</span><br><span class="line">- **债务缺省**： 金融术语。指债务人未能履行偿还债务的合同义务，即“违约”。（这里的“缺省”和“违约”是同一个英文词“Default”）。</span><br><span class="line"></span><br><span class="line">### 总结与建议</span><br><span class="line"></span><br><span class="line">1. **直接理解**： 今后在任何计算机文献中看到“缺省”，请毫不犹豫地在心里将其替换为“默认”。你的理解是完全正确的。</span><br><span class="line">2. **知其所以然**： 了解“缺省”来自“Default”，并且其本意是“因用户缺失/省略操作而由系统采用的方案”，这能帮助你更深刻地理解这个概念，而不仅仅是死记硬背一个词。</span><br><span class="line">3. **沟通时灵活运用**： 在书面文档或正式场合，使用“缺省”是规范且专业的。但在日常口头交流中，说“默认路由”、“默认网关”所有人都能听懂，且更自然。这类似于很多人会把“URI”直接说成“网址”，虽然不精确但沟通效率高。</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/16/%E6%B5%85%E6%9E%90%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E4%B8%8E%E7%9B%B4%E8%BF%9E%E8%B7%AF%E7%94%B1/" data-id="cuidBsvi7ty895CKX3wH15EE2" data-title="浅析静态路由与直连路由" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" rel="tag">网络工程师</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/16/hello-world/" class="article-date">
  <time class="dt-published" datetime="2025-10-16T15:15:08.778Z" itemprop="datePublished">2025-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/16/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/16/hello-world/" data-id="cuidFTgcr-gVYPt8mlzcxXS1d" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-IS-IS-IS-IS路由协议基本概念" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/13/IS-IS-IS-IS%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="article-date">
  <time class="dt-published" datetime="2025-10-13T09:05:58.000Z" itemprop="datePublished">2025-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/13/IS-IS-IS-IS%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">[IS-IS]IS-IS路由协议基本概念</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>IS-IS链路状态路由协议，采用Dijkstra（迪杰斯特拉）算法，路由优先级15。</p>
<p>IS-IS的地址结构由IDP（初始域）和DSP（域指定）组成，但是通常直接使用NET地址作为协议地址（NET地址包括区域ID、系统ID、固定字段）。</p>
<p>IS-IS使用cost作为路由度量， 一条IS-IS路径的cost等于本路由器到达目标网段。沿途的所有路由传递方向入接口的cost总和，cost值越小，路径越优。与OSPF不同的是，IS-IS接口的cost在缺省情况下并不与接口带宽相关（在实际部署时，IS-IS也支持根据带宽调整cost值），无论接口带宽多大，缺省时cost为10。</p>
<p>支持路由过滤，路由聚合，修改cost，默认路由下发，路由认证等路由优化功能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/13/IS-IS-IS-IS%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" data-id="cuidpGFjfvpuyyskjVwiyK9vc" data-title="[IS-IS]IS-IS路由协议基本概念" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IS-IS/" rel="tag">IS-IS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" rel="tag">网络工程师</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/" rel="tag">路由协议</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-RIP-RIP路由协议基本概念" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/13/RIP-RIP%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="article-date">
  <time class="dt-published" datetime="2025-10-13T09:02:48.000Z" itemprop="datePublished">2025-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/13/RIP-RIP%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">[RIP]RIP路由协议基本概念</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>RIP距离矢量路由协议，使用的路由算法是Bellman-Ford（贝尔曼-福特），以经过三层节点个数（跳数）为衡量路径最优的标准，经过节点最多不能超过15跳，16跳为目标不可达。</p>
<p>路由采用周期更新机制。</p>
<p>报文封装在传输层，基于UDP的520端口发送消息。</p>
<p>每个路由器只会学到邻居路由器的信息，不知道整个网络的拓扑结构。每次路由更新最多承载25条路由。</p>
<p>支持路由过滤，路由聚合（RIPv1不支持），修改跳数值，默认路由下发，路由认证等路由优化功能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/13/RIP-RIP%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" data-id="cuidupDWMZDZgIhFrAF0_yXoH" data-title="[RIP]RIP路由协议基本概念" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RIP/" rel="tag">RIP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" rel="tag">网络工程师</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/" rel="tag">路由协议</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-OSPF-一篇文章讲清楚OSPF路由协议的七步邻接关系建立步骤" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/11/OSPF-%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%AE%B2%E6%B8%85%E6%A5%9AOSPF%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%83%E6%AD%A5%E9%82%BB%E6%8E%A5%E5%85%B3%E7%B3%BB%E5%BB%BA%E7%AB%8B%E6%AD%A5%E9%AA%A4/" class="article-date">
  <time class="dt-published" datetime="2025-10-11T08:34:48.000Z" itemprop="datePublished">2025-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/11/OSPF-%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%AE%B2%E6%B8%85%E6%A5%9AOSPF%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%83%E6%AD%A5%E9%82%BB%E6%8E%A5%E5%85%B3%E7%B3%BB%E5%BB%BA%E7%AB%8B%E6%AD%A5%E9%AA%A4/">[OSPF]一篇文章讲清楚OSPF路由协议的七步邻接关系建立步骤</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>整个建立过程可以划分为以下几个关键状态，其流程如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A[Down状态&lt;br&gt;初始状态] --&gt; B[Init状态&lt;br&gt;收到Hello包]</span><br><span class="line">    B --&gt; C[2-Way状态&lt;br&gt;在Hello包中看到自己的RID]</span><br><span class="line">    C --&gt; D[ExStart状态&lt;br&gt;主从协商]</span><br><span class="line">    D --&gt; E[Exchange状态&lt;br&gt;交换DBD摘要]</span><br><span class="line">    E --&gt; F[Loading状态&lt;br&gt;请求并加载LSA]</span><br><span class="line">    F --&gt; G[Full状态&lt;br&gt;完全邻接]</span><br></pre></td></tr></table></figure>

<p>现在，我们来详细解释每一个状态：</p>
<ol>
<li><strong>Down (失效状态)</strong><ul>
<li><strong>描述</strong>: 这是邻接关系的初始状态。表示没有从邻居收到任何信息（Hello包）。</li>
<li><strong>动作</strong>: 本地路由器会周期性地向外发送Hello包，尝试发现邻居。</li>
</ul>
</li>
<li><strong>Init (初始状态)</strong><ul>
<li><strong>描述</strong>: 本地路由器<strong>收到了对端发来的Hello包</strong>，但Hello包中<strong>没有包含自己的Router ID (RID)</strong>。这意味着对方还没有收到我的Hello包，或者我的参数不符合它的要求。</li>
<li><strong>动作</strong>: 继续交互Hello包。</li>
</ul>
</li>
<li><strong>2-Way (双向通信状态)</strong><ul>
<li><strong>描述</strong>: 这是<strong>建立邻接关系的关键前提</strong>。本地路由器在收到的Hello包中，看到了<strong>自己的Router ID</strong>。这表明双向通信已经建立。</li>
<li><strong>决策点</strong>:<ul>
<li>在<strong>广播多路访问网络（如以太网）</strong> 中，DR（指定路由器）和BDR（备份指定路由器）将在此状态后与其他路由器继续建立邻接（FULL），而非DR&#x2F;BDR路由器之间会停留在此状态。</li>
<li>在<strong>点对点网络</strong>中，所有邻居都会继续向下一个状态发展。</li>
</ul>
</li>
</ul>
</li>
<li><strong>ExStart (预启动状态)</strong><ul>
<li><strong>描述</strong>: 这是<strong>邻接关系（而不仅仅是邻居关系）的真正开始</strong>。双方使用<strong>空的DBD（数据库描述）包</strong>来<strong>协商主从关系</strong>。</li>
<li><strong>目的</strong>: 确定在接下来的数据交换过程中，由谁作为“主”设备来控制交换过程。RID更大的一方将成为主设备。</li>
</ul>
</li>
<li><strong>Exchange (交换状态)</strong><ul>
<li><strong>描述</strong>: 主从关系协商完毕后，双方进入此状态。开始互相发送<strong>包含LSDB（链路状态数据库）摘要信息的DBD包</strong>。</li>
<li><strong>目的</strong>: 通过交换“目录”，互相了解对方有哪些LSA（链路状态通告）是自己没有的。</li>
</ul>
</li>
<li><strong>Loading (加载状态)</strong><ul>
<li><strong>描述</strong>: 在收到对端的DBD后，本地路由器会将自身的LSDB与收到的摘要进行对比。</li>
<li><strong>动作</strong>:<ul>
<li>如果发现自己缺少某条LSA，就会向对方发送<strong>LSR（链路状态请求）</strong>。</li>
<li>对方会回复<strong>LSU（链路状态更新）</strong> 来传递完整的LSA信息。</li>
<li>本地路由器收到LSU后，会发送<strong>LSAck（链路状态确认）</strong> 进行确认。</li>
</ul>
</li>
<li>图中的 <code>LSR</code>, <code>LSU</code>, <code>LSAck</code> 报文就是在此状态交互的。</li>
</ul>
</li>
<li><strong>Full (完全邻接状态)</strong><ul>
<li><strong>描述</strong>: 这是邻接关系建立的<strong>最终稳定状态</strong>。此时，双方路由器的<strong>LSDB已经完全同步</strong>。</li>
<li><strong>意义</strong>: 达到此状态后，路由器才能基于完全同步的LSDB，使用SPF算法独立计算出一致且无环的路由表。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="示意图中报文类型说明"><a href="#示意图中报文类型说明" class="headerlink" title="示意图中报文类型说明"></a>示意图中报文类型说明</h3><ul>
<li><strong>Hello</strong>: 用于发现和维持邻居关系。</li>
<li><strong>DD (Database Description Packet)</strong>: 用于描述自己的LSDB摘要，在ExStart和Exchange状态交换。</li>
<li><strong>LSR (Link State Request Packet)</strong>: 用于请求完整的LSA。</li>
<li><strong>LSU (Link State Update Packet)</strong>: 用于发送完整的LSA。</li>
<li><strong>LSAck (Link State Acknowledgment Packet)</strong>: 用于确认收到LSU。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>OSPF邻接关系的建立是一个严谨的“状态机”过程，从Down到Full，每一步都有特定的任务和报文交互。你的示意图完美地展示了这个完整的生命周期。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/11/OSPF-%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%AE%B2%E6%B8%85%E6%A5%9AOSPF%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%83%E6%AD%A5%E9%82%BB%E6%8E%A5%E5%85%B3%E7%B3%BB%E5%BB%BA%E7%AB%8B%E6%AD%A5%E9%AA%A4/" data-id="cuid9JCjC1Kzz7GGG8MhM-V8y" data-title="[OSPF]一篇文章讲清楚OSPF路由协议的七步邻接关系建立步骤" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OSPF/" rel="tag">OSPF</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" rel="tag">网络工程师</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/" rel="tag">路由协议</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BGP/" rel="tag">BGP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IS-IS/" rel="tag">IS-IS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OSPF/" rel="tag">OSPF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RIP/" rel="tag">RIP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/" rel="tag">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" rel="tag">网络工程师</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/" rel="tag">路由协议</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BGP/" style="font-size: 15px;">BGP</a> <a href="/tags/IS-IS/" style="font-size: 10px;">IS-IS</a> <a href="/tags/OSPF/" style="font-size: 12.5px;">OSPF</a> <a href="/tags/RIP/" style="font-size: 10px;">RIP</a> <a href="/tags/github/" style="font-size: 12.5px;">github</a> <a href="/tags/hexo/" style="font-size: 12.5px;">hexo</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" style="font-size: 20px;">网络工程师</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 20px;">计算机网络</a> <a href="/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/" style="font-size: 17.5px;">路由协议</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/10/">October 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">September 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/10/23/%E5%AF%B9%E6%AF%94RIP%EF%BC%8CIS-IS%EF%BC%8COSPF%EF%BC%8CBGP%E5%9B%9B%E5%A4%A7%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%EF%BC%882%EF%BC%89%E8%B7%AF%E7%94%B1%E8%81%9A%E5%90%88/">对比RIP，IS-IS，OSPF，BGP四大路由协议（2）路由聚合</a>
          </li>
        
          <li>
            <a href="/2025/10/21/%E5%AF%B9%E6%AF%94RIP%EF%BC%8CIS-IS%EF%BC%8COSPF%EF%BC%8CBGP%E5%9B%9B%E5%A4%A7%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%EF%BC%881%EF%BC%89%E5%AE%A3%E5%91%8A%E8%B7%AF%E7%94%B1/">对比RIP，IS-IS，OSPF，BGP四大路由协议（1）宣告路由</a>
          </li>
        
          <li>
            <a href="/2025/10/19/%E5%AF%B9%E6%AF%94%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1%E5%92%8C%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5%E7%9A%84%E4%B8%8D%E5%90%8C/">对比路由策略和策略路由的不同</a>
          </li>
        
          <li>
            <a href="/2025/10/19/%E6%8E%A2%E8%AE%A8%E5%8F%8D%E6%8E%A9%E7%A0%81%E7%9A%84%E4%BD%9C%E7%94%A8/">探讨反掩码的作用</a>
          </li>
        
          <li>
            <a href="/2025/10/19/%E6%B5%85%E6%9E%90%E8%B7%AF%E7%94%B1%E7%9A%84%E6%8E%A7%E5%88%B6%E5%B1%82%E9%9D%A2%E4%B8%8E%E8%BD%AC%E5%8F%91%E5%B1%82%E9%9D%A2/">浅析路由的控制层面与转发层面</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>