<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 8.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-对比策略路由和路由策略的不同" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/19/%E5%AF%B9%E6%AF%94%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1%E5%92%8C%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5%E7%9A%84%E4%B8%8D%E5%90%8C/" class="article-date">
  <time class="dt-published" datetime="2025-10-19T11:15:39.000Z" itemprop="datePublished">2025-10-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/19/%E5%AF%B9%E6%AF%94%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1%E5%92%8C%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5%E7%9A%84%E4%B8%8D%E5%90%8C/">对比路由策略和策略路由的不同</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>简单来说，核心区别在于：</p>
<ul>
<li><strong>路由策略</strong>：控制<strong>路由信息</strong>的流动路径，影响的是<strong>路由表</strong>。它回答的问题是：“哪些路由信息可以被学习、发布或接收？”</li>
<li><strong>策略路由</strong>：控制<strong>数据包</strong>的转发路径，影响的是<strong>数据包的转发行为</strong>。它回答的问题是：“对于特定的数据包，我应该走哪条路径，而不是根据路由表？”</li>
</ul>
<p>下面我们通过一个详细的对比表格和解释来深入理解它们的差异。</p>
<hr>
<h3 id="策略路由-vs-路由策略-详细对比"><a href="#策略路由-vs-路由策略-详细对比" class="headerlink" title="策略路由 vs. 路由策略 详细对比"></a><strong>策略路由 vs. 路由策略 详细对比</strong></h3><table>
<thead>
<tr>
<th align="left">对比维度</th>
<th align="left"><strong>策略路由</strong></th>
<th align="left"><strong>路由策略</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心本质</strong></td>
<td align="left"><strong>“路”不由“表”定</strong></td>
<td align="left"><strong>“表”由“策”定</strong></td>
</tr>
<tr>
<td align="left"><strong>英文术语</strong></td>
<td align="left">Policy-Based Routing</td>
<td align="left">Route Policy &#x2F; Routing Policy</td>
</tr>
<tr>
<td align="left"><strong>操作对象</strong></td>
<td align="left"><strong>数据包</strong></td>
<td align="left"><strong>路由信息</strong></td>
</tr>
<tr>
<td align="left"><strong>工作层次</strong></td>
<td align="left">数据转发层面</td>
<td align="left">路由控制层面</td>
</tr>
<tr>
<td align="left"><strong>决策依据</strong></td>
<td align="left">源IP地址、目的IP地址、协议类型、端口号、报文大小、入接口等<strong>丰富的条件</strong></td>
<td align="left">通常基于<strong>目的地址</strong>（以及路由属性如AS-Path、Community、MED等）</td>
</tr>
<tr>
<td align="left"><strong>优先级</strong></td>
<td align="left"><strong>高于</strong> 传统路由表。当PBR生效时，它会<strong>绕过</strong>标准路由表进行转发决策。</td>
<td align="left"><strong>影响</strong> 传统路由表。它决定了哪些路由能进入路由表，从而间接影响转发。</td>
</tr>
<tr>
<td align="left"><strong>主要工具</strong></td>
<td align="left"><strong>Route-map</strong>（在接口下通过 <code>ip policy route-map</code> 调用）</td>
<td align="left"><strong>Route-map, Filter-list, Prefix-list, AS-Path ACL</strong> 等</td>
</tr>
<tr>
<td align="left"><strong>应用场景</strong></td>
<td align="left">1. <strong>基于源IP的选路</strong>（如不同网段走不同ISP）<br>2. <strong>负载分担</strong>（非基于目的地址的）<br>3. <strong>服务质量</strong>（将特定流量引向防火墙、优化器等）</td>
<td align="left">1. <strong>路由过滤</strong>（只接收或发布特定路由）<br>2. <strong>路由属性修改</strong>（如BGP的Local_Pref, MED, AS_Path）<br>3. <strong>路由引入</strong>（在路由协议间重分布时进行过滤和属性设置）</td>
</tr>
<tr>
<td align="left"><strong>配置位置</strong></td>
<td align="left">通常在<strong>入方向接口</strong>上应用</td>
<td align="left">通常在<strong>路由协议</strong>的配置中（如 <code>neighbor</code> 语句下）或<strong>重分布</strong>点时应用</td>
</tr>
<tr>
<td align="left"><strong>资源消耗</strong></td>
<td align="left"><strong>较高</strong>。因为需要对每个数据包进行复杂的策略匹配。</td>
<td align="left"><strong>较低</strong>。仅在路由信息更新时进行计算。</td>
</tr>
</tbody></table>
<hr>
<h3 id="通俗比喻"><a href="#通俗比喻" class="headerlink" title="通俗比喻"></a><strong>通俗比喻</strong></h3><p>为了更好地理解，我们可以用一个<strong>快递分拣系统</strong>来比喻：</p>
<ul>
<li><p><strong>路由策略</strong> 就像是<strong>快递公司的总部规则</strong>：</p>
<ul>
<li>规则决定了哪些地区的包裹信息（路由）可以被接收和发送到各个分拣中心（路由器）。</li>
<li>例如，“我们不接收来自A地区的包裹信息”，或者“所有发往B地区的包裹信息，都标记为高优先级”。</li>
<li>最终，每个分拣中心都形成了一张“我们能派送的区域表”（路由表）。</li>
</ul>
</li>
<li><p><strong>策略路由</strong> 就像是<strong>某个特定分拣中心的自定义流水线</strong>：</p>
<ul>
<li>尽管总部的“区域表”上说“发往B地区的包裹都走陆路”，但这个分拣中心额外规定：“<strong>所有从X小区来的</strong>，发往B地区的包裹，全部走<strong>空运</strong>”。</li>
<li>这个规定<strong>凌驾于</strong>总部的“区域表”之上，它不看目的地是否相同，而是看更具体的来源等特征。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="典型配置示例"><a href="#典型配置示例" class="headerlink" title="典型配置示例"></a><strong>典型配置示例</strong></h3><p>假设一个网络场景：路由器有两个出口，一个连接到ISP1 (10.1.1.1)，另一个连接到ISP2 (20.1.1.1)。</p>
<h4 id="1-路由策略场景"><a href="#1-路由策略场景" class="headerlink" title="1. 路由策略场景"></a><strong>1. 路由策略场景</strong></h4><p><strong>目标</strong>：在运行BGP时，只从ISP1学习关于 <code>192.168.0.0/16</code> 网段的路由。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">! 创建一个前缀列表，定义我们感兴趣的路由</span><br><span class="line">ip prefix-list FROM-ISP1 permit 192.168.0.0/16</span><br><span class="line"></span><br><span class="line">! 创建一个Route-map来调用这个前缀列表</span><br><span class="line">route-map ROUTE-POLICY permit 10</span><br><span class="line"> match ip address prefix-list FROM-ISP1</span><br><span class="line"></span><br><span class="line">! 在BGP进程中，对来自ISP1邻居的路由应用这个策略</span><br><span class="line">router bgp 100</span><br><span class="line"> neighbor 10.1.1.1 route-map ROUTE-POLICY <span class="keyword">in</span></span><br></pre></td></tr></table></figure>
<p><strong>效果</strong>：只有 <code>192.168.0.0/16</code> 这条路由会被放入路由表，其他从ISP1发来的路由将被过滤掉。</p>
<h4 id="2-策略路由场景"><a href="#2-策略路由场景" class="headerlink" title="2. 策略路由场景"></a><strong>2. 策略路由场景</strong></h4><p><strong>目标</strong>：将所有来自 <code>172.16.1.0/24</code> 网段的流量，强制发送到ISP2，即使路由表指出最佳路径是ISP1。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">! 创建一个ACL来匹配感兴趣的流量（基于源IP）</span><br><span class="line">access-list 100 permit ip 172.16.1.0 0.0.0.255 any</span><br><span class="line"></span><br><span class="line">! 创建一个Route-map来定义动作</span><br><span class="line">route-map PBR permit 10</span><br><span class="line"> match ip address 100</span><br><span class="line"> <span class="built_in">set</span> ip next-hop 20.1.1.1  ! 强制设置下一跳为ISP2</span><br><span class="line"></span><br><span class="line">! 在接收到流量的入口接口上应用PBR</span><br><span class="line">interface GigabitEthernet0/0</span><br><span class="line"> ip policy route-map PBR</span><br></pre></td></tr></table></figure>
<p><strong>效果</strong>：当数据包从 <code>GigabitEthernet0/0</code> 进入，且源IP是 <code>172.16.1.0/24</code> 时，路由器会忽略自己的路由表，直接将其转发给 <code>20.1.1.1</code> (ISP2)。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">策略路由</th>
<th align="left">路由策略</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心</strong></td>
<td align="left">控制数据包路径</td>
<td align="left">控制路由信息</td>
</tr>
<tr>
<td align="left"><strong>对象</strong></td>
<td align="left">数据包</td>
<td align="left">路由</td>
</tr>
<tr>
<td align="left"><strong>优先级</strong></td>
<td align="left">高（覆盖路由表）</td>
<td align="left">低（生成路由表）</td>
</tr>
<tr>
<td align="left"><strong>资源消耗</strong></td>
<td align="left">高</td>
<td align="left">低</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">精细化的流量工程</td>
<td align="left">路由协议的管理和优化</td>
</tr>
</tbody></table>
<p>简单来说，<strong>路由策略是“管理地图”，而策略路由是“指挥司机”</strong>。前者决定了你手里地图上画了哪些路，后者则是在实际开车时，命令司机无视地图，直接开向某条特定的路。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/19/%E5%AF%B9%E6%AF%94%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1%E5%92%8C%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5%E7%9A%84%E4%B8%8D%E5%90%8C/" data-id="cuid9ircXoipknYPpKwMw22iZ" data-title="对比路由策略和策略路由的不同" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-探讨反掩码的作用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/19/%E6%8E%A2%E8%AE%A8%E5%8F%8D%E6%8E%A9%E7%A0%81%E7%9A%84%E4%BD%9C%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2025-10-19T10:37:03.000Z" itemprop="datePublished">2025-10-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/19/%E6%8E%A2%E8%AE%A8%E5%8F%8D%E6%8E%A9%E7%A0%81%E7%9A%84%E4%BD%9C%E7%94%A8/">探讨反掩码的作用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>普通掩码（子网掩码）和反掩码虽然都使用32位二进制格式，但它们的设计目的和逻辑是完全相反的。普通掩码用于IP地址划分，用连续的1和0表示，而反掩码是匹配工具，用0和1表示要检查或忽略的位。</strong></p>
<p>因此，在ACL和OSPF宣告这种需要“匹配”或“指定范围”的场景下，反掩码比普通掩码更灵活、更精确。</p>
<p>下面我们来详细解释为什么。</p>
<hr>
<h3 id="1-核心概念：目的不同"><a href="#1-核心概念：目的不同" class="headerlink" title="1. 核心概念：目的不同"></a>1. 核心概念：目的不同</h3><ul>
<li><p><strong>普通掩码（子网掩码）</strong></p>
<ul>
<li><strong>目的：</strong> 定义一个IP地址中哪部分是<strong>网络位</strong>，哪部分是<strong>主机位</strong>。</li>
<li><strong>逻辑：</strong> 掩码中的 <code>1</code> 表示网络位，<code>0</code> 表示主机位。它必须是<strong>连续的</strong>1和0。</li>
<li><strong>例子：</strong> <code>255.255.255.0</code> (<code>/24</code>) 表示前24位是网络地址，后8位是主机地址。它定义的是一个<strong>连续的、完整的</strong>IP地址段。</li>
</ul>
</li>
<li><p><strong>反掩码</strong></p>
<ul>
<li><strong>目的：</strong> 作为一个<strong>通配符掩码</strong>，用来匹配一个或多个IP地址。</li>
<li><strong>逻辑：</strong> 掩码中的 <code>0</code> 表示“<strong>必须精确匹配</strong>”，<code>1</code> 表示“<strong>不关心，可以任意</strong>”。</li>
<li><strong>例子：</strong> <code>0.0.0.255</code> 表示前24位必须精确匹配，后8位可以是任意值。</li>
</ul>
</li>
</ul>
<h3 id="2-为什么在ACL中使用反掩码？"><a href="#2-为什么在ACL中使用反掩码？" class="headerlink" title="2. 为什么在ACL中使用反掩码？"></a>2. 为什么在ACL中使用反掩码？</h3><p>访问控制列表的核心功能是<strong>匹配数据包的源&#x2F;目标IP地址，并执行允许或拒绝操作</strong>。这种匹配通常不是针对单个主机，而是针对一个网段，甚至是多个不连续的IP。</p>
<ul>
<li><p><strong>场景1：匹配一个完整的子网</strong></p>
<ul>
<li>你想允许 <code>192.168.1.0/24</code> 这个网段的所有主机。</li>
<li><strong>ACL语句：</strong> <code>permit 192.168.1.0 0.0.0.255</code></li>
<li><strong>解释：</strong><ul>
<li>IP地址： <code>192.168.1.0</code> (这是一个代表网段的参考点)</li>
<li>反掩码： <code>0.0.0.255</code> (二进制为 <code>00000000.00000000.00000000.11111111</code>)</li>
<li>匹配规则：前三个八位组 (<code>192.168.1</code>) 必须精确匹配 (<code>0</code>)，最后一个八位组可以是任何值 (<code>255</code>)。所以它匹配从 <code>192.168.1.0</code> 到 <code>192.168.1.255</code> 的所有IP。</li>
</ul>
</li>
<li><strong>这里用普通掩码 <code>255.255.255.0</code> 是无法实现这种“匹配”逻辑的。</strong></li>
</ul>
</li>
<li><p><strong>场景2：匹配一个特定主机</strong></p>
<ul>
<li>你想拒绝主机 <code>192.168.1.10</code>。</li>
<li><strong>ACL语句：</strong> <code>deny 192.168.1.10 0.0.0.0</code></li>
<li><strong>解释：</strong> 反掩码全是 <code>0</code>，表示所有32位都必须精确匹配。这等同于 <code>host 192.168.1.10</code> 命令。</li>
</ul>
</li>
<li><p><strong>场景3：匹配不连续的IP（反掩码的超级优势）</strong></p>
<ul>
<li>假设你想匹配 <code>192.168.1.1</code> 和 <code>192.168.1.3</code> 这两个IP。用普通掩码无法定义一个包含这两个IP的连续网段。</li>
<li><strong>ACL语句：</strong> <code>permit 192.168.1.1 0.0.0.2</code></li>
<li><strong>解释：</strong><ul>
<li>IP地址： <code>192.168.1.1</code> (二进制最后8位: <code>000000**01**</code>)</li>
<li>反掩码： <code>0.0.0.2</code> (二进制最后8位: <code>000000**10**</code>)</li>
<li>匹配规则：前24位精确匹配，最后8位中，只有对应反掩码为 <code>0</code> 的位需要匹配。看最后一位：<ul>
<li>第1位 (最低位)：反掩码是 <code>0</code>，必须匹配IP地址的 <code>1</code>。</li>
<li>第2位：反掩码是 <code>1</code>，不关心。</li>
<li>其他位都是 <code>0</code>，必须匹配IP地址的 <code>0</code>。</li>
</ul>
</li>
<li>所以可能的组合是：<ul>
<li><code>...00000001</code> (十进制 1) -&gt; <strong>匹配</strong></li>
<li><code>...00000011</code> (十进制 3) -&gt; <strong>匹配</strong></li>
</ul>
</li>
<li>这样就巧妙地匹配了两个不连续的IP。<strong>这是普通掩码绝对做不到的。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-为什么在OSPF宣告中使用反掩码？"><a href="#3-为什么在OSPF宣告中使用反掩码？" class="headerlink" title="3. 为什么在OSPF宣告中使用反掩码？"></a>3. 为什么在OSPF宣告中使用反掩码？</h3><p>在OSPF中，使用 <code>network</code> 命令时，反掩码的作用是<strong>告诉路由器，哪些接口的IP地址应该被“宣告”到OSPF进程中</strong>。</p>
<ul>
<li><strong>场景：</strong> 你有一个路由器，接口1的IP是 <code>10.1.1.1/24</code>，接口2的IP是 <code>172.16.1.1/24</code>。你只想把 <code>10.1.1.0/24</code> 这个网段宣告到OSPF区域0。</li>
<li><strong>OSPF配置：</strong> <code>network 10.1.1.0 0.0.0.255 area 0</code></li>
<li><strong>解释：</strong><ul>
<li>路由器会检查它所有接口的IP地址。</li>
<li>对于每个接口IP，用它和 <code>network</code> 命令中的 <code>IP + 反掩码</code> 进行运算。</li>
<li>如果 <code>(接口IP) XOR (network命令中的IP)</code> 然后 <code>AND (反掩码)</code> 的结果为 <code>0</code>，则该接口被激活OSPF。</li>
<li>简单理解就是：接口IP的前24位如果是 <code>10.1.1</code>，那么这个接口就会加入OSPF进程，并在区域0中宣告其连接的网段 <code>10.1.1.0/24</code>。</li>
</ul>
</li>
</ul>
<p>这里使用反掩码，同样是为了提供<strong>精确控制</strong>，让你可以灵活地选择将哪个精确的网段（甚至是不连续的网段）宣告到OSPF中，而不是只能宣告一个主类网络。</p>
<hr>
<h3 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">普通掩码（子网掩码）</th>
<th align="left">反掩码（通配符掩码）</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>设计目的</strong></td>
<td align="left"><strong>定义</strong>一个IP地址的网络和主机部分。</td>
<td align="left"><strong>匹配</strong>一个或多个IP地址。</td>
</tr>
<tr>
<td align="left"><strong>逻辑</strong></td>
<td align="left"><code>1</code> &#x3D; 网络位， <code>0</code> &#x3D; 主机位。</td>
<td align="left"><code>0</code> &#x3D; 精确匹配， <code>1</code> &#x3D; 不关心（任意）。</td>
</tr>
<tr>
<td align="left"><strong>连续性</strong></td>
<td align="left"><strong>必须</strong>是连续的1和0。</td>
<td align="left"><strong>可以是任意组合</strong>的0和1。</td>
</tr>
<tr>
<td align="left"><strong>灵活性</strong></td>
<td align="left">较低，只能定义标准的、连续的IP网段。</td>
<td align="left"><strong>极高</strong>，可以匹配单个主机、连续网段、甚至不连续的IP。</td>
</tr>
<tr>
<td align="left"><strong>主要应用</strong></td>
<td align="left">IP地址规划、子网划分、路由器接口配置。</td>
<td align="left">ACL、OSPF&#x2F;BGP的 <code>network</code> 命令、NAT等需要精确匹配的场景。</td>
</tr>
</tbody></table>
<p><strong>结论：</strong> 不是普通的掩码不能起作用，而是因为它“起作用”的方式（定义网络）与ACL和OSPF宣告所需要的“匹配”功能不匹配。反掩码凭借其“通配符”的特性，为网络匹配操作提供了无与伦比的灵活性和精确度，因此成为了这些场景下的标准选择。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/19/%E6%8E%A2%E8%AE%A8%E5%8F%8D%E6%8E%A9%E7%A0%81%E7%9A%84%E4%BD%9C%E7%94%A8/" data-id="cuidpKbuz0P_m-HB_FuEN5bqp" data-title="探讨反掩码的作用" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" rel="tag">网络工程师</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-浅析路由的控制层面与转发层面" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/19/%E6%B5%85%E6%9E%90%E8%B7%AF%E7%94%B1%E7%9A%84%E6%8E%A7%E5%88%B6%E5%B1%82%E9%9D%A2%E4%B8%8E%E8%BD%AC%E5%8F%91%E5%B1%82%E9%9D%A2/" class="article-date">
  <time class="dt-published" datetime="2025-10-19T09:38:54.000Z" itemprop="datePublished">2025-10-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/19/%E6%B5%85%E6%9E%90%E8%B7%AF%E7%94%B1%E7%9A%84%E6%8E%A7%E5%88%B6%E5%B1%82%E9%9D%A2%E4%B8%8E%E8%BD%AC%E5%8F%91%E5%B1%82%E9%9D%A2/">浅析路由的控制层面与转发层面</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一-关于控制层面和转发层面"><a href="#一-关于控制层面和转发层面" class="headerlink" title="一.关于控制层面和转发层面"></a>一.关于控制层面和转发层面</h2><p>路由器的控制层面和转发层面。这个概念是现代路由器架构的基石，理解了它，就能理解路由器如何工作、如何进行故障排查以及SDN（软件定义网络）的革命性意义。</p>
<hr>
<h3 id="核心概念：一个形象的比喻"><a href="#核心概念：一个形象的比喻" class="headerlink" title="核心概念：一个形象的比喻"></a>核心概念：一个形象的比喻</h3><p>为了更好地理解，我们可以把<strong>路由器</strong>比作一个<strong>城市的交通管理系统</strong>：</p>
<ul>
<li><strong>控制层面</strong>：相当于<strong>交通管理局</strong>。它负责制定全市的交通规则、绘制道路地图（路由表）、根据实时事故（网络拓扑变化）更新导航APP。它进行的是全局性的、智能的决策。</li>
<li><strong>转发层面</strong>：相当于<strong>每个路口的交警或交通信号灯</strong>。他们不关心城市整体路况，只负责根据现有的交通规则和目的地指示牌，指挥每一辆到达路口的车（数据包）应该往哪个方向走。他们进行的是局部的、高速的、重复性的执行。</li>
</ul>
<hr>
<h3 id="1-控制层面"><a href="#1-控制层面" class="headerlink" title="1. 控制层面"></a>1. 控制层面</h3><p>控制层面是路由器的“大脑”，负责<strong>学习和生成路由信息</strong>，并最终构建出路由表。</p>
<h4 id="主要功能："><a href="#主要功能：" class="headerlink" title="主要功能："></a>主要功能：</h4><ol>
<li><p><strong>运行路由协议</strong>：</p>
<ul>
<li>与相邻的路由器通过OSPF、BGP、EIGRP等路由协议进行通信。</li>
<li>互相交换和学习网络拓扑信息（如链路状态、路径属性等）。</li>
</ul>
</li>
<li><p><strong>维护路由信息库</strong>：</p>
<ul>
<li>将从各个路由协议学到的、以及直连路由、静态路由等所有路由信息存储在一个数据库中。</li>
</ul>
</li>
<li><p><strong>执行路由决策</strong>：</p>
<ul>
<li>根据特定的算法（如SPF算法 for OSPF）或策略（如BGP路径属性），从RIB中选择出到达每个目标网络的最佳路径。</li>
</ul>
</li>
<li><p><strong>生成转发信息库</strong>：</p>
<ul>
<li>将最终确定的最佳路径信息安装到<strong>路由表</strong> 中，这个表就是转发层面实际使用的“地图”。在高端路由器上，控制平面会将这个表优化后生成一个更适合硬件快速查找的表，即<strong>转发信息库</strong>，并下发给转发层面。</li>
</ul>
</li>
</ol>
<h4 id="关键特点："><a href="#关键特点：" class="headerlink" title="关键特点："></a>关键特点：</h4><ul>
<li><strong>智能的、决策性的</strong>：它负责思考和计算。</li>
<li><strong>基于CPU和软件</strong>：运行复杂的路由算法，消耗CPU和内存资源。</li>
<li><strong>异步工作</strong>：路由更新和计算是事件驱动的（如链路up&#x2F;down），不是定时发生的。</li>
<li><strong>全局视角</strong>：了解网络的整体拓扑结构。</li>
</ul>
<hr>
<h3 id="2-转发层面"><a href="#2-转发层面" class="headerlink" title="2. 转发层面"></a>2. 转发层面</h3><p>转发层面是路由器的“肌肉”，负责<strong>根据控制层面生成的FIB，对每一个到达的数据包执行转发操作</strong>。</p>
<h4 id="主要功能：-1"><a href="#主要功能：-1" class="headerlink" title="主要功能："></a>主要功能：</h4><ol>
<li><strong>数据包接收</strong>：在入接口接收数据链路层帧，解封装出IP数据包。</li>
<li><strong>查找FIB</strong>：提取数据包中的<strong>目标IP地址</strong>，在FIB中进行最长前缀匹配查找，确定出接口和下一跳IP地址。</li>
<li><strong>重写数据链路层头</strong>：根据ARP表或邻居发现协议，将下一跳IP地址解析为MAC地址，并重写数据帧的源&#x2F;目标MAC地址。</li>
<li><strong>数据包发送</strong>：将重新封装好的数据帧从确定的出接口发送出去。</li>
</ol>
<h4 id="关键特点：-1"><a href="#关键特点：-1" class="headerlink" title="关键特点："></a>关键特点：</h4><ul>
<li><strong>无状态的、执行性的</strong>：它不做决策，只执行命令。</li>
<li><strong>基于专用硬件</strong>：为了达到线速转发，现代路由器使用<strong>ASIC</strong>、<strong>NPU</strong> 等专用芯片进行查找和转发，速度极快（纳秒级）。</li>
<li><strong>同步工作</strong>：对每一个数据包都执行相同的、流水线式的操作。</li>
<li><strong>局部视角</strong>：只关心当前数据包的目标地址和FIB中的对应条目，不关心网络全局。</li>
</ul>
<hr>
<h3 id="两者关系总结"><a href="#两者关系总结" class="headerlink" title="两者关系总结"></a>两者关系总结</h3><table>
<thead>
<tr>
<th align="left">特性维度</th>
<th align="left">控制层面</th>
<th align="left">转发层面</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>功能</strong></td>
<td align="left"><strong>路由</strong>：学习和决策，生成“地图”</td>
<td align="left"><strong>交换</strong>：查找和执行，按照“地图”行驶</td>
</tr>
<tr>
<td align="left"><strong>处理对象</strong></td>
<td align="left">路由协议报文</td>
<td align="left">用户数据包</td>
</tr>
<tr>
<td align="left"><strong>工作频率</strong></td>
<td align="left">低频、异步</td>
<td align="left">高频、同步（每个数据包）</td>
</tr>
<tr>
<td align="left"><strong>性能关键</strong></td>
<td align="left">CPU、内存</td>
<td align="left">吞吐量、延迟、丢包率</td>
</tr>
<tr>
<td align="left"><strong>资源依赖</strong></td>
<td align="left">软件、通用处理器</td>
<td align="left">专用硬件、ASIC&#x2F;TCAM</td>
</tr>
<tr>
<td align="left"><strong>视角</strong></td>
<td align="left">全局网络拓扑</td>
<td align="left">单个数据包的目的地</td>
</tr>
</tbody></table>
<p><strong>关系流程</strong>：<br><code>路由协议通信</code> -&gt; <code>控制层面计算最佳路径</code> -&gt; <code>更新路由表和FIB</code> -&gt; <code>转发层面查询FIB</code> -&gt; <code>转发数据包</code></p>
<hr>
<h3 id="故障排查中的应用"><a href="#故障排查中的应用" class="headerlink" title="故障排查中的应用"></a>故障排查中的应用</h3><p>理解这两个层面可以极大地帮助网络故障排查：</p>
<ol>
<li><p><strong>连通性故障</strong>：PC无法访问服务器。</p>
<ul>
<li><strong>检查控制层面</strong>：在沿途路由器上使用 <code>show ip route &lt;server_ip&gt;</code> 命令。如果路由表中没有相应的路由条目，问题出在控制层面（路由协议未学习到、静态路由缺失等）。</li>
<li><strong>检查转发层面</strong>：如果路由表中有正确的路由条目，但数据包还是过不去，问题可能出在转发层面（ACL拦截、策略路由、硬件故障等）。</li>
</ul>
</li>
<li><p><strong>路径异常</strong>：数据包走了错误的路径。</p>
<ul>
<li>这通常是<strong>控制层面</strong>的问题，因为路径选择是由控制层面决定的（如BGP策略配置错误、OSPF成本值设置不当）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="与SDN的关联"><a href="#与SDN的关联" class="headerlink" title="与SDN的关联"></a>与SDN的关联</h3><p>软件定义网络（SDN）的核心思想正是<strong>将控制层面与转发层面彻底分离</strong>。</p>
<ul>
<li><strong>传统网络</strong>：每个路由器都集成了自己的控制层面和转发层面，是分布式的大脑。</li>
<li><strong>SDN网络</strong>：<ul>
<li><strong>控制层面</strong>被集中到一个独立的、逻辑上的<strong>SDN控制器</strong>中。控制器拥有全网视图，并向所有交换机下发流表。</li>
<li><strong>转发层面</strong>保留在交换机上（称为<strong>数据平面</strong>），但变得非常“笨”，它只负责根据控制器下发的<strong>流表</strong> 来转发数据包。</li>
</ul>
</li>
</ul>
<p>这种分离带来了网络的集中管理、灵活编程和自动化等巨大优势。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>控制层面决定“去哪走”，转发层面负责“怎么走”</strong>。这两个层面各司其职，一个负责全局的、智能的路径计算，一个负责局部的、高速的数据包转发，共同构成了路由器高效、可靠工作的基础。理解它们的区别和联系，是掌握路由技术和现代网络架构的关键。</p>
<h2 id="二-ACL与IP前缀列表中的应用理念"><a href="#二-ACL与IP前缀列表中的应用理念" class="headerlink" title="二.ACL与IP前缀列表中的应用理念"></a>二.ACL与IP前缀列表中的应用理念</h2><p>那么，在ACL和IP前缀列表两大应用中，ACL可以用于数据过滤和网段匹配，IP前缀列表只可用于网段匹配。这两个哪些对应控制层面，哪些对应转发层面？</p>
<p>我们首先需要理解ACL（访问控制列表）和IP前缀列表在网络设备中的常见应用场景。</p>
<ul>
<li>ACL：通常用于过滤数据包，可以基于源&#x2F;目标IP、协议、端口等。它既可以用在控制层面过滤路由信息（如过滤路由更新），也可以用在前向转发层面过滤数据包。</li>
<li>IP前缀列表：通常用于匹配IP网段（即路由前缀），一般用于控制层面，例如在路由策略中匹配特定的路由前缀，从而进行路由的过滤或属性修改。</li>
</ul>
<p>现在，问题问的是这两个工具分别对应控制层面和转发层面。注意，ACL可以用于两个层面，而IP前缀列表只用于控制层面。</p>
<p>具体来说：</p>
<ul>
<li>在控制层面，ACL可以用于过滤路由更新（例如，在OSPF或BGP中，使用ACL来匹配路由前缀，从而决定接受或拒绝某些路由）。但ACL在控制层面的使用不如IP前缀列表灵活，因为ACL不能直接匹配前缀长度（掩码），而IP前缀列表可以同时匹配前缀和掩码长度。</li>
<li>在转发层面，ACL用于过滤数据包（例如，在接口上应用ACL来允许或拒绝数据包通过）。IP前缀列表一般不用于转发层面，因为它设计的目的就是为路由策略服务的。</li>
</ul>
<p>因此，我们可以总结：</p>
<ul>
<li>ACL：既可用于控制层面（路由过滤），也可用于转发层面（数据包过滤）。</li>
<li>IP前缀列表：仅用于控制层面（路由过滤）。</li>
</ul>
<p>所以，回答这个问题：</p>
<ul>
<li>对应控制层面的有：ACL（部分功能）和IP前缀列表。</li>
<li>对应转发层面的有：ACL（部分功能）。</li>
</ul>
<p>但是，问题表述是“这两个那些对应控制层面，那些对应转发层面”，所以我们分别说明：</p>
<ul>
<li>ACL：在控制层面和转发层面都有应用。</li>
<li>IP前缀列表：只用于控制层面。</li>
</ul>
<p>注意：在具体设备上，ACL和IP前缀列表的应用可能略有不同，但这是通用概念。</p>
<h2 id="三-各种路由协议的详细体现"><a href="#三-各种路由协议的详细体现" class="headerlink" title="三.各种路由协议的详细体现"></a>三.各种路由协议的详细体现</h2><p>另一个问题，各种路由协议（RIP，IS-IS，OSPF，BGP等）体现的是路由的控制层面还是转发层面？</p>
<p><strong>先说结论：所有路由协议（RIP，IS-IS，OSPF，BGP等）本身都属于控制层面。</strong></p>
<p>它们是控制层面最核心、最活跃的组成部分，是路由器“大脑”中进行思考和交流的部分。</p>
<hr>
<h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><p>我们可以把控制层面想象成一个公司的“战略决策部门”，而不同的路由协议就像是部门内部不同的沟通和决策机制。</p>
<h4 id="为什么它们属于控制层面？"><a href="#为什么它们属于控制层面？" class="headerlink" title="为什么它们属于控制层面？"></a>为什么它们属于控制层面？</h4><ol>
<li><strong>处理的对象是路由信息，而非数据包</strong>：<ul>
<li>路由协议之间互相发送和接收的是<strong>路由更新报文</strong>（例如OSPF的LSA、BGP的Update消息）。这些报文的内容是“我已知哪些网络，路径成本是多少”等信息。</li>
<li>它们<strong>不处理</strong>用户的真实数据流量（如你浏览的网页、下载的文件）。用户数据是由<strong>转发层面</strong>处理的。</li>
</ul>
</li>
<li><strong>核心功能是构建和更新路由表</strong>：<ul>
<li>所有路由协议的最终目的，都是通过各自的算法（如RIP的跳数、OSPF的SPF算法、BGP的路径属性比较），计算出到达所有已知目标网络的最佳路径。</li>
<li>计算出的最优路径最终会被安装到路由器的<strong>路由表</strong>中。这个路由表就是控制层面输出给转发层面的“最终指令集”。</li>
</ul>
</li>
<li><strong>工作方式是异步和事件驱动的</strong>：<ul>
<li>它们通常在后台运行，定期发送keepalive消息，或者在网络拓扑发生变化时（如链路故障）触发更新。这不是对每个数据包都进行的操作。</li>
</ul>
</li>
</ol>
<h3 id="不同路由协议在控制层面的特点"><a href="#不同路由协议在控制层面的特点" class="headerlink" title="不同路由协议在控制层面的特点"></a>不同路由协议在控制层面的特点</h3><p>尽管都属于控制层面，但它们在控制层面内部扮演的角色和运作方式有所不同：</p>
<table>
<thead>
<tr>
<th align="left">路由协议</th>
<th align="left">在控制层面中的角色与特点</th>
<th align="left">控制层面交互方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>RIP</strong></td>
<td align="left">一种简单的“距离矢量”协议。路由器之间互相告知“我到某网的距离是X跳”。</td>
<td align="left">周期性地向邻居广播整个路由表。</td>
</tr>
<tr>
<td align="left"><strong>OSPF</strong></td>
<td align="left">一种复杂的“链路状态”协议。路由器之间同步整个区域的网络拓扑地图，然后各自独立计算最短路径。</td>
<td align="left">通过组播发送链路状态通告，只在拓扑变化时进行增量更新。</td>
</tr>
<tr>
<td align="left"><strong>IS-IS</strong></td>
<td align="left">另一种“链路状态”协议，在机制上与OSPF类似，但源于OSI模型，通常用于大型运营商网络。</td>
<td align="left">与OSPF类似，使用LSP进行链路状态信息的同步。</td>
</tr>
<tr>
<td align="left"><strong>BGP</strong></td>
<td align="left">一种“路径矢量”协议，用于在不同自治系统之间交换路由信息。其决策基于丰富的策略和路径属性。</td>
<td align="left">通过可靠的TCP会话与对等体建立连接，进行增量更新。</td>
</tr>
</tbody></table>
<h3 id="与控制层面和转发层面的关系"><a href="#与控制层面和转发层面的关系" class="headerlink" title="与控制层面和转发层面的关系"></a>与控制层面和转发层面的关系</h3><ol>
<li><strong>控制层面</strong>：路由协议作为核心引擎，通过互相通信，生成路由表（RIB），并最终生成转发信息库（FIB）。</li>
<li><strong>转发层面</strong>：不运行任何路由协议。它只做一件事：当数据包到达时，查询控制层面下发的FIB，然后执行转发动作。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>路由协议是控制层面的核心引擎</strong>：没有它们，控制层面就无法自动学习路由，路由器就只能依靠手工配置的静态路由来工作。</li>
<li><strong>它们为转发层面提供“导航地图”</strong>：路由协议辛勤工作的最终产物，就是一张详尽且最优的“路径地图”（FIB），转发层面则依赖这张地图来高效地转发每一个数据包。</li>
</ul>
<p>所以，当您在想RIP、IS-IS、OSPF、BGP时，您应该立即联想到它们是在<strong>控制层面</strong>负责“路由决策”的智能协议。而IP转发、ACL过滤等操作，则是在<strong>转发层面</strong>负责“数据包搬运”的执行过程。</p>
<h2 id="四-静态路由与默认路由的体现"><a href="#四-静态路由与默认路由的体现" class="headerlink" title="四.静态路由与默认路由的体现"></a>四.静态路由与默认路由的体现</h2><p><strong>静态路由和默认路由也同样属于控制层面。</strong></p>
<p>它们同样是控制层面用于“决策”和“生成路由表”的一种方式，只不过其“智能”的来源不同。</p>
<hr>
<h3 id="详细分析-1"><a href="#详细分析-1" class="headerlink" title="详细分析"></a>详细分析</h3><p>让我们回到那个“交通管理系统”的比喻：</p>
<ul>
<li><strong>动态路由协议（OSPF&#x2F;BGP等）</strong>：像是一个<strong>实时的交通信息网络</strong>。每个路由器（交通节点）自动与邻居交换路况信息，共同计算并实时更新出最优路径。这是<strong>分布式、自动的智能</strong>。</li>
<li><strong>静态路由</strong>：则像是<strong>交通管理员手动绘制在地图上的固定路线</strong>。管理员明确指定：“要去往目的地A，必须从X路口出去。” 路由器无需与其他路由器通信，直接听从这条指令。</li>
<li><strong>默认路由</strong>：是一种特殊的静态路由，它像是<strong>指向“主干道”或“高速公路”的通用指示牌</strong>，上面写着：“所有没有明确指示目的地的车辆，请全部驶入此路。” 它是一个捕获所有未知流量的最后手段。</li>
</ul>
<h3 id="为什么它们属于控制层面？-1"><a href="#为什么它们属于控制层面？-1" class="headerlink" title="为什么它们属于控制层面？"></a>为什么它们属于控制层面？</h3><ol>
<li><p><strong>它们直接影响路由表（RIB）的生成</strong>：</p>
<ul>
<li>当您在路由器上输入 <code>ip route 192.168.2.0 255.255.255.0 10.1.1.1</code> 这条静态路由命令后，这条路径信息会<strong>直接被安装到路由表</strong>中。</li>
<li>控制层面的核心任务就是“构建路由表”。无论是通过动态协议学来的，还是通过手工配置输入的，都是路由条目的来源。</li>
</ul>
</li>
<li><p><strong>它们是转发层面的“指令”来源</strong>：</p>
<ul>
<li>控制层面将静态路由和默认路由加入到路由表后，同样会将其最优路径<strong>下发到转发信息库（FIB）</strong> 中。</li>
<li>转发层面在转发数据包时，并不会区分这条路由是来自OSPF还是静态配置。它只是盲目地查询FIB并执行转发。</li>
<li><strong>例如</strong>：一个去往 <code>192.168.2.10</code> 的数据包到达路由器，转发层面在FIB中查找到匹配的静态路由条目，然后就会从指定接口转发给下一跳 <code>10.1.1.1</code>。</li>
</ul>
</li>
<li><p><strong>它们参与控制层面的决策过程</strong>：</p>
<ul>
<li>路由器可能会从多个来源学到通往同一目的地的路由（如同时从OSPF和静态路由学到）。这时，控制层面会根据<strong>管理距离</strong> 这个值来决策哪个来源更可信，并将最可信的路由安装到路由表中。</li>
<li>静态路由通常拥有一个很小的管理距离（例如1或更小），这意味着它比大多数动态路由协议（如OSPF的管理距离是110）更受信任。</li>
</ul>
</li>
</ol>
<h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">动态路由协议 (OSPF&#x2F;BGP等)</th>
<th align="left">静态路由 &#x2F; 默认路由</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>本质</strong></td>
<td align="left"><strong>自动、分布式智能</strong></td>
<td align="left"><strong>手动、集中式智能</strong></td>
</tr>
<tr>
<td align="left"><strong>控制层面工作</strong></td>
<td align="left">与邻居通信、运行算法、计算路径</td>
<td align="left">网络管理员直接输入路径信息</td>
</tr>
<tr>
<td align="left"><strong>路由信息来源</strong></td>
<td align="left">其他路由器</td>
<td align="left">本机配置（config）</td>
</tr>
<tr>
<td align="left"><strong>开销与灵活性</strong></td>
<td align="left">占用CPU、内存资源；灵活，能自动适应拓扑变化</td>
<td align="left">无运行时开销；不灵活，拓扑变化需手动修改</td>
</tr>
<tr>
<td align="left"><strong>在控制层面的角色</strong></td>
<td align="left"><strong>自动路由发现与计算</strong></td>
<td align="left"><strong>手动路由注入</strong></td>
</tr>
</tbody></table>
<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>您可以这样理解控制层面的构成：</p>
<p><strong>控制层面 &#x3D; 动态路由协议（负责自动学习） + 静态&#x2F;默认路由（负责手动指定） + 其他来源（如直连路由）</strong></p>
<p>它们共同协作，有时也相互竞争（通过管理距离），最终汇集成一张完整的“网络地图”——<strong>路由表</strong>。这张地图随后被交给转发层面去执行。</p>
<p>所以，无论是动态路由协议还是静态路由，它们都是<strong>控制层面</strong>用于回答“数据包应该往哪去？”这个核心问题的方法。它们的区别在于<strong>获取答案的方式</strong>是自动还是手动，而它们<strong>所属的逻辑层面</strong>是完全一致的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/19/%E6%B5%85%E6%9E%90%E8%B7%AF%E7%94%B1%E7%9A%84%E6%8E%A7%E5%88%B6%E5%B1%82%E9%9D%A2%E4%B8%8E%E8%BD%AC%E5%8F%91%E5%B1%82%E9%9D%A2/" data-id="cuidsjJKpI4zwe6h6Am73EkvK" data-title="浅析路由的控制层面与转发层面" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" rel="tag">网络工程师</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-浅析静态路由与直连路由" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/16/%E6%B5%85%E6%9E%90%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E4%B8%8E%E7%9B%B4%E8%BF%9E%E8%B7%AF%E7%94%B1/" class="article-date">
  <time class="dt-published" datetime="2025-10-16T15:22:31.000Z" itemprop="datePublished">2025-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/16/%E6%B5%85%E6%9E%90%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E4%B8%8E%E7%9B%B4%E8%BF%9E%E8%B7%AF%E7%94%B1/">浅析静态路由与直连路由</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一.关于直连路由</p>
<p>路由器访问直连网段时使用直连路由。直连路由的接口配置了IP地址并且处于up状态，<br>直连路由会自动产生，不需要任何配置。</p>
<p>二.静态路由</p>
<p>静态路由一般用于小型网络规模，不能根据网络的变更进行动态路由学习。配置形式<br>一般为：<em>目标网段 目标网段掩码 下一跳地址（本地出接口）</em></p>
<p>三.缺省路由</p>
<p>缺省路由是静态路由的一种特殊形态，一般用在内网三层设备需要访问互联网。配置<br>形式一般为：<em>0.0.0.0 0.0.0.0 下一跳地址（本地出接口）</em></p>
<p>多说一句，个人其实一般习惯把缺省路由叫做默认路由，以便于理解。</p>
<p>关于“缺省”这个专有名词的翻译，之前还特意和AI讨论过这方面问题，关于“缺省”是否可以同义替换为“默认”这个词。以下是AI对此的分析：</p>
<ol>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">### 一、为什么是“缺省”？—— 词源探秘</span><br><span class="line"></span><br><span class="line">“缺省”是一个典型的**意译词**，它翻译自英文术语 **“Default”**。</span><br><span class="line"></span><br><span class="line">要理解这个古怪的翻译，我们需要拆解一下“Default”在英文中的核心含义：</span><br><span class="line"></span><br><span class="line">- **De-**： 一个前缀，有“否定”、“离开”、“向下”的意思。</span><br><span class="line">- **-fault**： 来自拉丁语 *fallere*，意思是“欺骗、失败、辜负期望”。（和“fault”错误同源）</span><br><span class="line"></span><br><span class="line">所以，“Default”的本质是：</span><br><span class="line">**“由于（用户）未能做出（某个选择或提供某个信息），而由系统自动采用的一个预先设定好的（退而求其次的）选项或行为。”**</span><br><span class="line"></span><br><span class="line">中文译者当年在翻译时，抓住了这个“未能”和“缺失”的核心，将其拆解为：</span><br><span class="line"></span><br><span class="line">- **缺**： 缺失、缺乏、缺少。对应“未能提供”。</span><br><span class="line">- **省**： 省略、省去。对应“（用户）省略了操作”或“（系统）省去了判断”。</span><br><span class="line"></span><br><span class="line">因此，“缺省”直译过来就是 **“因缺失而省略”** 或 **“在用户缺位/未指定时，系统省去询问环节而采用的方案”** 。虽然逻辑上能自洽，但确实非常拗口，不符合日常语言习惯。相比之下，“默认”（默默地承认/认定）这个词就形象和自然得多。</span><br><span class="line"></span><br><span class="line">**结论：** 在绝大多数情况下，**“缺省” = “默认”**。你可以放心地在脑海里进行替换。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### 二、除了“缺省路由”，还有哪些地方会用到“缺省”？</span><br><span class="line"></span><br><span class="line">“缺省”这个概念在计算机科学中无处不在，只要有一个地方需要预设一个“保底”的、或“当用户不指定时”就启用的值或行为，就会用到它。以下是一些常见的例子：</span><br><span class="line"></span><br><span class="line">#### 1. 缺省路由</span><br><span class="line"></span><br><span class="line">这你已经提到了。它是路由表中的最后一条“保底”规则，当所有其他路由规则都不匹配目标IP地址时，数据包就会被发送到缺省路由所指向的**下一跳地址**（通常是网关路由器）。可以理解为“不知道去哪的数据包都往这儿送”。</span><br><span class="line"></span><br><span class="line">#### 2. 缺省网关</span><br><span class="line"></span><br><span class="line">这个概念和缺省路由紧密相关。**缺省网关**就是一个设备的**缺省路由所指的那个IP地址**。在你的电脑上，网络设置里填写的“默认网关”就是你这台电脑的缺省网关。你的电脑要访问互联网，所有非本地的流量都会先发给这个网关。</span><br><span class="line"></span><br><span class="line">#### 3. 缺省值</span><br><span class="line"></span><br><span class="line">这是最广泛的应用。指在用户没有显式提供值时，程序或系统自动使用的那个预设值。</span><br><span class="line"></span><br><span class="line">- **编程中**： 函数参数可以设置缺省值。例如 `function greet(name = &quot;Guest&quot;)`，如果你调用 `greet()` 不传参数，`name` 的缺省值就是 `&quot;Guest&quot;`。</span><br><span class="line">- **数据库中**： 可以为表的字段设置缺省值。例如一个 `users` 表的 `create_date` 字段，可以设置缺省值为 `CURRENT_TIMESTAMP`，这样当插入新数据没指定时间时，数据库会自动填入当前时间。</span><br><span class="line">- **软件设置中**： 软件的“恢复默认设置”功能，就是将所有配置重置为出厂时的**缺省值**。</span><br><span class="line"></span><br><span class="line">#### 4. 缺省配置 / 配置文件</span><br><span class="line"></span><br><span class="line">许多软件在启动时会加载一个 `default.conf` 或 `config.default.yml` 之类的**缺省配置文件**。如果用户没有创建自己的配置文件，或者自己的配置里缺少某些选项，系统就会使用这些缺省配置中的值。</span><br><span class="line"></span><br><span class="line">#### 5. 缺省构造函数</span><br><span class="line"></span><br><span class="line">在面向对象编程（如C++、Java、C#）中，指一个不需要提供任何参数的构造函数。当程序员没有为类编写任何构造函数时，编译器会自动生成一个缺省构造函数。</span><br><span class="line"></span><br><span class="line">#### 6. 缺省参数</span><br><span class="line"></span><br><span class="line">在函数调用或API请求中，如果某些参数是可选的，当调用者省略它们时，这些参数就会使用预先定义好的**缺省参数**。</span><br><span class="line"></span><br><span class="line">#### 7. 法律和金融领域的延伸</span><br><span class="line"></span><br><span class="line">甚至在计算机领域之外，“default”这个词也广泛使用，并同样被（生硬地）翻译为“缺省”。</span><br><span class="line"></span><br><span class="line">- **缺省判决**： 法律术语。指在庭审中，一方（通常是被告）未能出庭或未能答辩，法官据此作出的对其不利的判决。</span><br><span class="line">- **债务缺省**： 金融术语。指债务人未能履行偿还债务的合同义务，即“违约”。（这里的“缺省”和“违约”是同一个英文词“Default”）。</span><br><span class="line"></span><br><span class="line">### 总结与建议</span><br><span class="line"></span><br><span class="line">1. **直接理解**： 今后在任何计算机文献中看到“缺省”，请毫不犹豫地在心里将其替换为“默认”。你的理解是完全正确的。</span><br><span class="line">2. **知其所以然**： 了解“缺省”来自“Default”，并且其本意是“因用户缺失/省略操作而由系统采用的方案”，这能帮助你更深刻地理解这个概念，而不仅仅是死记硬背一个词。</span><br><span class="line">3. **沟通时灵活运用**： 在书面文档或正式场合，使用“缺省”是规范且专业的。但在日常口头交流中，说“默认路由”、“默认网关”所有人都能听懂，且更自然。这类似于很多人会把“URI”直接说成“网址”，虽然不精确但沟通效率高。</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/16/%E6%B5%85%E6%9E%90%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E4%B8%8E%E7%9B%B4%E8%BF%9E%E8%B7%AF%E7%94%B1/" data-id="cuidBsvi7ty895CKX3wH15EE2" data-title="浅析静态路由与直连路由" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" rel="tag">网络工程师</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/16/hello-world/" class="article-date">
  <time class="dt-published" datetime="2025-10-16T15:15:08.778Z" itemprop="datePublished">2025-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/16/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/16/hello-world/" data-id="cuidFTgcr-gVYPt8mlzcxXS1d" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-IS-IS-IS-IS路由协议基本概念" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/13/IS-IS-IS-IS%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="article-date">
  <time class="dt-published" datetime="2025-10-13T09:05:58.000Z" itemprop="datePublished">2025-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/13/IS-IS-IS-IS%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">[IS-IS]IS-IS路由协议基本概念</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>IS-IS链路状态路由协议，采用Dijkstra（迪杰斯特拉）算法，路由优先级15。</p>
<p>IS-IS的地址结构由IDP（初始域）和DSP（域指定）组成，但是通常直接使用NET地址作为协议地址（NET地址包括区域ID、系统ID、固定字段）。</p>
<p>IS-IS使用cost作为路由度量， 一条IS-IS路径的cost等于本路由器到达目标网段。沿途的所有路由传递方向入接口的cost总和，cost值越小，路径越优。与OSPF不同的是，IS-IS接口的cost在缺省情况下并不与接口带宽相关（在实际部署时，IS-IS也支持根据带宽调整cost值），无论接口带宽多大，缺省时cost为10。</p>
<p>支持路由过滤，路由聚合，修改cost，默认路由下发，路由认证等路由优化功能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/13/IS-IS-IS-IS%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" data-id="cuidpGFjfvpuyyskjVwiyK9vc" data-title="[IS-IS]IS-IS路由协议基本概念" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IS-IS/" rel="tag">IS-IS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" rel="tag">网络工程师</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/" rel="tag">路由协议</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-RIP-RIP路由协议基本概念" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/13/RIP-RIP%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="article-date">
  <time class="dt-published" datetime="2025-10-13T09:02:48.000Z" itemprop="datePublished">2025-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/13/RIP-RIP%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">[RIP]RIP路由协议基本概念</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>RIP距离矢量路由协议，使用的路由算法是Bellman-Ford（贝尔曼-福特），以经过三层节点个数（跳数）为衡量路径最优的标准，经过节点最多不能超过15跳，16跳为目标不可达。</p>
<p>路由采用周期更新机制。</p>
<p>报文封装在传输层，基于UDP的520端口发送消息。</p>
<p>每个路由器只会学到邻居路由器的信息，不知道整个网络的拓扑结构。每次路由更新最多承载25条路由。</p>
<p>支持路由过滤，路由聚合（RIPv1不支持），修改跳数值，默认路由下发，路由认证等路由优化功能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/13/RIP-RIP%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" data-id="cuidupDWMZDZgIhFrAF0_yXoH" data-title="[RIP]RIP路由协议基本概念" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RIP/" rel="tag">RIP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" rel="tag">网络工程师</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/" rel="tag">路由协议</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-OSPF-一篇文章讲清楚OSPF路由协议的七步邻接关系建立步骤" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/11/OSPF-%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%AE%B2%E6%B8%85%E6%A5%9AOSPF%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%83%E6%AD%A5%E9%82%BB%E6%8E%A5%E5%85%B3%E7%B3%BB%E5%BB%BA%E7%AB%8B%E6%AD%A5%E9%AA%A4/" class="article-date">
  <time class="dt-published" datetime="2025-10-11T08:34:48.000Z" itemprop="datePublished">2025-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/11/OSPF-%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%AE%B2%E6%B8%85%E6%A5%9AOSPF%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%83%E6%AD%A5%E9%82%BB%E6%8E%A5%E5%85%B3%E7%B3%BB%E5%BB%BA%E7%AB%8B%E6%AD%A5%E9%AA%A4/">[OSPF]一篇文章讲清楚OSPF路由协议的七步邻接关系建立步骤</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>整个建立过程可以划分为以下几个关键状态，其流程如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A[Down状态&lt;br&gt;初始状态] --&gt; B[Init状态&lt;br&gt;收到Hello包]</span><br><span class="line">    B --&gt; C[2-Way状态&lt;br&gt;在Hello包中看到自己的RID]</span><br><span class="line">    C --&gt; D[ExStart状态&lt;br&gt;主从协商]</span><br><span class="line">    D --&gt; E[Exchange状态&lt;br&gt;交换DBD摘要]</span><br><span class="line">    E --&gt; F[Loading状态&lt;br&gt;请求并加载LSA]</span><br><span class="line">    F --&gt; G[Full状态&lt;br&gt;完全邻接]</span><br></pre></td></tr></table></figure>

<p>现在，我们来详细解释每一个状态：</p>
<ol>
<li><strong>Down (失效状态)</strong><ul>
<li><strong>描述</strong>: 这是邻接关系的初始状态。表示没有从邻居收到任何信息（Hello包）。</li>
<li><strong>动作</strong>: 本地路由器会周期性地向外发送Hello包，尝试发现邻居。</li>
</ul>
</li>
<li><strong>Init (初始状态)</strong><ul>
<li><strong>描述</strong>: 本地路由器<strong>收到了对端发来的Hello包</strong>，但Hello包中<strong>没有包含自己的Router ID (RID)</strong>。这意味着对方还没有收到我的Hello包，或者我的参数不符合它的要求。</li>
<li><strong>动作</strong>: 继续交互Hello包。</li>
</ul>
</li>
<li><strong>2-Way (双向通信状态)</strong><ul>
<li><strong>描述</strong>: 这是<strong>建立邻接关系的关键前提</strong>。本地路由器在收到的Hello包中，看到了<strong>自己的Router ID</strong>。这表明双向通信已经建立。</li>
<li><strong>决策点</strong>:<ul>
<li>在<strong>广播多路访问网络（如以太网）</strong> 中，DR（指定路由器）和BDR（备份指定路由器）将在此状态后与其他路由器继续建立邻接（FULL），而非DR&#x2F;BDR路由器之间会停留在此状态。</li>
<li>在<strong>点对点网络</strong>中，所有邻居都会继续向下一个状态发展。</li>
</ul>
</li>
</ul>
</li>
<li><strong>ExStart (预启动状态)</strong><ul>
<li><strong>描述</strong>: 这是<strong>邻接关系（而不仅仅是邻居关系）的真正开始</strong>。双方使用<strong>空的DBD（数据库描述）包</strong>来<strong>协商主从关系</strong>。</li>
<li><strong>目的</strong>: 确定在接下来的数据交换过程中，由谁作为“主”设备来控制交换过程。RID更大的一方将成为主设备。</li>
</ul>
</li>
<li><strong>Exchange (交换状态)</strong><ul>
<li><strong>描述</strong>: 主从关系协商完毕后，双方进入此状态。开始互相发送<strong>包含LSDB（链路状态数据库）摘要信息的DBD包</strong>。</li>
<li><strong>目的</strong>: 通过交换“目录”，互相了解对方有哪些LSA（链路状态通告）是自己没有的。</li>
</ul>
</li>
<li><strong>Loading (加载状态)</strong><ul>
<li><strong>描述</strong>: 在收到对端的DBD后，本地路由器会将自身的LSDB与收到的摘要进行对比。</li>
<li><strong>动作</strong>:<ul>
<li>如果发现自己缺少某条LSA，就会向对方发送<strong>LSR（链路状态请求）</strong>。</li>
<li>对方会回复<strong>LSU（链路状态更新）</strong> 来传递完整的LSA信息。</li>
<li>本地路由器收到LSU后，会发送<strong>LSAck（链路状态确认）</strong> 进行确认。</li>
</ul>
</li>
<li>图中的 <code>LSR</code>, <code>LSU</code>, <code>LSAck</code> 报文就是在此状态交互的。</li>
</ul>
</li>
<li><strong>Full (完全邻接状态)</strong><ul>
<li><strong>描述</strong>: 这是邻接关系建立的<strong>最终稳定状态</strong>。此时，双方路由器的<strong>LSDB已经完全同步</strong>。</li>
<li><strong>意义</strong>: 达到此状态后，路由器才能基于完全同步的LSDB，使用SPF算法独立计算出一致且无环的路由表。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="示意图中报文类型说明"><a href="#示意图中报文类型说明" class="headerlink" title="示意图中报文类型说明"></a>示意图中报文类型说明</h3><ul>
<li><strong>Hello</strong>: 用于发现和维持邻居关系。</li>
<li><strong>DD (Database Description Packet)</strong>: 用于描述自己的LSDB摘要，在ExStart和Exchange状态交换。</li>
<li><strong>LSR (Link State Request Packet)</strong>: 用于请求完整的LSA。</li>
<li><strong>LSU (Link State Update Packet)</strong>: 用于发送完整的LSA。</li>
<li><strong>LSAck (Link State Acknowledgment Packet)</strong>: 用于确认收到LSU。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>OSPF邻接关系的建立是一个严谨的“状态机”过程，从Down到Full，每一步都有特定的任务和报文交互。你的示意图完美地展示了这个完整的生命周期。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/11/OSPF-%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%AE%B2%E6%B8%85%E6%A5%9AOSPF%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%83%E6%AD%A5%E9%82%BB%E6%8E%A5%E5%85%B3%E7%B3%BB%E5%BB%BA%E7%AB%8B%E6%AD%A5%E9%AA%A4/" data-id="cuid9JCjC1Kzz7GGG8MhM-V8y" data-title="[OSPF]一篇文章讲清楚OSPF路由协议的七步邻接关系建立步骤" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OSPF/" rel="tag">OSPF</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" rel="tag">网络工程师</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/" rel="tag">路由协议</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-OSPF-OSPF路由协议基本概念" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/11/OSPF-OSPF%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="article-date">
  <time class="dt-published" datetime="2025-10-11T08:32:35.000Z" itemprop="datePublished">2025-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/11/OSPF-OSPF%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">[OSPF]OSPF路由协议基本概念</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>OSPF链路状态路由协议，采用DIjkstra算法，协议本身不存在环路。报文封装在IP层，协议号89，使用组播224.0.0.5和224.0.0.6建立连接。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/11/OSPF-OSPF%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" data-id="cuidbJ-3Jwh64dmMG_wIOHoSS" data-title="[OSPF]OSPF路由协议基本概念" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OSPF/" rel="tag">OSPF</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" rel="tag">网络工程师</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/" rel="tag">路由协议</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-BGP-深入讨论BGP预防环路机制-3-BGP联盟" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/04/BGP-%E6%B7%B1%E5%85%A5%E8%AE%A8%E8%AE%BABGP%E9%A2%84%E9%98%B2%E7%8E%AF%E8%B7%AF%E6%9C%BA%E5%88%B6-3-BGP%E8%81%94%E7%9B%9F/" class="article-date">
  <time class="dt-published" datetime="2025-10-04T01:18:40.000Z" itemprop="datePublished">2025-10-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/04/BGP-%E6%B7%B1%E5%85%A5%E8%AE%A8%E8%AE%BABGP%E9%A2%84%E9%98%B2%E7%8E%AF%E8%B7%AF%E6%9C%BA%E5%88%B6-3-BGP%E8%81%94%E7%9B%9F/">[BGP]深入讨论BGP预防环路机制(3) BGP联盟</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>好的，这是一个非常核心的BGP进阶概念。我们来详细拆解一下这句话：“BGP通过AS内部使用联盟，以此防止环路”。</p>
<p>为了理解它，我们需要分三步走：</p>
<ol>
<li><strong>BGP的防环路基础机制</strong></li>
<li><strong>在单个AS内部（iBGP）遇到的问题</strong></li>
<li><strong>联盟如何解决这个问题并防止环路</strong></li>
</ol>
<hr>
<h3 id="1-BGP的防环路基础机制：AS-PATH"><a href="#1-BGP的防环路基础机制：AS-PATH" class="headerlink" title="1. BGP的防环路基础机制：AS_PATH"></a>1. BGP的防环路基础机制：AS_PATH</h3><p>BGP是一种“路径矢量”路由协议，它防环路的核心机制是 <strong>AS_PATH</strong> 属性。</p>
<ul>
<li><strong>工作原理</strong>：当BGP路由器向外部的AS通告一条路由时，会把自己的<strong>AS号</strong> 添加到AS_PATH列表的最前面。</li>
<li><strong>环路检测</strong>：当一台BGP路由器收到一条路由更新时，它会检查AS_PATH列表。<strong>如果在这个列表中发现了自己的AS号，它就认为这条路由产生了环路，从而丢弃该路由。</strong></li>
</ul>
<p><strong>举个例子：</strong><br>假设AS 100 -&gt; AS 200 -&gt; AS 300。<br>当路由从AS 100传到AS 200时，AS_PATH是 <code>100</code>。<br>当AS 200再传给AS 300时，AS_PATH变成 <code>200 100</code>。<br>如果AS 300试图把这条路由再传回给AS 200，AS 200会在AS_PATH <code>300 200 100</code> 中看到自己的AS号 <code>200</code>，于是它会拒绝接受这条路由，防止了环路。</p>
<hr>
<h3 id="2-在单个AS内部（iBGP）遇到的问题"><a href="#2-在单个AS内部（iBGP）遇到的问题" class="headerlink" title="2. 在单个AS内部（iBGP）遇到的问题"></a>2. 在单个AS内部（iBGP）遇到的问题</h3><p>在一个AS内部，路由器之间使用<strong>iBGP</strong> 来交换BGP路由信息。iBGP有一个非常重要的规则，叫做：</p>
<p><strong>“从一台iBGP对等体学到的路由，永远不会传递给另一台iBGP对等体。”</strong></p>
<p>这被称为 <strong>BGP Split-Horizon</strong>。</p>
<p><strong>为什么要有这个规则？</strong><br>因为在AS内部，<strong>没有AS号被添加到AS_PATH中</strong>！回想一下防环路机制，它是基于AS_PATH来检测的。如果在同一个AS内，路由器之间互相传递路由，AS_PATH不会改变，BGP就无法通过AS_PATH来检测环路。为了防止在AS内部产生路由环路，所以干脆定下这个“死规矩”：iBGP邻居之间传一次就够了，不许二次传播。</p>
<p><strong>这个规则带来的问题：</strong><br>为了保证AS内所有BGP路由器都能学到完整的路由信息，<strong>所有运行iBGP的路由器之间必须形成全互联的邻居关系</strong>。这在一个大型AS中会带来巨大的管理和性能开销（比如有N台路由器，就需要建立 N*(N-1)&#x2F;2 个iBGP会话）。</p>
<hr>
<h3 id="3-联盟如何解决这个问题并防止环路"><a href="#3-联盟如何解决这个问题并防止环路" class="headerlink" title="3. 联盟如何解决这个问题并防止环路"></a>3. 联盟如何解决这个问题并防止环路</h3><p><strong>联盟（BGP Confederations）</strong> 就是为了解决上述“iBGP全互联”问题而设计的一种方法。</p>
<p><strong>它的核心思想是：</strong> <strong>“化整为零”</strong>。把一个大的AS（我们称之为<strong>联盟AS</strong>）划分成多个小的、更容易管理的AS（我们称之为<strong>子AS</strong> 或 <strong>成员AS</strong>）。</p>
<p><strong>具体做法：</strong></p>
<ol>
<li><strong>划分</strong>：将原来的大AS 65000，划分为几个子AS，例如 AS 65001, AS 65002, AS 65003。</li>
<li><strong>对外表现</strong>：对于<strong>联盟外部</strong>的BGP对等体来说，整个联盟仍然被看作<strong>一个单一的AS 65000</strong>。它们完全不知道内部被划分了。</li>
<li><strong>内部运行</strong>：在<strong>联盟内部</strong>，这些子AS之间使用一种特殊的<strong>eBGP</strong> 来交换路由信息。注意，它不是标准的eBGP，而是经过修改的，我们称之为 ** Confederation eBGP**。</li>
</ol>
<h4 id="联盟如何防止环路？"><a href="#联盟如何防止环路？" class="headerlink" title="联盟如何防止环路？"></a><strong>联盟如何防止环路？</strong></h4><p>这里就是最关键的部分了。联盟通过引入两个概念来防止环路：</p>
<p><strong>a) AS_CONFED_SEQUENCE</strong></p>
<p>这是一个类似于AS_PATH的BGP路径属性，但它只在联盟内部使用。</p>
<ul>
<li>当路由在一个子AS（如AS 65001）内传播时，AS_PATH不会改变。</li>
<li>但当路由从一个子AS（AS 65001）传到另一个子AS（AS 65002）时，<strong>发出路由的子AS号（65001）会被添加到 AS_CONFED_SEQUENCE 这个属性中</strong>。</li>
</ul>
<p><strong>b) 联盟内部的环路检测</strong><br>在联盟内部，路由器会同时检查 <strong>AS_PATH</strong> 和 <strong>AS_CONFED_SEQUENCE</strong>。</p>
<ul>
<li>如果在一台属于AS 65002的路由器收到的路由更新中，在 <strong>AS_CONFED_SEQUENCE</strong> 里看到了自己的子AS号 <code>65002</code>，它就会认为这条路由在联盟内部产生了环路，从而将其丢弃。</li>
</ul>
<p><strong>这样一来，联盟就在大的AS内部，重新创建了一个类似于外部AS之间的防环路机制。</strong></p>
<h4 id="工作流程与好处"><a href="#工作流程与好处" class="headerlink" title="工作流程与好处"></a><strong>工作流程与好处</strong></h4><ul>
<li><strong>流程</strong>：<ul>
<li>子AS内部：使用iBGP，遵循iBGP的规则。</li>
<li>子AS之间：使用 Confederation eBGP。它允许像标准eBGP一样传递路由，从而<strong>打破了iBGP全互联的要求</strong>。你只需要在每个子AS的边界路由器之间建立eBGP对等体关系即可。</li>
</ul>
</li>
<li><strong>好处</strong>：<ol>
<li><strong>解决了全互联问题</strong>：大大减少了需要建立的iBGP会话数量。</li>
<li><strong>防止了AS内部环路</strong>：通过AS_CONFED_SEQUENCE属性，在联盟内部实现了可靠的环路检测。</li>
<li><strong>策略灵活性</strong>：可以在子AS之间应用类似于eBGP的路由策略，提供了更精细的控制。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>根本问题</strong>：iBGP因为AS_PATH在AS内不变，无法防环路，所以只能用“全互联”这个笨办法来规避环路，但这在大型网络中不可行。</li>
<li><strong>联盟的解决方案</strong>：将大AS“伪装”成多个小AS的联合体。</li>
<li><strong>防环路机制</strong>：在内部的小AS（子AS）之间通信时，使用一个<strong>新的、只在联盟内部有效的路径属性 <code>AS_CONFED_SEQUENCE</code></strong> 来记录路径。路由器通过检查这个属性来判断是否在联盟内部形成了环路。</li>
</ul>
<p><strong>一个简单的比喻：</strong><br>把一个有1000人的大公司（大AS）重组，分成10个部门（子AS）。</p>
<ul>
<li><strong>以前</strong>：为了保证信息一致，要求这1000人两两之间都要直接沟通（全互联），这根本做不到。</li>
<li><strong>现在</strong>：部门内部（iBGP）自由沟通。部门之间（Confed eBGP）只派代表（边界路由器）沟通，并且每次跨部门传递消息时，都会在内部备忘录（AS_CONFED_SEQUENCE）上盖章，如果一份文件转了一圈又回到本部门，一看备忘录就知道是循环了，直接扔掉。而对于公司外部的人来说，他们仍然只认为这是一个公司（联盟AS）。</li>
</ul>
<p>那是不是可以说，BGP联盟仅适用于IBGP，而在EBGP上不可行？</p>
<p>这是一个非常好的问题，它触及了BGP联盟设计的核心。</p>
<p>首先给出结论：这个说法完全正确，并且非常精准。我们可以这样来理解：</p>
<p><strong>BGP联盟本质上是一种用于“优化和改造大型AS内部iBGP网络”的技术。它不是为了在eBGP上使用，而是为了解决纯iBGP环境下的问题而诞生的。</strong></p>
<p>下面我来详细解释为什么：</p>
<hr>
<h3 id="1-根本目的：解决iBGP的难题"><a href="#1-根本目的：解决iBGP的难题" class="headerlink" title="1. 根本目的：解决iBGP的难题"></a>1. 根本目的：解决iBGP的难题</h3><p>正如我们之前讨论的，iBGP有两大核心问题：</p>
<ul>
<li><strong>防环路机制缺失</strong>：在AS内部传递时，AS_PATH不变，无法用AS_PATH防环。</li>
<li><strong>全互联要求</strong>：导致管理复杂度和资源消耗巨大。</li>
</ul>
<p><strong>联盟就是为了直接解决这两个iBGP特有的问题而设计的。</strong> 如果一个AS很小，根本不需要iBGP全互联，那么联盟也就没有存在的必要。</p>
<hr>
<h3 id="2-实现方式：在AS内部“模拟”eBGP"><a href="#2-实现方式：在AS内部“模拟”eBGP" class="headerlink" title="2. 实现方式：在AS内部“模拟”eBGP"></a>2. 实现方式：在AS内部“模拟”eBGP</h3><p>联盟的实现手法非常巧妙：<strong>它在一个真实的AS内部，创建了多个逻辑上的“子AS”，然后在它们之间运行一种特殊的、经过修改的eBGP。</strong></p>
<p>这里的关键点是：</p>
<ul>
<li><strong>对“外”</strong>：对于联盟之外的、真正的eBGP对等体来说，它们看到的仍然是一个<strong>单一的、完整的AS号</strong>。它们完全不知道这个AS内部被划分成了多个子AS。在与外部通信时，联盟AS的行为和一个普通AS没有任何区别。</li>
<li><strong>对“内”</strong>：在联盟内部，子AS之间的行为<strong>类似于eBGP</strong>（比如可以正常传递路由，而不需要全互联），但又<strong>不是标准的eBGP</strong>（比如下一跳属性、LOCAL_PREF等属性在子AS间依然保持，不像标准eBGP那样默认重置）。</li>
</ul>
<p>所以，<strong>联盟技术是将eBGP的某些机制“内化”为了一个解决iBGP问题的工具。</strong></p>
<hr>
<h3 id="3-为什么说它“在eBGP上不可行”？"><a href="#3-为什么说它“在eBGP上不可行”？" class="headerlink" title="3. 为什么说它“在eBGP上不可行”？"></a>3. 为什么说它“在eBGP上不可行”？</h3><p>这个说法可以从两个层面理解：</p>
<p><strong>a) 从设计初衷和应用场景来看：</strong><br>联盟的设计目标就不是为了用于两个<strong>真正独立的、不同所属的AS</strong> 之间的eBGP连接。比如，你不可能告诉你的运营商：“我们在我们两个AS之间的eBGP链路上启用联盟吧。” 这是没有意义的，因为eBGP本身已经通过AS_PATH完美地解决了环路问题，并且不需要全互联。</p>
<p><strong>b) 从技术细节来看：</strong><br>如果试图在两个真正的eBGP对等体之间使用联盟，会遇到根本性的矛盾：</p>
<ul>
<li><strong>AS号表示</strong>：联盟使用的子AS号通常属于私有AS号范围（64512-65534）。在真正的eBGP会话中，这些私有AS号是不应该被通告给对方的。</li>
<li><strong>路径属性</strong>：联盟内部使用的<code>AS_CONFED_SEQUENCE</code>路径属性，在传递给真正的eBGP对等体之前<strong>必须被移除</strong>。如果将它泄露给外部AS，会导致路由问题，因为外部AS无法理解这个属性。</li>
<li><strong>失去意义</strong>：eBGP本身工作得很好，引入联盟机制不会带来任何好处，反而会破坏标准的防环路和工作机制。</li>
</ul>
<hr>
<h3 id="总结与类比"><a href="#总结与类比" class="headerlink" title="总结与类比"></a>总结与类比</h3><p>让我们用一个比喻来巩固理解：</p>
<ul>
<li><strong>一个大型公司</strong> &#x3D; 一个大的AS（例如AS 65000）</li>
<li><strong>公司内部的部门（如市场部、技术部）</strong> &#x3D; 子AS（AS 65001， AS 65002）</li>
<li><strong>公司与外部公司沟通</strong> &#x3D; eBGP</li>
<li><strong>公司内部的全员大会</strong> &#x3D; iBGP全互联（效率低下）</li>
<li><strong>联盟</strong> &#x3D; 公司重组，设立部门经理。部门内部自由沟通（子AS内的iBGP），部门经理之间开会沟通（子AS间的Confederation eBGP）。对外，公司仍然是一个整体。</li>
</ul>
<p><strong>结论：</strong></p>
<p><strong>BGP联盟是一种专门为解决大型iBGP网络中的全互联和防环路问题而设计的技术。它通过在一个真实的AS内部引入类似eBGP的逻辑关系来实现这一目标，但它本身并不应用于两个独立AS之间的eBGP会话。</strong> 它是“用于iBGP的eBGP-like机制”，而不是“用于eBGP的技术”。</p>
<p>最后，让我们再对IBGP中的全互联，反射路由器RR，以及BGP联盟三大预防环路机制进行详细对比。</p>
<hr>
<h3 id="对比总览"><a href="#对比总览" class="headerlink" title="对比总览"></a>对比总览</h3><table>
<thead>
<tr>
<th align="left">特性维度</th>
<th align="left">全互联</th>
<th align="left">路由反射器</th>
<th align="left">联盟</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心思想</strong></td>
<td align="left">最直接的方法，遵守基础规则</td>
<td align="left"><strong>打破“不传递”规则</strong>：指定特定路由器（RR）来反射路由</td>
<td align="left"><strong>化整为零</strong>：将大AS划分为小AS，内部使用“特殊eBGP”</td>
</tr>
<tr>
<td align="left"><strong>扩展性</strong></td>
<td align="left"><strong>极差</strong><br>会话数呈O(N²)增长</td>
<td align="left"><strong>优秀</strong><br>会话数呈O(N)线性增长</td>
<td align="left"><strong>良好</strong><br>减少了全互联范围，但比RR稍复杂</td>
</tr>
<tr>
<td align="left"><strong>配置与管理复杂度</strong></td>
<td align="left"><strong>低</strong>（概念简单）<br><strong>高</strong>（实际维护会话多）</td>
<td align="left"><strong>中等</strong><br>需要精心设计RR和客户机的拓扑</td>
<td align="left"><strong>高</strong><br>需要规划子AS，配置边界路由器</td>
</tr>
<tr>
<td align="left"><strong>防环机制</strong></td>
<td align="left"><strong>BGP Split-Horizon</strong><br>（从iBGP学到的路由不传给其他iBGP对等体）</td>
<td align="left"><strong>Cluster_List</strong> 和 <strong>Originator_ID</strong> 属性</td>
<td align="left"><strong>AS_CONFED_SEQUENCE</strong> 属性</td>
</tr>
<tr>
<td align="left"><strong>路径可见性</strong></td>
<td align="left">AS_PATH保持原始状态，清晰明了</td>
<td align="left">AS_PATH保持原始状态</td>
<td align="left">对外隐藏内部子AS结构，AS_PATH中只显示联盟AS号</td>
</tr>
<tr>
<td align="left"><strong>策略控制的灵活性</strong></td>
<td align="left">策略在所有路由器上对等应用</td>
<td align="left"><strong>集中化策略</strong><br>可在RR上应用策略，影响其所有客户机</td>
<td align="left"><strong>分布式策略</strong><br>可在子AS边界应用类似eBGP的策略，更精细</td>
</tr>
<tr>
<td align="left"><strong>网络稳定性与故障域</strong></td>
<td align="left"><strong>无单点故障</strong><br>一个会话断开不影响其他会话</td>
<td align="left"><strong>有单点故障风险</strong><br>一个RR故障会影响其所有客户机（可通过冗余缓解）</td>
<td align="left"><strong>故障域隔离</strong><br>一个子AS的问题更容易被隔离在内部</td>
</tr>
<tr>
<td align="left"><strong>迁移难度</strong></td>
<td align="left">N&#x2F;A（基准）</td>
<td align="left"><strong>相对容易</strong><br>可以逐步部署，将部分路由器设为RR的客户机</td>
<td align="left"><strong>相对困难</strong><br>通常需要规划停机时间，重新划分AS并配置边界</td>
</tr>
</tbody></table>
<hr>
<h3 id="深入分析各自特点"><a href="#深入分析各自特点" class="headerlink" title="深入分析各自特点"></a>深入分析各自特点</h3><h4 id="1-全互联"><a href="#1-全互联" class="headerlink" title="1. 全互联"></a>1. 全互联</h4><ul>
<li><strong>优点</strong>：<ul>
<li><strong>简单可靠</strong>：概念上最简单，符合BGP最基础的设计。</li>
<li><strong>无单点故障</strong>：没有中心节点，任何一个iBGP会话的中断只会影响直接相连的两个路由器。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>无法扩展</strong>：这是其致命弱点。当路由器数量超过几十台时，会话数量会变得难以管理，消耗大量内存和CPU资源。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li>小型网络或实验室环境。</li>
<li>作为衡量其他方案优劣的基准。</li>
</ul>
</li>
</ul>
<h4 id="2-路由反射器"><a href="#2-路由反射器" class="headerlink" title="2. 路由反射器"></a>2. 路由反射器</h4><ul>
<li><strong>优点</strong>：<ul>
<li><strong>极佳的扩展性</strong>：大幅减少了iBGP会话数量。是当前大型网络中最主流的解决方案。</li>
<li><strong>易于部署和迁移</strong>：可以从现有全互联网络中逐步引入RR，无需大规模重构网络。</li>
<li><strong>保持逻辑拓扑</strong>：整个AS在逻辑上仍然是一个统一的实体，对外部网络没有影响。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>可能引入单点故障</strong>：如果RR发生故障，其下所有客户机将无法学习到完整的BGP路由。解决方案是部署多个冗余的RR。</li>
<li><strong>潜在的子最优路径</strong>：RR会向所有客户机反射最佳路径，但客户机到该路径的下一跳可能不是最优的，需要依赖IGP的收敛或开启“下一跳自我”功能。</li>
<li><strong>配置复杂性</strong>：需要精心设计RR的层级（如分层RR）和Cluster，配置不当容易引起环路。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li><strong>绝大多数中大型企业和服务提供商网络</strong>。是目前事实上的标准。</li>
</ul>
</li>
</ul>
<h4 id="3-联盟"><a href="#3-联盟" class="headerlink" title="3. 联盟"></a>3. 联盟</h4><ul>
<li><strong>优点</strong>：<ul>
<li><strong>天然的故障域隔离</strong>：将一个大的网络问题分解到多个子AS中，便于管理和故障排查。</li>
<li><strong>策略灵活性强</strong>：在子AS边界，可以像使用eBGP一样应用丰富的路由策略（如MED、AS_PATH预挂等），提供了比RR更精细的控制粒度。</li>
<li><strong>无单点故障</strong>：类似于全互联，在子AS内部是全互联或RR，但子AS之间是网状连接，没有中心化的反射器。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>配置和管理最复杂</strong>：需要规划子AS的划分、分配私有AS号，并配置所有子AS边界路由器。</li>
<li><strong>迁移困难</strong>：从现有网络迁移到联盟架构通常需要详细的计划和可能的业务中断。</li>
<li><strong>调试复杂度增加</strong>：在排查问题时，需要同时关注AS_PATH和AS_CONFED_SEQUENCE。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li>规模极其庞大、结构复杂且由多个独立管理区域组成的网络（例如超大型运营商、经历了多次合并的网络）。</li>
<li>对策略控制有极高要求的特殊场景。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h3><p>在实际网络中，这三种方案并非互斥，经常被<strong>组合使用</strong>以发挥最大效益。</p>
<p><strong>最常见的组合是：路由反射器 + 联盟</strong></p>
<ul>
<li>在一个超大型的联盟AS内，每个子AS的内部可能仍然很大。</li>
<li>此时，可以在<strong>每个子AS内部使用路由反射器</strong>来进一步减少iBGP会话数量。</li>
<li>这样既获得了联盟的故障隔离和策略灵活性，又享受了RR在子AS内部的扩展性优势。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>全互联</strong>是“教科书式”的基准，但不可用于生产大型网络。</li>
<li><strong>路由反射器</strong>是当今的“主流选择”，在扩展性和易用性之间取得了最佳平衡。</li>
<li><strong>联盟</strong>是“高级武器”，提供了最强的控制力和隔离性，但代价是极高的复杂性。</li>
</ul>
<p>选择哪种方案取决于您的网络规模、增长预期、运维团队的技术能力和对网络控制力的具体要求。对于绝大多数网络而言，<strong>路由反射器</strong>都是首选方案。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/04/BGP-%E6%B7%B1%E5%85%A5%E8%AE%A8%E8%AE%BABGP%E9%A2%84%E9%98%B2%E7%8E%AF%E8%B7%AF%E6%9C%BA%E5%88%B6-3-BGP%E8%81%94%E7%9B%9F/" data-id="cuidkL-fu2dKa7tgkITYYZVb7" data-title="[BGP]深入讨论BGP预防环路机制(3) BGP联盟" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BGP/" rel="tag">BGP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" rel="tag">网络工程师</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/" rel="tag">路由协议</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BGP/" rel="tag">BGP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IS-IS/" rel="tag">IS-IS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OSPF/" rel="tag">OSPF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RIP/" rel="tag">RIP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/" rel="tag">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" rel="tag">网络工程师</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/" rel="tag">路由协议</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BGP/" style="font-size: 15px;">BGP</a> <a href="/tags/IS-IS/" style="font-size: 10px;">IS-IS</a> <a href="/tags/OSPF/" style="font-size: 12.5px;">OSPF</a> <a href="/tags/RIP/" style="font-size: 10px;">RIP</a> <a href="/tags/github/" style="font-size: 12.5px;">github</a> <a href="/tags/hexo/" style="font-size: 12.5px;">hexo</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" style="font-size: 20px;">网络工程师</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 20px;">计算机网络</a> <a href="/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/" style="font-size: 17.5px;">路由协议</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/10/">October 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">September 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/10/19/%E5%AF%B9%E6%AF%94%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1%E5%92%8C%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5%E7%9A%84%E4%B8%8D%E5%90%8C/">对比路由策略和策略路由的不同</a>
          </li>
        
          <li>
            <a href="/2025/10/19/%E6%8E%A2%E8%AE%A8%E5%8F%8D%E6%8E%A9%E7%A0%81%E7%9A%84%E4%BD%9C%E7%94%A8/">探讨反掩码的作用</a>
          </li>
        
          <li>
            <a href="/2025/10/19/%E6%B5%85%E6%9E%90%E8%B7%AF%E7%94%B1%E7%9A%84%E6%8E%A7%E5%88%B6%E5%B1%82%E9%9D%A2%E4%B8%8E%E8%BD%AC%E5%8F%91%E5%B1%82%E9%9D%A2/">浅析路由的控制层面与转发层面</a>
          </li>
        
          <li>
            <a href="/2025/10/16/%E6%B5%85%E6%9E%90%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E4%B8%8E%E7%9B%B4%E8%BF%9E%E8%B7%AF%E7%94%B1/">浅析静态路由与直连路由</a>
          </li>
        
          <li>
            <a href="/2025/10/16/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>