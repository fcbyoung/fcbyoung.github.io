[{"title":"如何查看路由表","path":"/2025/11/01/如何查看路由表/","content":"在路由器终端输入 display ip routing-table（或其简写 dis ip rou）后，你会看到路由器返回的路由表信息。理解这些信息的含义至关重要。 下面我将详细解释如何查看和解读这些信息。 一个典型的路由表显示示例在分析之前，我们先看一个典型的输出： Router display ip routing-tableRoute Flags: R - relay, D - download to fib------------------------------------------------------------------------------Routing Tables: Public Destinations : 7 Routes : 7Destination/Mask Proto Pre Cost Flags NextHop Interface 0.0.0.0/0 Static 60 0 D 192.168.1.1 GigabitEthernet0/0/1 10.0.1.0/24 Direct 0 0 D 10.0.1.1 GigabitEthernet0/0/0 10.0.1.1/32 Direct 0 0 D 127.0.0.1 InLoopBack0 10.0.1.255/32 Direct 0 0 D 127.0.0.1 InLoopBack0 192.168.1.0/24 Direct 0 0 D 192.168.1.254 GigabitEthernet0/0/1 192.168.1.254/32 Direct 0 0 D 127.0.0.1 InLoopBack0 192.168.1.255/32 Direct 0 0 D 127.0.0.1 InLoopBack0 逐列解读路由表信息路由表可以看作一个“路径指示牌”，它告诉路由器：要去往某个目的地，应该从哪个接口、把数据包扔给下一个谁。 我们来逐一解读每一列的含义： 1. DestinationMask（目的网络掩码） 含义： 这一行路由条目所指向的目标网络地址和子网掩码。 解读： 0.0.0.0/0 是默认路由，代表“所有未在路由表中明确指定的目标地址”。可以理解为“万能通道”，当没有更精确的路径时，就走这条路。 10.0.1.0/24 代表一个具体的网段，即从 10.0.1.1 到 10.0.1.254 的所有IP地址。 10.0.1.1/32 代表一个主机路由，即一个具体的IP地址（/32 表示掩码为255.255.255.255，精确匹配一个主机）。 2. Proto（协议） 含义： 这条路由是通过什么方式学习到的。 常见类型： Direct： 直连路由。路由器直接连接的网络，只要接口配置了IP地址并处于UP状态，就会自动生成。 Static： 静态路由。由网络管理员手动配置。 RIP、OSPF、IS-IS、BGP： 动态路由协议。路由器之间通过协议算法自动学习到的路由。 3. Pre（优先级） 含义： 路由的“可信度”或“优先级”。数值越小，优先级越高。 解读： 当去往同一个目的网络存在多条不同来源的路由时（例如，一条静态，一条OSPF），路由器会优先选择Pre值最小的路由放入路由表。 直连路由（Direct）的优先级最高，通常是 0。 静态路由（Static）的优先级通常是 60。 OSPF 内部路由的优先级通常是 10。 RIP 的优先级通常是 100。 4. Cost（度量值） 含义： 到达目的网络的“开销”或“距离”。 解读： 当去往同一个目的网络存在多条相同Proto和Pre的路由时（例如，都通过OSPF学到），路由器会优先选择Cost值最小的路径。 对于直连路由，Cost为 0。 对于静态路由，通常可以手动设置，默认为 0。 对于动态路由协议，计算方式不同（如RIP是跳数，OSPF是带宽成本）。 5. Flags（标志） 含义： 路由条目的状态标志。 常见标志： D： 表示这条路由已经下载到转发信息库（FIB） 中，可以被直接用于转发数据包。这是你最常见到的标志。 R： 表示该路由是迭代路由，需要依赖其他路由才能生效。 6. NextHop（下一跳） 含义： 数据包要发送到的下一个路由器的接口IP地址。 解读： 对于直连网络（Direct），下一跳就是该接口自己的IP（如 10.0.1.1）。 对于非直连网络，下一跳是相邻路由器的IP地址（如默认路由的 192.168.1.1）。 127.0.0.1 表示本地环回地址，通常用于指向路由器自身的主机路由。 7. Interface（出接口） 含义： 路由器将要从哪个物理或逻辑接口把数据包发送出去。 解读： 这是数据包离开路由器的“门”。例如 GigabitEthernet0/0/0、GigabitEthernet0/0/1。 如何分析路由表：一个实际场景假设你的电脑（IP：10.0.1.100）要访问百度（假设IP：180.101.49.12）。 路由器收到目标为 180.101.49.12 的数据包。 它在路由表中进行最长匹配查找： 它会从上到下扫描 Destination/Mask 列，寻找与 180.101.49.12 最匹配（即掩码最长）的条目。 它找不到 180.101.49.0/24 这样的精确条目。 它最终会匹配到 0.0.0.0/0（默认路由）。 查看这条默认路由： Proto： Static（管理员配的） NextHop: 192.168.1.1（告诉路由器，把这个包发给 192.168.1.1 这个设备） Interface: GigabitEthernet0/0/1（从 GE0/0/1 这个接口发出去） 路由器于是将数据包从 GigabitEthernet0/0/1 接口转发给 192.168.1.1。 常用查看技巧和过滤命令为了更高效地查看路由信息，你可以使用以下过滤命令： 查看去往特定目标的路由： display ip routing-table ip-address# 例如：查看去往 10.0.1.50 的路由Router display ip routing-table 10.0.1.50 查看来自特定协议的路由： display ip routing-table protocol protocol# 例如：只查看所有的静态路由Router display ip routing-table protocol static# 例如：只查看所有OSPF路由Router display ip routing-table protocol ospf 查看更详细的路由信息（如路由的生存时间等）： display ip routing-table verbose 总结查看 display ip routing-table 的结果，核心就是理解这七个字段的含义。通过分析这些信息，你可以： 诊断网络连通性问题： 数据包是否按照你预期的路径转发？ 验证配置是否正确： 静态路由或动态路由协议是否生效？ 了解网络拓扑结构： 路由器是如何学习到各个网络的路由的？ 熟练掌握路由表的解读，是网络管理和故障排查的一项基本功。","tags":["网络工程师","计算机网络"]},{"title":"路由器与交换机的对比","path":"/2025/10/25/路由器与交换机的对比/","content":"在实际使用场景中，尤其是小型办公室房间里，用路由器还是小型交换机来分路，虽然表面上都是“一分多”，但它们在网络结构、功能和适用场景上有本质的区别。 简单来说，核心区别在于： 路由器：是一个“管理者”，它负责在不同网络之间建立连接和指挥交通。 交换机：是一个“扩展者”，它只负责在同一个网络内部扩大端口数量，让更多设备接入。 下面我们来详细拆解一下。 核心设备解析1. 路由器 核心功能：网络地址转换（NAT）、路由选择、DHCP服务、防火墙。 工作角色：它是一个网络的“大门”和“管理员”。 大门：它连接着两个不同的网络，通常是内部的局域网（比如你办公室的192.168.1.x网络）和外部的广域网（互联网）。所有设备上网都必须经过它。 管理员：它内置了DHCP服务器，会自动给连接它的电脑、手机分配IP地址（如192.168.1.100），让它们能够相互识别和通信。它的防火墙功能可以保护内网设备不受外部的直接攻击。 典型接口：1个WAN口（通常颜色不同） + 多个LAN口。 2. 交换机 核心功能：端口扩展、数据交换。 工作角色：它是一个网络的“接线板”或“立交桥”。 接线板：它的唯一作用就是把一个网络信号扩展成多个，让你可以连接更多的有线设备。 立交桥：它内部有一个交换矩阵，可以让连接在它不同端口上的设备之间高效地直接通信，而不会堵塞其他端口的流量。 典型接口：多个完全相同功能的LAN口（没有WAN口）。 两种工作模式的对比为了更直观，我们来看两种典型的接线方式： 场景一：使用路由器分路接线方式：主网线（来自上一级设备，如光猫或大楼网络端口） → 路由器的WAN口 → 电脑连接在路由器的LAN口上。 网络结构：路由器创建了一个新的、独立的私有局域网（例如192.168.1.x）。办公室里的所有电脑都在这个局域网下。 IP分配：路由器是“老板”，它给自己的LAN口分配一个IP（如192.168.1.1），然后通过DHCP功能给下面的电脑分配IP（如192.168.1.100, 192.168.1.101…）。 访问控制：由于NAT的存在，外网无法直接看到你办公室里的电脑，只能看到路由器，起到了基础的安全防护作用。 场景二：使用交换机分路接线方式：主网线（来自上一级设备） → 交换机的任何一个LAN口 → 电脑连接在交换机的其他LAN口上。 网络结构：交换机没有创建新网络，它只是把你办公室的所有电脑和上一级网络（比如公司总机房）连接在同一个局域网内。 IP分配：交换机是“透明”的，它不管IP地址。所有电脑的IP地址都是由上一级网络中的真正的“路由器”或DHCP服务器来分配的。 访问控制：你的办公室电脑和公司其他部门的电脑可能处于同一个扁平的网络中，缺乏隔离。如果公司有统一的网络管理策略，那么所有设备都在管理员的管控之下。 对比表格总结 特性 路由器 小型交换机 核心功能 连接不同网络、NAT、路由、DHCP、防火墙 扩展网络端口、数据交换 网络层级 创建新的子网络 扩展现有网络，不创建新网络 IP地址管理 自己分配IP（通过DHCP） 不分配IP，只传递数据 安全性 较高，有NAT防火墙隔离内外网 较低，设备暴露在上级网络中 典型接口 区分WAN口和LAN口 所有接口都是相同的LAN口 适用场景 小型独立办公室、家庭、需要创建独立网络的环境 办公室端口扩展、需要接入公司大局域网的工位 实际工作中如何选择和注意事项 什么时候必须用路由器？ 当你需要创建一个独立、私密的办公网络时。例如，一个小的创业团队租用了一个房间，从房东那里拉来一根可以上网的网线，你们希望自己的电脑、打印机形成一个内部网络，不受房东其他租户网络的影响。这时必须用路由器。 当你需要自己控制Wi-Fi（无线路由器）时。 什么时候应该用交换机？ 当办公室只是公司大网络的一部分时。公司总机房已经有核心路由器和交换机来统一管理所有IP和网络安全，你办公室只是需要增加有线网络端口数量。这时用交换机是正确且高效的，因为它不会增加不必要的网络层级（NAT），避免“网络套网络”的复杂结构。 当你发现路由器LAN口不够用，但又不想改变现有网络结构时，可以在路由器的一个LAN口下接一个交换机来扩展端口。 一个常见的错误和现象 错误：把上一级来的网线误插到路由器的LAN口，然后把电脑插到其他LAN口。这时路由器失去了路由功能，退化成了一个交换机（通常WAN口会失效）。虽然可能能上网，但DHCP等功能可能会冲突，造成网络不稳定。 现象：如果你办公室的电脑IP地址和公司其他部门电脑的IP地址在同一个网段（比如都是10.10.XX），那么你们用的肯定是交换机模式。如果你的电脑IP是192.168.x.x，而公司其他部门不是，那么你们办公室很可能用了路由器。 总结一句话： 想自己“另立门户”，搞一个独立小王国，就用路由器。想简单地“扩大地盘”，接入已有的公司大网络，就用交换机。","tags":["计算机网络"]},{"title":"vlan，vlanif与vlan间通信","path":"/2025/10/24/vlan，vlanif与vlan间通信/","content":"一.vlan交换机划分vlan后，不同vlan间无法通过二层直接通信，需经过三层的路由进行通信。 一个常见的比喻： VLAN 就像一栋大楼里的不同楼层。二层通信就像楼层内部的人可以互相喊话（广播）和传递纸条（单播）。 路由 就像大楼里的电梯楼梯。不同楼层的人要通信，必须经过电梯楼梯（路由）才能到达另一个楼层。 二.vlan间通信首先，我们要明确一个核心矛盾： VLAN的初衷是隔离：划分VLAN的主要目的是隔离广播域，增强网络安全性，简化管理。默认情况下，不同VLAN之间的设备是无法通信的。 业务需求是互通：在实际网络中，不同部门（处于不同VLAN）可能需要访问共同的服务器（如财务服务器、文件服务器），或者需要访问互联网。这就产生了跨VLAN的通信需求。 结论：VLAN解决了“不该通的不能通”的问题，而VLAN间通信则是在此基础上，解决“该通的如何通”的问题。 常用的方式有单臂路由，vlanif等。 三.单臂路由这是一种经典但目前已较少在核心网络中使用的方法。 核心思想：使用一个物理路由器，通过一个物理接口连接交换机。交换机与路由器相连的接口配置为Trunk口，允许多个VLAN的流量通过。 实现方式：在路由器和交换机相连的物理接口上创建多个子接口，每个子接口对应一个VLAN，并分配一个IP地址作为该VLAN的网关。 工作过程： PC1 (VLAN 10) 要发送数据给 PC2 (VLAN 20)。 数据帧被打上VLAN 10的标签，通过Trunk链路发送给路由器。 路由器收到后，由其子接口处理，剥掉VLAN标签，进行路由查询。 发现目标网络在VLAN 20，于是通过对应的VLAN 20子接口将数据帧发出，并重新打上VLAN 20的标签。 交换机收到带VLAN 20标签的帧，将其转发给PC2。 优缺点： 优点：概念清晰，利用现有路由器设备。 缺点：路由器成为性能和单点故障的瓶颈，所有跨VLAN流量都要经过这一条物理链路（“单臂”），容易形成拥堵。 四.vlanif 核心思想：将路由功能集成到交换机内部。三层交换机既具备二层交换的所有功能，也具备三层路由功能。 关键组件：VLANIF接口 什么是VLANIF？ 它是一个逻辑的三层接口，也常被称为 SVI。它不是物理存在的，而是通过命令行创建的。 作用：为每个VLAN创建一个VLANIF接口，并为其分配IP地址。这个IP地址就充当了该VLAN内所有设备的默认网关。 位置：路由功能在三层交换机内部的高速ASIC芯片中完成，速度极快，可以达到“线速路由”。 工作过程： 在三层交换机上为VLAN 10创建VLANIF 10，配置IP地址192.168.10.1/24；为VLAN 20创建VLANIF 20，配置IP地址192.168.20.1/24。 PC1 (VLAN 10， IP 192.168.10.2) 要访问 PC2 (VLAN 20， IP 192.168.20.2)。 PC1判断目标PC2与自己不在同一网段，于是将数据包发送给自己的网关192.168.10.1（即交换机的VLANIF 10接口）。 数据包进入交换机后，在内部从二层交换流程上送到三层路由引擎。 三层引擎查询路由表，发现目标网络192.168.20.0/24 是直连路由，出接口是VLANIF 20。 于是，数据包被重新封装，源MAC地址改为VLANIF 20的MAC，目的MAC改为PC2的MAC。 交换机根据目标MAC地址，将数据包从属于VLAN 20的端口转发给PC2。 优缺点： 优点： 高性能：基于硬件转发，速度远快于传统路由器。 低延迟：无需离开设备，内部完成路由。 简化拓扑：无需外接路由器，网络结构更简洁。 缺点：成本比二层交换机高。 总结： 根本原理：VLAN间通信的本质是三层路由。数据包必须经过一个具有路由功能的设备（路由器或三层交换机）。 VLANIF的核心角色： 它是VLAN的网关接口。每个需要与外部通信的VLAN都需要一个VLANIF接口。 它是一个逻辑的三层接口，是三层路由功能的入口和出口。 它的IP地址是所在VLAN内所有主机的默认网关。 通信流程简化模型： 源主机 - 发送到本VLAN的网关（VLANIF） - 三层设备路由 - 从目标VLAN的网关（VLANIF）送出 - 目标主机 配置示例（以华为三层交换机为例）： bash # 创建VLANSwitch system-view[Switch] vlan batch 10 20# 将端口加入VLAN (假设G0/0/1属于VLAN10， G0/0/2属于VLAN20)[Switch] interface gigabitethernet 0/0/1[Switch-GigabitEthernet0/0/1] port link-type access[Switch-GigabitEthernet0/0/1] port default vlan 10[Switch] interface gigabitethernet 0/0/2[Switch-GigabitEthernet0/0/2] port link-type access[Switch-GigabitEthernet0/0/2] port default vlan 20# 创建VLANIF接口并配置IP地址（网关）[Switch] interface vlanif 10[Switch-Vlanif10] ip address 192.168.10.1 255.255.255.0[Switch] interface vlanif 20[Switch-Vlanif20] ip address 192.168.20.1 255.255.255.0 完成以上配置后，VLAN 10和VLAN 20之间就可以互相通信了。 总结对比表 特性 单臂路由（传统路由器） 三层交换机（VLANIF） 核心设备 物理路由器 三层交换机 实现接口 物理接口的子接口 逻辑VLANIF接口 性能 低，受CPU和链路带宽限制 高，硬件ASIC线速转发 延迟 较高 极低 网络拓扑 复杂，需要Trunk链路 简洁，设备内部完成 成本 可能较低（利用现有设备） 较高（三层交换机更贵） 适用场景 小型网络，临时需求 中大型企业网、园区网核心","tags":["网络工程师","计算机网络","交换机","vlan"]},{"title":"vlan与交换机","path":"/2025/10/24/vlan与交换机/","content":"一.vlanvlan可以将统一物理局域网内不同用户从逻辑上划分为不同广播域，不同vlan间隔离广播域。 vlan范围0~4095,0和4095不可用。vlan 1为默认vlan。 相同vlan间的主机可基于二层通信，不同vlan主机不可基于二层通信。 （意思是不同vlan间主机可基于单臂路由，或vlanif等方式从三层建立通信渠道） 二.与vlan相关的三种交换机模式(1)access我们可以把Access接口的工作过程想象成一个严格的“门卫”，它只允许属于特定VLAN（即缺省VLAN）的流量通过，并且会帮数据帧“穿上”或“脱掉”制服（VLAN标签）。 核心概念： PVID (Port VLAN ID)： 端口的缺省VLAN ID。这是Access接口最重要的属性，可以理解为这个接口的“身份牌”。 VID (VLAN ID)： 数据帧本身携带的VLAN标签中的ID。 Tag (标签)： 数据帧在交换机内部传输时，为了区分属于哪个VLAN而加上的一个4字节的报头。 详细解读： “可以使用接口VLAN编号(PVID)对数据帧封装和剥离VLAN标签(VID)，可以传输一个VLAN流量。通常用于交换机与PC相连接。” 理解： 这句话是总述。它点明了Access接口的两个核心功能（打标签和撕标签）和它的根本特性（只能属于一个VLAN）。应用场景是连接PC、服务器、打印机等通常不支持VLAN标签的设备。 “(1)对接收不带Tag的报文处理” 场景： 一台PC发送一个普通的以太网数据帧给交换机。PC根本不知道VLAN是什么，所以发送的帧是“原始的”、不带Tag的。 动作： 交换机Access接口的“门卫”看到这个没穿制服的帧，会根据自己身上的身份牌（PVID），给它穿上对应的制服（打上PVID值的VLAN标签）。然后这个帧才能在交换机内部转发。 “(2)对接收带Tag的报文处理” 场景： 这种情况较少见于终端设备，但可能发生在配置错误或网络攻击时。一个带着VLAN标签的帧到达了Access接口。 动作： “门卫”会检查这个帧的制服号码（VID）是否和自己的身份牌（PVID）一致。 ① 相同： 罕见但允许的情况。比如这个帧是从另一个配置了相同PVID的Access接口发过来的（可能是配置失误）。门卫会放行。 ② 不同： 这是绝大多数情况。门卫认为“这不是我们部门的人，穿错制服了”，会直接丢弃该报文。这是Access接口实现VLAN隔离的关键一步。 “(3)发送帧处理过程” 场景： 交换机需要将一个数据帧从这个Access接口发送给相连的PC。 动作： 数据帧在交换机内部是穿着制服（带Tag）的。在发出接口前，“门卫”会帮它把制服脱掉（剥离VLAN标签），还原成一个普通的以太网帧，再发送给PC。因为PC不希望、也看不懂VLAN标签。 总结与补充1. 核心特点总结 单向VLAN成员关系： 一个Access接口在某一时刻只能属于一个VLAN。这是它和Trunk、Hybrid接口最根本的区别。 安全与隔离： 其“丢弃与PVID不同Tag的帧”的行为，是实现VLAN间二层隔离的基础，增强了网络安全性。 即插即用： 对于下联设备（如PC）来说，它完全感知不到VLAN的存在，简化了终端配置。 2. 配置相关 配置命令（以华为华三设备为例）：interface GigabitEthernet 0/0/1 # 进入接口视图port link-type access # 将接口模式设置为Accessport default vlan 10 # 设置接口的PVID为10 不进行这些配置，接口通常默认为Hybrid模式，PVID为1，行为会不符合预期。 3. 常见应用场景扩展 连接终端用户设备： 如PC、IP电话（语音VLAN通常用其他方式处理）、打印机。 连接服务器： 如果服务器只需要在一个VLAN内通信。 连接路由器或防火墙的接口： 当需要实现“单臂路由”或VLAN间路由时，连接路由器的交换机接口通常配置为Access模式，属于一个特定的VLAN。 一个简单的比喻 公司部门： 每个VLAN就像一个部门（如财务部VLAN 10，技术部VLAN 20）。 Access接口： 就像是每个员工的工位网口。这个网口只属于他所在的部门（PVID部门号）。 接收不带Tag的帧： 员工在自己工位写了一封普通信件（数据帧），交给交换机。交换机会在信上盖一个“财务部”（VLAN 10）的章（Tag），然后只在财务部内部传递。 接收带Tag的帧： 如果一封盖着“技术部”章的信误传到财务部员工的工位，工位网口（Access接口）会直接把这封信扔掉（丢弃），确保财务部的网络不会收到技术部的广播流量。 发送帧： 当有信从交换机发给员工时，交换机会在发出前把“财务部”的章撕掉，员工看到的还是一封普通信件。 (2)trunkTrunk接口是交换机互联的关键，理解它对于构建复杂网络至关重要。 详细解读我们可以把Trunk接口想象成一个高速公路的收费站检查站，它负责管理多条”车道”（多个VLAN）的流量，确保每辆车（数据帧）都在正确的车道上行驶。 核心概念（在Access基础上新增）： 允许通过的VLAN列表（Allowed VLAN List）：这是Trunk接口最重要的特性之一，定义了哪些VLAN的流量可以通行。 PVID在Trunk中的特殊作用：除了处理无标签帧，还决定了哪个VLAN的帧在发送时会被”隐藏身份”（去标签）。 对原文的解读：1. “可以使用接口VLAN编号(PVID)对数据帧封装和剥离VLAN标签(VID)，可以传输多个VLAN流量。通常用于交换机之间互联。” 理解：这句话点明了Trunk接口与Access接口的根本区别——多VLAN传输能力。应用场景是交换机之间的互联，用于在骨干链路上承载多个VLAN的流量。 2. “(1)对接收不带Tag的报文处理” 场景：一台不支持VLAN的设备（如老式交换机或配置错误的设备）向Trunk接口发送了无标签帧。 动作：Trunk接口的”收费员”看到这辆没有”通行证”（Tag）的车，会给它发放一个默认的”临时通行证”（打上PVID）。 ① PVID在允许列表中：检查这个临时通行证（PVID）是否在允许通行的VLAN名单里。如果在，就放行这辆车。 ② PVID不在允许列表中：如果临时通行证不在名单上，则拒绝这辆车进入高速（丢弃报文）。这是一种安全机制，防止未知VLAN的流量进入网络。 3. “(2)对接收带Tag的报文处理” 场景：这是Trunk接口的正常工作场景。从另一台交换机收到了带有明确VLAN标签的帧。 动作：”收费员”直接检查车辆自带的”通行证”（VLAN ID）。 ① VLAN ID在允许列表中：通行证有效，允许进入相应车道（接收报文）。 ② VLAN ID不在允许列表中：通行证无效，禁止进入（丢弃报文）。这是实现VLAN修剪（VLAN Pruning）的关键，可以手动控制哪些VLAN流量可以通过Trunk链路，避免不必要的广播流量泛滥。 4. “(3)发送帧处理过程” 场景：交换机需要通过Trunk接口将数据帧发送给另一台交换机。这里的处理规则是Trunk接口最精妙的部分。 动作：”收费员”在车辆出口处，根据它的目的地决定是否收回”通行证”。 ① 当VLAN ID与PVID相同，且在允许列表中：如果这辆车属于”本地车辆”（VLAN ID PVID），就收回它的通行证（去掉Tag），让它以普通车辆（无标签帧）的身份出去。这样做主要是为了兼容对端设备可能不支持VLAN的情况，但现代网络中，建议始终保持Tagged。 ② 当VLAN ID与PVID不同，但在允许列表中：如果这辆车是”过境车辆”（VLAN ID ≠ PVID），则保留它的通行证（保持原有Tag），让它继续在高速上行驶。这是Trunk接口的典型行为，确保对端交换机能够正确识别VLAN。 总结与补充1. 核心特点总结 多VLAN干线：核心功能是在一条物理链路上承载多个VLAN的流量，极大提高了链路利用率。 显式允许列表：必须通过配置明确指定哪些VLAN可以通过（allowed VLAN list）。默认情况下，某些厂商的设备可能只允许缺省VLAN（VLAN 1）通过，这是一个常见的安全陷阱。 PVID的”本地VLAN”概念：在Trunk接口上，PVID通常被称为”Native VLAN“。这个VLAN的流量在发送时会被去标签，因此要求互联的交换机Trunk接口的Native VLAN必须一致，否则会导致安全问题和通信故障。 2. 配置相关 配置命令（以华为华三设备为例）：interface GigabitEthernet 0/0/24port link-type trunk # 设置接口为Trunk模式port trunk pvid vlan 10 # （可选）设置Native VLAN为10，默认为1port trunk allow-pass vlan 10 20 30 # 允许VLAN 10, 20, 30的流量通过 注意：如果不配置allow-pass，Trunk接口可能无法传递任何需要的VLAN流量。 3. 实际应用中的关键考量 Native VLAN的安全问题：因为Native VLAN的帧是不带标签传输的，如果攻击者接入一个Access接口并将其PVID设置为Trunk的Native VLAN，他可能截获到其他VLAN的流量（如果交换机配置不当）。最佳实践是：将Native VLAN设置为一个不使用的、专门的VLAN，而不是VLAN 1。 VLAN修剪：只允许必要的VLAN通过Trunk链路。例如，一栋楼的接入交换机只需要允许本楼的用户VLAN和公共VLAN上行到核心，而不需要允许其他楼的VLAN，这样可以减少不必要的广播流量。 与Access接口的对比记忆： 特性 Access接口 Trunk接口 VLAN数量 1个 多个 主要用途 接终端 接交换机网络设备 接收无标签帧 打上PVID 打上PVID，并检查PVID是否在允许列表 接收有标签帧 仅接受VIDPVID的帧 接受VID在允许列表中的帧 发送帧 总是去掉Tag 仅当VIDPVID时去掉Tag，否则保留 4. 一个典型的Trunk应用场景 场景：一栋大楼的每层有一台接入交换机（Access Switch），通过Trunk链路连接到中心机房的核心交换机（Core Switch）。 配置： 接入交换机Trunk口：allow-pass vlan 10, 20（本层的两个VLAN） 核心交换机Trunk口：allow-pass vlan 10, 20, 30, 40, 99（所有楼的VLAN和一个管理VLAN） 工作流程： 三楼用户（VLAN 10）发数据到服务器（VLAN 99）。 接入交换机通过Access接口收到无标签帧，打上VLAN 10标签。 查询MAC地址表后，决定通过Trunk口发送给核心交换机。 因为VLAN 10 (≠ PVID) 在允许列表中，帧带着VLAN 10标签被发送。 核心交换机收到带标签的帧，识别出属于VLAN 10，进行路由转发到VLAN 99。 核心交换机将帧从连接服务器机房的Trunk口发出，因为VLAN 99在允许列表中，帧带着VLAN 99标签被发送。 比喻升级：从”门卫”到”高速公路收费站” Trunk链路：连接两座城市（交换机）的高速公路。 允许通过的VLAN列表：收费站允许通行的车辆类型清单（小客车、货车、客车等）。 接收带Tag的报文：一辆挂着”货车”（VLAN 20）牌照的车驶来。收费站检查”货车”是否在允许通行的清单上。如果在，放行。 Native VLAN (PVID)：这条高速上的”本地车辆专用通道”。本地车辆（VLAN ID PVID）通过时不需要显示牌照（无标签），但必须在清单上。 发送帧处理：车辆要驶出收费站。如果是本地车辆，就收起牌照（去标签）通过；如果是其他类型的车辆，就继续挂着牌照（带标签）通过。 (3)hybridHybrid接口是华为华三交换机特有的模式，也是最灵活的一种接口模式。它融合了Access和Trunk的特性，提供了更精细的控制能力。 详细解读我们可以把Hybrid接口想象成一个高度智能的”多功能交通枢纽”，它既能像Access接口那样处理终端设备，又能像Trunk接口那样处理多VLAN流量，而且还能对每个VLAN的”出入站规则”进行个性化设置。 核心概念（Hybrid特有的）： 按VLAN配置发送行为：这是Hybrid接口最核心的特性。对于每个允许通过的VLAN，都可以单独配置它在发送时是带Tag（Tagged） 还是不带Tag（Untagged）。 详细解读：1. “可以使用接口VLAN编号(PVID)对数据帧封装和剥离VLAN标签(VID)，并具有多个VLAN标签的携带或剥离选择性配置，可以传输多个VLAN流量。可以用于交换机与PC相连接或交换机之间互联。” 理解：这句话概括了Hybrid接口的最大特点——灵活性。它既具备Access接口的打标签去标签能力，又具备Trunk接口的多VLAN传输能力，而且还能选择性地控制每个VLAN的标签处理方式。因此它应用场景非常广泛。 2. “(1)对接收不带Tag的报文处理” 场景：与Trunk接口完全一致。一个终端设备（如PC）发送无标签帧到Hybrid接口。 动作： ① PVID在允许列表中：打上PVID，接收报文。 ② PVID不在允许列表中：打上PVID，但丢弃报文。这说明Hybrid接口的接收逻辑与Trunk接口完全相同。 3. “(2)对接收带Tag的报文处理” 场景：与Trunk接口完全一致。从网络设备收到带标签的帧。 动作： ① VLAN ID在允许列表中：接收报文。 ② VLAN ID不在允许列表中：丢弃报文。再次确认，Hybrid接口的接收逻辑与Trunk接口完全一致。 4. “(3)发送帧处理过程” 场景：这是Hybrid接口与Trunk接口的根本区别所在！交换机要通过Hybrid接口发送一个数据帧。 动作：首先检查VLAN ID是否在允许列表中。如果在，则不依赖于PVID，而是依赖于管理员为该VLAN预先配置的指令： 如果配置该VLAN为tagged：则帧带标签发送。 如果配置该VLAN为untagged：则帧去标签发送。 注意：原文”可以通过命令设置发送时是否携带Tag”是Hybrid接口的灵魂所在！ 总结与补充1. 核心特点总结 极致的灵活性：Hybrid接口打破了Trunk接口”仅PVID对应VLAN可去标签发送”的限制，允许为每一个VLAN独立指定发送时的标签状态。 接收行为与Trunk相同：在数据帧的接收方向上，Hybrid接口的逻辑与Trunk接口完全一致。 发送行为可定制：在数据帧的发送方向上，Hybrid接口提供了最精细的控制粒度。 2. 配置相关 配置命令（华为华三设备为例）：interface GigabitEthernet 0/0/1port link-type hybrid # 设置接口为Hybrid模式port hybrid pvid vlan 10 # 设置PVID（Native VLAN）为10port hybrid untagged vlan 10 20 # 设置VLAN 10和20以Untagged方式发送port hybrid tagged vlan 30 99 # 设置VLAN 30和99以Tagged方式发送 关键：一个VLAN不能同时被配置为tagged和untagged，但一个接口上可以同时存在多个tagged和多个untagged的VLAN。 3. 典型应用场景（这是理解Hybrid价值的关键）场景1：单线复用（连接IP电话和PC） 需求：一台IP电话和一台PC共用一条网线连接到交换机。电话需要属于VLAN 10（语音VLAN），PC需要属于VLAN 20（数据VLAN）。 解决方案： 交换机连接电话的接口配置为Hybrid。 port hybrid pvid vlan 20 （PC的无标签流量默认划入VLAN 20） port hybrid untagged vlan 20 （发给PC的VLAN 20流量去标签） port hybrid tagged vlan 10 （发给电话的VLAN 10流量带标签，电话能识别VLAN标签） 效果：一根网线同时传输两个VLAN的流量，且各自以正确格式送达终端。 场景2：灵活的网络设备互联 需求：连接另一台交换机，但希望VLAN 100（管理VLAN）以无标签形式传输（简化对端配置），其他业务VLAN（VLAN 10, 20, 30）以标准Trunk方式（带标签）传输。 解决方案： port hybrid pvid vlan 100 port hybrid untagged vlan 100 管理VLAN去标签 port hybrid tagged vlan 10 20 30 业务VLAN带标签 4. 三种接口模式对比总结 特性 Access接口 Trunk接口 Hybrid接口 VLAN数量 1个 多个 多个 主要用途 接终端 接网络设备 接终端或网络设备 接收无标签帧 打上PVID 打上PVID，检查PVID是否允许 同Trunk 接收有标签帧 仅接受VIDPVID 接受VID在允许列表中 同Trunk 发送帧规则 总是去掉Tag VIDPVID：去标签VID≠PVID：带标签 可配置：指定VLAN去标签(Untagged)指定VLAN带标签(Tagged) 灵活性 低 中 高 5. 比喻升级：Hybrid作为”智能多功能交通枢纽” Hybrid接口：一个大型国际机场的边检和登机口系统。 允许通过的VLAN列表：机场允许通行的国家地区列表。 接收处理：与Trunk”收费站”逻辑相同，检查护照（VLAN标签）是否在允许名单上。 发送处理（核心区别）：在登机口（发送帧时），系统会根据乘客的目的地（VLAN ID）和预先设置的规定： 去标签（Untagged）：飞往”国内航班”（如VLAN 10）的乘客，收回他们的护照（去标签），让他们像国内旅客一样登机。 带标签（Tagged）：飞往”国际航班”（如VLAN 20, 30）的乘客，需要继续持有护照（带标签）登机。 关键：这个规则不是基于乘客来自哪里（PVID），而是基于他们的目的地，并且可以由管理员为每个目的地（每个VLAN）单独设置。 三类接口核心总结 Access： 一个接口，一个VLAN。接终端。 Trunk： 一个接口，多个VLAN。接另一台交换机或路由器。允许带Tag的多个VLAN流量通过。 Hybrid： 一个接口，多个VLAN。混合模式，更灵活，可以手动指定哪些VLAN带Tag发送，哪些不带Tag发送。兼具Access和Trunk的部分特性。","tags":["网络工程师","计算机网络","交换机","vlan"]},{"title":"关于交换机的深入理解","path":"/2025/10/24/关于交换机的深入理解/","content":"定义与作用交换机，工作在数据链路层，端口隔离冲突域，所有端口属于一个广播域。可以把交换机理解为多端口的网桥。 冲突域：同一时间只能有一台设备发送数据的网络区域。若多个设备同时发送数据，会导致信号冲突（数据碰撞），需进行重传。 广播域：网络中某一设备可同时向网络中所有其他设备发送数据。 同一广播域内通信属于二层通信。 不同广播域间通信属于三层通信。 说到这里，让我们详细分析下“交换机隔离冲突域”这一说法背后的原理： 还是回到交换机每个端口都是一个独立的冲突域这一知识点。 交换机的多端口，好比把一条单车道马路（一个大的冲突域）划分成若干多车道（多个小冲突域）。 工作原理交换机根据MAC地址转发数据帧，通过ARP机制学习MAC地址并生成MAC地址表项（接口与MAC的映射关系），交换机得到数据帧后，只会查看二层帧头，并根据MAC表项对数据帧进行转发。 交换机转发模式(1)直通式转发 交换机接收到数据帧后，不进行缓存校验直接转发出去。 (2)存储式转发 交换机首先在缓冲区存储接收到的整个数据帧，再进行CRC校验，校验通过再进行转发。不正确则丢弃 。 (3)碎片隔离式转发 交换机在接收数据帧时，会先缓存帧的前64字节，当帧大于64字节再进行转发。","tags":["网络工程师","计算机网络"]},{"title":"路由协议的抑制接口详解","path":"/2025/10/24/路由协议的抑制接口详解/","content":"抑制接口配置，也叫被动接口，是指在运行动态路由协议（如OSPF、RIP）的路由器上，将一个或多个接口配置为“被动”状态。 简单来说：被抑制的接口会停止向该接口所在的网络广播或多播路由更新报文，但它仍然会接收并处理来自该网络的路由更新，并且该接口直连的网络仍会被通告到其他非抑制的接口。 可以把它想象成一个 “只听不说” 的接口。 为什么要抑制接口？（目的与好处）主要出于三个目的：安全性、节约资源和优化网络行为。 增强网络安全性 防止路由器将内部路由信息泄露给不该接收的设备。例如，在连接用户PC或公共服务器的接口上，这些设备不需要也不应该参与路由学习过程。如果它们收到了路由更新，可能会被恶意利用来进行网络拓扑探测或攻击。 减少不必要的网络流量（节约带宽和CPU资源） 在没有其他路由器、只有终端设备（如PC、打印机、服务器）的网段上，定期发送路由更新报文（尤其是RIP的广播或OSPF的组播）是完全不必要的。这只会浪费网络带宽和终端设备的CPU资源（因为它们需要处理并丢弃这些报文）。 避免建立不必要的邻居关系 对于OSPF和EIGRP这类需要建立邻居关系的协议，抑制接口可以防止路由器在不需要的链路上尝试建立邻居关系，从而避免相关的控制平面开销和可能的错误日志。 不同路由协议中的抑制接口行为虽然概念相同，但在不同协议中的具体行为有细微差别： 1. RIP 行为：在抑制接口上，RIP将停止发送路由更新报文。但它仍然会监听该接口上收到的RIP更新。 典型应用场景：连接终端主机的局域网接口。 2. OSPF 行为：在抑制接口上，OSPF将停止发送Hello报文。 关键影响：由于Hello报文是建立和维护OSPF邻居关系的基础，停止发送Hello报文意味着无法在该接口上建立邻居关系。因此，该接口也不会发送LSA（链路状态通告）或接收LSA。 该接口的IP地址仍会被包括在Router LSA中，作为一个Stub网络被通告出去。 典型应用场景：不希望运行OSPF的接口，例如连接用户的接口或指向某些特定服务提供商的接口。 配置示例（以Cisco IOS为例）RIP 配置Router(config)# router ripRouter(config-router)# version 2Router(config-router)# passive-interface GigabitEthernet0/1 # 抑制GE0/1接口Router(config-router)# network 10.0.0.0 OSPF 配置Router(config)# router ospf 1Router(config-router)# passive-interface GigabitEthernet0/1 # 抑制GE0/1接口Router(config-router)# network 10.1.1.0 0.0.0.255 area 0 常用技巧：passive-interface default可以将所有接口默认设置为抑制状态，然后手动开启需要建立邻居关系的接口。这是一种更安全的方法。 Router(config)# router ospf 1Router(config-router)# passive-interface default # 默认抑制所有接口Router(config-router)# no passive-interface Serial0/0/0 # 只在S0/0/0接口上启用OSPF 总结 特性 定义 目的 关键影响 抑制接口被动接口 让路由协议在某个接口上 “只听不说” 或 “既不听也不说” 1. 安全性：防止路由信息泄露2. 效率：减少不必要流量和开销3. 优化：避免无用邻居关系 RIP：停止发送更新，但仍接收。OSPFEIGRP：停止发送Hello，无法建立邻居，停止所有路由协议通信。 简单来说，抑制接口是一种精细化的路由协议管理工具，它让你能够精确控制路由信息在何处被发送，从而构建一个更安全、更高效、更稳定的网络。","tags":["网络工程师","计算机网络","路由协议"]},{"title":"对比RIP，IS-IS，OSPF，BGP四大路由协议（2）路由聚合","path":"/2025/10/23/对比RIP，IS-IS，OSPF，BGP四大路由协议（2）路由聚合/","content":"一. 什么是路由聚合？路由聚合，也常被称为路由汇总 或超网，是一种网络设计技术。它的核心思想是：将多个连续的、更小的IP地址网络（子网）合并成一个更大的、单一的地址块，并在网络中只通告这个汇总后的路由。 你可以把它想象成现实生活中的邮政系统： 没有聚合：邮局需要知道每一个具体的门牌号（如：北京路1号、2号、3号…）才能送信，路由表会非常庞大。 使用聚合：邮局只需要知道“所有寄往北京路的信都扔到这个分拣中心”即可。这个“北京路”就是一个聚合后的路由。 技术上的实现：路由聚合依赖于无类域间路由（CIDR） 的思想。它通过缩短IP地址的网络前缀（即子网掩码变短）来实现。 举个例子：假设一个路由器后面连接着以下四个子网： 192.168.0.024 192.168.1.024 192.168.2.024 192.168.3.024 如果我们不进行聚合，路由器需要向网络中的其他路由器分别通告这4条路由条目。 但如果我们进行聚合： 将这些地址写成二进制，观察它们的前缀。 我们发现这四个子网的前24位是相同的，但从第25位开始有变化。 我们可以找到一个更短的公共前缀：22。 计算后，这个聚合后的路由就是：192.168.0.022。 这个 /22 的网络包含了从 192.168.0.0 到 192.168.3.255 的所有地址，完美覆盖了原来的四个 /24 子网。现在，路由器只需要向外通告 192.168.0.022 这一条路由，就代表了背后的所有四个子网。 为什么路由协议中要使用路由聚合？在路由协议（如OSPF, EIGRP, BGP等）中部署路由聚合，主要是为了解决以下几个核心问题，并带来巨大的网络效益： 1. 大幅减小路由表规模这是最直接、最重要的好处。互联网的核心路由器和大型企业网络的核心设备承载着数十万甚至百万条路由。通过聚合，可以将成百上千条具体路由压缩成几条汇总路由，极大地减轻了路由器内存的负担。 2. 提高路由效率和转发性能路由表越小，路由器查询“最佳路径”的速度就越快。这直接提升了数据包的转发效率，降低了处理延迟。 3. 限制路由波动的影响，增强网络稳定性在大型网络中，某一条具体链路的“翻动”（频繁UpDown）会导致该路由信息在网络中被反复通告和撤销。这种现象称为路由抖动。 没有聚合：一个子网的抖动会传播到整个网络，导致所有路由器不停地重新计算路由表，消耗CPU资源，甚至引发网络震荡。 使用聚合：由于外部路由器只知道聚合后的路由（如上面的192.168.0.022），而不知道内部具体的子网（如192.168.1.024）。因此，内部某个子网的抖动被限制在了聚合边界之内，不会影响到外部网络。这极大地提升了整个网络的稳定性。 4. 节省网络带宽更少的路由条目意味着路由协议在邻居之间发送的路由更新报文体积更小，占用的链路带宽也更少。 5. 隐藏网络细节，提升安全性聚合对外部网络隐藏了内部寻址的具体结构。从外部看，你只知道有一个大的地址块（如192.168.0.022），但无法知晓其内部具体划分了多少个子网以及它们的拓扑结构。这在一定程度上增加了网络攻击的难度。 6. 简化网络设计和维护通过将网络设计成层次化结构（核心、汇聚、接入），并在汇聚层进行路由聚合，可以使网络逻辑更清晰，故障排查和日常维护也更加容易。 总结 特性 未使用路由聚合 使用路由聚合 路由表大小 庞大，包含所有明细路由 精简，只有汇总路由 性能 查询慢，转发效率较低 查询快，转发效率高 稳定性 路由抖动易传播，不稳定 隔离路由抖动，更稳定 带宽占用 路由更新信息多，占用带宽大 路由更新信息少，节省带宽 网络设计 扁平化，复杂难维护 层次化，清晰易维护 简单来说，路由聚合是构建大规模、可扩展、稳定高效网络的一项基础且至关重要的技术。 它通过“抓大放小”的策略，用一条汇总信息代表一系列明细网络，从而解决了网络规模增长带来的诸多挑战。 二. RIP路由聚合详解RIP的路由聚合主要作用在于减少路由表规模和提升网络稳定性。华为设备支持两种聚合方式： 特性 自动路由聚合 (有类聚合) 手动路由聚合 (无类聚合) 配置视图 RIP视图 接口视图 聚合原则 按自然网络边界（主类网络）聚合 按自定义网络边界（无类别地址）聚合 优先级 低 高 主要命令 summary 或 summary always rip summary-address ip-address mask 配置步骤 配置自动路由聚合在系统视图下进入RIP进程，并确保版本为RIP-2，然后使能聚合功能。 HUAWEI system-view[HUAWEI] rip 1[HUAWEI-rip-1] version 2[HUAWEI-rip-1] summary 如果配置了水平分割或毒性反转，普通summary命令会失效，此时可以使用summary always命令强制开启聚合。 配置手动路由聚合手动聚合提供了更精细的控制，可以在指定接口上发布一条聚合后的路由。 HUAWEI system-view[HUAWEI] interface GigabitEthernet 0/0/1[HUAWEI-GigabitEthernet0/0/1] rip summary-address 192.168.0.0 255.255.0.0 添加avoid-feedback参数可以防止从该接口再学习到相同的聚合路由，避免潜在环路。 ⚠️ 核心注意事项 与防环机制的冲突：这是RIP聚合配置中最关键的一点。水平分割和毒性反转功能会阻止在同一个接口发送从该接口学来的路由，这导致自动聚合在配置了这些功能的接口上失效。解决方案是： 在需要发送聚合路由的接口上关闭水平分割和毒性反转。 或者，直接使用summary always命令，此命令能无视防环机制，强制进行聚合。 优先级规则：当同时配置了自动聚合和接口手动聚合时，手动聚合的优先级更高。只有当某些子网路由超出了手动聚合的地址范围时，RIP的自动聚合路由才会被发布出去。 版本要求：路由聚合是RIP-2的特性，RIP-1不支持。在配置前请确保已执行version 2命令。 防止路由环路：在NBMA（非广播多路访问）网络等复杂拓扑中配置聚合时，使用avoid-feedback参数是防止路由环路的有效手段。 三. IS-IS路由聚合详解IS-IS的路由聚合是一项关键功能，主要用于缩减路由表规模、优化网络资源利用并提升网络稳定性。 在华为设备上，配置IS-IS路由聚合的核心命令是 summary ip-address mask 。你还可以通过一些可选参数来精确控制聚合行为： 参数 说明 level-1 仅对引入到Level-1区域的路由进行聚合。 level-2 仅对引入到Level-2区域（骨干区域）的路由进行聚合。此为缺省级别。 level-1-2 同时对向Level-1和Level-2区域引入的路由进行聚合。 avoid-feedback 避免设备通过路由计算再学习到自身发布的聚合路由。 generate_null0_route 生成一条Null0路由，用于防止路由环路。 tag tag 为聚合路由分配一个管理标签，常用于通过路由策略匹配路由。 📝 配置步骤与查看结果配置IS-IS路由聚合的基本步骤如下： 进入系统视图：system-view。 进入IS-IS视图：isis [ process-id ]。 配置路由聚合：summary ip-address mask [ 可选参数 ] *，例如 summary 192.168.0.0 255.255.248.0 level-2。 提交配置：commit。 配置完成后，可以使用 display isis route 命令查看IS-IS路由表中的聚合路由，或使用 display ip routing-table verbose 命令查看IP路由表中的聚合路由。 🏗️ 理解IS-IS路由聚合的应用理解IS-IS路由聚合，关键在于把握其应用场景和生效特点。 应用场景与好处在大中型IS-IS网络中，配置路由聚合能有效减少路由表中的条目数量，节省设备内存和网络资源。同时，当被聚合地址范围内的某条具体链路发生震荡时，这种变化不会被传播到聚合范围之外，从而避免了频繁的LSP扩散和SPF计算，提升了网络的稳定性。 生效特点与位置IS-IS路由聚合只对本地设备生成的LSP（链路状态报文）中的路由生效。这意味着，配置聚合的设备，其本地路由表仍然会显示所有具体路由；但接收到该设备发出的聚合LSP的其他设备，其路由表中则只会出现聚合后的路由。 通常，在作为Level-1-2路由器并负责将Level-1路由泄漏到Level-2区域的设备上配置聚合非常有效。这可以防止Level-1区域内的链路抖动影响到整个骨干区域。 ⚠️ 重要注意事项配置IS-IS路由聚合时，有几点需要特别留意： 聚合路由的开销值：聚合后路由的开销值（Cost）取所有被聚合的具体路由中的最小开销值。 避免路由环路：在特定网络拓扑中（如NBMA网络），合理使用 avoid-feedback 和 generate_null0_route 参数有助于防止路由环路。 IPv6支持：对于IPv6网络，IS-IS也支持路由聚合，配置命令为 ipv6 summary ipv6-address prefix-length。 💎 总结总的来说，IS-IS路由聚合通过将多条具体路由汇总为更粗略的路由，有效提升了大规模网络的效率和稳定性。配置时，关键在于选择合适的聚合位置（通常是Level-1-2路由器）和精细控制聚合参数。 四.OSPF路由聚合详解下面这个表格汇总了OSPF路由聚合的主要特点和华为设备的配置命令： 特性维度 ABR路由聚合 (区域间路由聚合) ASBR路由聚合 (外部路由聚合) 配置视图 OSPF区域视图 (area area-id) OSPF进程视图 (ospf [process-id]) 核心配置命令 abr-summary ip-address mask asbr-summary ip-address mask 聚合对象 同一OSPF区域内的内部路由 (Type-3 LSA) 通过重分发引入的外部路由 (Type-5Type-7 LSA) 主要目的 减少区域间传播的LSA数量，缩小其他区域路由表 减少引入OSPF域内的外部路由数量，抑制外部路由波动 可选参数举例 cost、not-advertise、generate-null0-route cost、not-advertise、tag 🔧 配置步骤与说明ABR路由聚合 在ABR（区域边界路由器）上进行配置。它的主要目的是将来自某个区域内部的一组连续路由，在ABR向其他区域发送路由信息时，聚合成一条汇总路由。这样可以减少其他区域中LSDB的规模。 具体配置步骤如下： 进入系统视图：system-view。 进入OSPF进程视图：ospf [process-id]。 进入特定的OSPF区域视图：area area-id。 配置ABR路由聚合命令：abr-summary ip-address mask [ [ cost { cost | inherit-minimum } | [ advertise [ generate-null0-route ] | not-advertise | generate-null0-route [ advertise ] ] ] * ]。 ASBR路由聚合 在ASBR（自治系统边界路由器）上进行配置。当大量外部路由被引入到OSPF时，ASBR路由聚合可以对引入的路由进行聚合，这样可确保每次发布的聚合路由信息携带更多的有效路由，避免由于不正确的路由信息造成的网络振荡。 具体配置步骤如下： 进入系统视图：system-view。 进入OSPF进程视图：ospf [process-id]。 配置ASBR路由聚合命令：asbr-summary ip-address mask [ not-advertise | tag tag | cost cost | distribute-delay interval ] *。 ⚠️ 配置要点与注意事项 聚合路由的开销值（Cost）： 对于ABR聚合，默认情况下，聚合路由的开销取所有被聚合的具体路由中的最大开销值。你也可以通过cost参数手动指定一个开销值。 对于ASBR聚合，默认情况下，聚合路由的开销取所有被聚合的外部路由中的最大开销值。如果是Type2外部路由，则聚合路由的开销值是所有被聚合路由中的最大开销值再加上1。同样，你也可以通过cost参数手动指定。 not-advertise参数的使用： 在abr-summary或asbr-summary命令中配置not-advertise参数，可以抑制聚合路由的通告。这意味着符合该聚合地址范围的路由将不会被发布出去。这个功能可以用于精确控制路由的传播范围。 生成Null0路由以防止环路： 在配置ABR路由聚合时，可以使用 generate-null0-route 参数。这会在本地生成一条指向Null0接口的聚合路由，作为一种防环机制。当匹配到聚合路由但找不到更精确的具体路由时，数据包会被丢弃，从而避免形成路由环路。 聚合与网络规划： 为了更有效地实施路由聚合，在规划网络时，应尽量为同一区域分配连续的网络地址。连续的地址块更容易被聚合，能充分发挥路由聚合的优势。 📝 参考配置实例以下是一个在华为设备上配置OSPF ASBR路由聚合的示例： #ospf 2 asbr-summary 192.168.2.0 255.255.254.0 // 聚合192.168.2.0/24和192.168.3.0/24等连续路由 import-route direct // 引入直连路由 area 0.0.0.0 network 192.168.0.0 0.0.0.255# 此配置将引入的直连路由（例如192.168.2.024和192.168.3.024）聚合为一条路由192.168.2.023发布到OSPF网络中。 五. BGP路由聚合详解BGP的路由聚合是控制路由表规模和优化网络稳定性的关键手段，主要分为自动聚合和手动聚合两种方式。下面这个表格汇总了它们的核心特性，方便你快速了解： 特性维度 自动聚合 手动聚合 配置命令 summary automatic aggregate ipv4-address { mask 生效对象 仅对通过 import-route 命令引入的路由有效（如直连、静态、OSPF等） 对BGP本地路由表中已存在的明细路由有效 聚合方式 按IP地址的自然网段（Classful）进行聚合 按配置的无类别地址块进行聚合，更为灵活 优先级 低于手动聚合 更高 适用场景 快速简化路由，但在现代网络中不推荐使用 推荐使用，提供精细控制 🔧 配置要点与步骤自动聚合配置自动聚合的配置相对直接，但需要注意其局限性。 进入系统视图和BGP视图：HUAWEI system-view[HUAWEI] bgp 100[HUAWEI-bgp] ipv4-family unicast // 进入IPv4单播地址族视图 （可选）引入路由：如果尚未引入，可配置例如 import-route direct 引入直连路由。 使能自动聚合：在对应的地址族视图下执行 summary automatic。 手动聚合配置手动聚合提供了强大的控制能力，通过为 aggregate 命令添加不同的关键字，可以实现复杂的聚合策略： 命令关键字 功能说明 detail-suppressed 只发布聚合路由，抑制所有明细路由的通告。 suppress-policy route-policy-name 有选择地抑制部分明细路由，匹配路由策略的明细路由被抑制，其他的仍可通告。 as-set 生成携带 AS_SET 属性的聚合路由，该属性包含了所有被聚合明细路由的AS路径信息，用于防止路由环路，但在明细路由频繁变化时可能导致路由振荡。 attribute-policy route-policy-name 通过路由策略来设置聚合路由的属性（如Community、MED等）。 origin-policy route-policy-name 只根据通过路由策略筛选出的明细路由来生成聚合路由。 配置手动聚合的基本步骤为： 进入系统视图和BGP视图，并选择合适的地址族视图（如 ipv4-family unicast）。 使用 aggregate 命令并组合所需的关键字，例如：[HUAWEI-bgp-af-ipv4] aggregate 10.1.0.0 255.255.0.0 detail-suppressed// 这将聚合10.1.0.0/16的路由，并抑制所有明细路由。 ⚠️ 重要注意事项 手动聚合的前提：BGP本地路由表中必须至少存在一条属于该聚合地址范围的明细路由，手动聚合才能生效并生成聚合路由。例如，BGP路由表中不存在 10.1.1.0/24 这样的明细路由，那么配置 aggregate 10.1.0.0 255.255.0.0 是无效的。 聚合路由的下一跳：手动聚合产生的聚合路由，其出接口默认为 Null0。这是一种防环机制，但需要注意确保该聚合路由不会成为设备自身的优选路由，否则可能导致流量被错误丢弃。 as-set 属性的权衡：使用 as-set 可以保留AS路径信息以防环，但会导致聚合路由携带的AS_PATH变为无序的AS集合。当聚合范围内的任何一条明细路由发生抖动时，都会引起整个聚合路由的更新，因此在聚合大量AS路径或明细路由频繁变化时需谨慎使用。 📊 四大路由协议聚合方式概览下表简要对比了RIP、OSPF、IS-IS和BGP的路由聚合特性，帮助你建立一个整体的认识。 协议 聚合类型 主要特点与说明 RIP 自动手动 如前述，手动聚合优先级高，需注意与防环机制配合。 OSPF 手动 主要在区域边界路由器（ABR） 上进行区域间路由聚合，以及在自治系统边界路由器（ASBR） 上进行外部路由聚合。 IS-IS 手动 通常在Level-1-2路由器上将Level-1路由聚合后发布到Level-2区域，也可以在Level-2路由器上进行聚合。支持通过路由策略精细控制。 BGP 手动 聚合灵活性最高，可通过aggregate命令生成聚合路由，并灵活控制是否抑制具体路由、是否携带AS_SET属性等，常用于优化庞大的互联网路由表。","tags":["网络工程师","计算机网络"]},{"title":"对比RIP，IS-IS，OSPF，BGP四大路由协议（1）宣告路由","path":"/2025/10/21/对比RIP，IS-IS，OSPF，BGP四大路由协议（1）宣告路由/","content":"一、RIP路由协议RIP是一种基于距离矢量的内部网关协议，它通过UDP 520端口进行路由信息交换。在华为设备上，其宣告方式相对直接。 1. 宣告命令在华为设备上，你需要在RIP进程视图下使用 network 命令来宣告直连网络。关键点在于：network 后面跟的是主类网络号（即A、B、C类网络），RIP会自动将该主类网络下的所有直连接口启用RIP。 基本配置步骤： Huawei system-view[Huawei] rip [process-id] # 启动RIP进程，进程ID默认为1[Huawei-rip-1] version 2 # 强烈建议使用RIPv2，支持VLSM和认证[Huawei-rip-1] network 192.168.1.0 # 宣告主类网络。例如，如果接口IP是192.168.1.1/24，则宣告192.168.1.0[Huawei-rip-1] network 10.0.0.0 # 宣告另一个主类网络，例如A类网络10.0.0.0 示例：假设路由器有一个接口G000，IP地址为 192.168.1.1/24，另一个接口G001，IP地址为 10.1.1.1/24。配置如下： [Huawei] rip 1[Huawei-rip-1] version 2[Huawei-rip-1] network 192.168.1.0[Huawei-rip-1] network 10.0.0.0# 注意：即使接口地址是10.1.1.1，也只需宣告其主类网络号 10.0.0.0 2. 注意事项 宣告主类网络：这是最核心也最容易出错的地方。network 命令后跟的是有类网络地址，而不是子网或接口IP。RIP进程会检查所有直连接口的IP地址，只要落在该主类网络范围内，该接口就会： 开始发送和接收RIP更新。 将该接口的IP网络地址宣告给邻居。 RIP版本： RIPv1：广播更新、不支持VLSM、不支持认证。基本已淘汰。 RIPv2：组播更新（224.0.0.9）、支持VLSM和CIDR、支持明文MD5认证。当前标准配置。 在与其他厂商设备互操作时，可能需要使用 undo summary 命令关闭自动汇总。 自动汇总：RIPv2默认开启自动汇总（在边界路由器上会将子网路由汇总为主类网络宣告出去）。在不连续子网环境中，这会导致路由问题，需要使用 undo summary 命令关闭。 好的，您的理解非常准确。与RIP、OSPF需要明确宣告网络范围不同，IS-IS的“宣告”方式确实非常独特，它不直接宣告IP网段，而是宣告路由器本身。 二、IS-IS路由协议IS-IS是一个链路状态协议，最初为OSI（开放式系统互联）网络设计，后来被扩展以支持IP。它的核心思想是：每台路由器在链路状态协议数据单元中通告自己的链路状态信息，而不是直接宣告IP网络。 1. “宣告”方式：启用IS-IS并分配NET地址在IS-IS中，所谓的“宣告”包含两个关键步骤： 在路由器上全局启用IS-IS进程，并为其分配一个网络实体名称。 在特定接口上启用IS-IS协议，使该接口参与IS-IS路由计算和邻接关系建立。 基本配置步骤： Huawei system-view[Huawei] isis [process-id] # 启动IS-IS进程，进程ID默认为1[Huawei-isis-1] network-entity 49.0001.0010.0100.1001.00 # 配置NET地址，这是路由器的唯一标识[Huawei-isis-1] quit[Huawei] interface gigabitethernet 0/0/0 # 进入需要运行IS-IS的接口[Huawei-GigabitEthernet0/0/0] isis enable [process-id] # 在该接口上启用IS-IS 示例：假设我们要在接口G000和G001上运行IS-IS。 [Huawei] isis 1[Huawei-isis-1] network-entity 49.0001.0000.0000.0001.00[Huawei-isis-1] quit[Huawei] interface gigabitethernet 0/0/0[Huawei-GigabitEthernet0/0/0] isis enable 1[Huawei-GigabitEthernet0/0/0] quit[Huawei] interface gigabitethernet 0/0/1[Huawei-GigabitEthernet0/0/1] isis enable 1 2. 核心机制与注意事项 NET地址： 这是IS-IS中最重要的标识符，相当于OSPF中的Router-ID加上区域ID的结合体。 格式：AA.AAAA.BBBB.BBBB.BBBB.CC AA.AAAA：区域地址（Area ID）。 BBBB.BBBB.BBBB：系统ID（System ID），在一个域内必须唯一。通常由Loopback接口的MAC地址或IP地址转换而来。 CC：SEL，对于IP路由而言，总是00。 路由器通过NET地址来识别彼此和计算SPF树。 接口启用： 在接口视图下使用 isis enable 命令后，该接口就会： 发送和接收IS-IS Hello报文，与同一链路上的邻居建立邻接关系。 将该接口的IP地址和掩码作为TLV信息放入其LSP中，并泛洪给其他邻居。 间接宣告：路由器A在接口G000上配置了IP地址 192.168.1.1/24 并启用了IS-IS。那么，A会在自己生成的LSP中携带信息：“我连接到了一个IP网络 192.168.1.0/24”。其他路由器收到这个LSP后，就能学习到这条路由。 层级与网络类型： 层级：IS-IS有两级层级。 is-level： 可以配置为 level-1（类似OSPF的完全末节区域）、level-2（骨干路由器）或 level-1-2（默认，边界路由器）。 网络类型： 类似于OSPF，需要在接口下指定网络类型，如 isis circuit-type p2p 用于点对点链路，这对于正确建立邻接至关重要。 与RIPOSPF的对比总结： RIPOSPF：network IP网络 - 宣告一个网络范围，落在该范围内的接口被激活。 IS-IS：network-entity NET + interface下 isis enable - 宣告路由器本身，并明确指定哪些接口参与通信。 简单来说，IS-IS的“宣告”逻辑是： “大家好，我是路由器 [NET]，我连接到了以下这些IP网络…”，而这些网络信息是通过在接口上启用IS-IS来自动收集和分发的。 三、OSPF路由协议OSPF是一种基于链路状态的内部网关协议。它的核心思想是：每台路由器通过泛洪LSA来描述自己周围的网络拓扑，所有路由器共同维护一个相同的链路状态数据库，然后各自独立地使用SPF算法计算出无环的最短路径树。 1. 宣告方式：在区域中宣告精确的网络范围与RIP宣告主类网络不同，OSPF使用 network 命令来精确地匹配接口，并将匹配成功的接口放入指定的OSPF区域中。宣告的本质是：“让这个接口参与OSPF路由进程，并将其连接的网段信息以LSA的形式发布出去。” 基本配置步骤： Huawei system-view[Huawei] ospf [process-id] router-id router-id # 启动OSPF进程并配置Router-ID[Huawei-ospf-1] area area-id # 进入区域视图（通常是区域0）[Huawei-ospf-1-area-0.0.0.0] network ip-address wildcard-mask # 宣告网络（反掩码方式） 示例：假设路由器有一个接口G000，IP地址为 192.168.1.1/24，另一个接口G001，IP地址为 10.1.1.1/24。我们希望G000在区域0，G001在区域1。 [Huawei] ospf 1 router-id 1.1.1.1[Huawei-ospf-1] area 0[Huawei-ospf-1-area-0.0.0.0] network 192.168.1.0 0.0.0.255[Huawei-ospf-1] area 1[Huawei-ospf-1-area-0.0.0.1] network 10.1.1.0 0.0.0.255 关键点：反掩码 反掩码也叫通配符掩码，与子网掩码相反。 0 表示需要精确匹配的位。 1 表示忽略的位。 所以，对于 192.168.1.0/24 网段，其反掩码是 0.0.0.255。这条命令的意思是：将所有IP地址前24位（即192.168.1）匹配的接口激活OSPF，并放入相应区域。 更现代的宣告方式：在接口下直接启用OSPF华为设备也支持一种更直观、更精确的配置方式，推荐使用： [Huawei] ospf 1 router-id 1.1.1.1[Huawei-ospf-1] area 0[Huawei-ospf-1-area-0.0.0.0] quit[Huawei-ospf-1] quit[Huawei] interface gigabitethernet 0/0/0[Huawei-GigabitEthernet0/0/0] ospf enable 1 area 0 # 在该接口上直接启用OSPF并指定区域 这种方式避免了反掩码的计算，更加清晰，不易出错。 2. 核心机制与注意事项 Router-ID： 这是OSPF中路由器的唯一标识，格式类似于IP地址（如 1.1.1.1）。 必须唯一，否则会导致路由计算混乱。通常手动配置为Loopback接口的IP地址，以确保稳定性。 选择顺序：手动配置 最大Loopback接口IP 最大物理接口IP。 区域概念： OSPF通过区域来实现层次化设计和规模扩展。Area 0是骨干区域，是必需的，所有非骨干区域必须直接与Area 0相连。 宣告时必须指定接口所在的区域，这是RIP所没有的概念。 网络类型： OSPF接口有不同的网络类型（如Broadcast、P2P、NBMA、P2MP），这会直接影响邻居发现和DRBDR的选举。需要根据实际链路类型进行正确配置。 引入外部路由：与RIP类似，使用 import-route 命令。 [Huawei-ospf-1] import-route static # 引入静态路由，默认为Type-2外部路由[Huawei-ospf-1] import-route rip 1 # 引入RIP路由 总结比喻： RIP 像一个传令兵，每隔一段时间就跑到邻居那里告诉他：“我听说去往某某地方要经过X跳”。信息是二手、三手的，且相对模糊（只宣告主类网络）。 OSPF 像一个测绘团队，每台路由器都会绘制自己周围的精确地图（LSA），然后大家互相交换地图碎片，最终每台路由器都拼出一张完整的网络地图（LSDB），并自己计算去往所有目的地的最短路径。宣告的接口就是地图上的精确坐标。 好的，我们来讲解BGP，并最后对RIP、OSPF和BGP的宣告方式进行对比总结。 四、BGP路由协议BGP是一种路径矢量协议，也是事实上的互联网外部网关协议标准。与IGP（内部网关协议，如RIP、OSPF）不同，BGP的核心设计目标是在不同自治系统之间提供可控的、策略驱动的路由交换，而不是简单地寻找最短路径。 1. 宣告方式：手动、精确地发布网络BGP的宣告哲学与IGP完全不同。它不会自动宣告任何路由。你必须明确地告诉BGP进程：”请将这条路由发布给我的BGP邻居”。这种设计赋予了网络管理员极大的控制权。 BGP路由注入的两种主要方式： network 命令 重分发 基本配置步骤： Huawei system-view[Huawei] bgp as-number # 启动BGP进程，指定本地AS号[Huawei-bgp] router-id router-id # 配置Router-ID（必须唯一）[Huawei-bgp] peer ip-address as-number as-number # 配置BGP邻居（对等体）[Huawei-bgp] ipv4-family unicast # 进入IPv4单播地址族视图[Huawei-bgp-af-ipv4] network ip-address mask mask # 精确宣告网络（必须带掩码） 示例：假设公司AS号为65001，需要向BGP邻居（IP为2.2.2.2，AS号为65002）宣告网络 192.168.1.0/24 和 10.1.0.0/16。 [Huawei] bgp 65001[Huawei-bgp] router-id 1.1.1.1[Huawei-bgp] peer 2.2.2.2 as-number 65002[Huawei-bgp] ipv4-family unicast[Huawei-bgp-af-ipv4] network 192.168.1.0 mask 255.255.255.0[Huawei-bgp-af-ipv4] network 10.1.0.0 mask 255.255.0.0 2. 核心机制与注意事项 network 命令的条件： 这是BGP中最重要也最容易混淆的一点。使用 network 命令宣告一条路由时，该路由必须已经存在于本地的IP路由表中（可以是直连路由、静态路由或IGP学习到的路由）。 BGP的 network 命令是 “发布” 命令，而非OSPFRIP的 “激活” 命令。它不激活任何接口，只是将IP路由表中已有的路由复制到BGP表中，然后发送给邻居。 重分发： 另一种常见方式是将IGP路由或静态路由重分发到BGP中。 命令：[Huawei-bgp-af-ipv4] import-route ospf 1 或 import-route static 注意：重分发需要非常小心，因为它可能意外地将内部路由泄露到互联网上。通常建议使用精确的 network 命令来控制要宣告的路由。 邻居关系： BGP邻居（对等体）必须手动指定，这与IGP的自动发现邻居截然不同。 邻居可以是不同AS的（EBGP），也可以是同一AS内的（IBGP）。两者行为有显著差异（如EBGP默认跳数、IBGP的水平分割规则）。 策略驱动： BGP的强大之处在于其丰富的路径属性（如AS_PATH、NEXT_HOP、LOCAL_PREF、MED等）。 宣告路由时，通常会配合路由策略来修改这些属性，以影响入站和出站的流量路径。例如，使用 filter-policy 或 route-policy 来过滤或设置属性。 RIP、OSPF、BGP宣告方式对比总结 特性 RIP OSPF BGP 协议类型 距离矢量IGP 链路状态IGP 路径矢量EGP 宣告哲学 激活接口以宣告其所在主类网络 激活接口到特定区域以宣告其精确网络 发布IP路由表中已存在的特定路由 宣告命令 network 10.0.0.0 network 10.1.1.0 0.0.0.255 area 0 或 接口下 ospf enable network 10.1.0.0 mask 255.255.0.0 关键参数 主类网络号 区域ID、网络地址+反掩码 AS号、网络地址+掩码 自动性 自动宣告匹配接口的主类网络 自动宣告匹配接口的精确网络 完全不自动，必须手动发布每条路由 控制粒度 粗（按主类网络） 细（按接口精确网络） 最精细（按任意前缀掩码） 邻居建立 自动（广播组播） 自动（组播） 手动指定每个邻居 设计目标 简单互通，找”跳数少”的路径 快速收敛，找”成本低”的最优路径 策略控制，找”符合策略”的路径 总结比喻： RIP 像一个社区广播：”我们小区（主类网络）的人可以互相串门了！” 信息比较模糊。 OSPF 像一个城市规划局，将城市划分为不同的区域，并精确绘制每条街道（接口网络）的地图，让大家都能找到最优路径。 BGP 像一个国家间的外交官，他不会自动透露任何信息。只有当本国政府（IP路由表）明确授权，并且他手动准备好外交照会（network命令）后，他才会有选择地、附带各种条件地将特定信息（路由）告知给手动指定的外国大使（BGP邻居）。","tags":["网络工程师","计算机网络"]},{"title":"对比路由策略和策略路由的不同","path":"/2025/10/19/对比策略路由和路由策略的不同/","content":"简单来说，核心区别在于： 路由策略：控制路由信息的流动路径，影响的是路由表。它回答的问题是：“哪些路由信息可以被学习、发布或接收？” 策略路由：控制数据包的转发路径，影响的是数据包的转发行为。它回答的问题是：“对于特定的数据包，我应该走哪条路径，而不是根据路由表？” 下面我们通过一个详细的对比表格和解释来深入理解它们的差异。 策略路由 vs. 路由策略 详细对比 对比维度 策略路由 路由策略 核心本质 “路”不由“表”定 “表”由“策”定 英文术语 Policy-Based Routing Route Policy Routing Policy 操作对象 数据包 路由信息 工作层次 数据转发层面 路由控制层面 决策依据 源IP地址、目的IP地址、协议类型、端口号、报文大小、入接口等丰富的条件 通常基于目的地址（以及路由属性如AS-Path、Community、MED等） 优先级 高于 传统路由表。当PBR生效时，它会绕过标准路由表进行转发决策。 影响 传统路由表。它决定了哪些路由能进入路由表，从而间接影响转发。 主要工具 Route-map（在接口下通过 ip policy route-map 调用） Route-map, Filter-list, Prefix-list, AS-Path ACL 等 应用场景 1. 基于源IP的选路（如不同网段走不同ISP）2. 负载分担（非基于目的地址的）3. 服务质量（将特定流量引向防火墙、优化器等） 1. 路由过滤（只接收或发布特定路由）2. 路由属性修改（如BGP的Local_Pref, MED, AS_Path）3. 路由引入（在路由协议间重分布时进行过滤和属性设置） 配置位置 通常在入方向接口上应用 通常在路由协议的配置中（如 neighbor 语句下）或重分布点时应用 资源消耗 较高。因为需要对每个数据包进行复杂的策略匹配。 较低。仅在路由信息更新时进行计算。 通俗比喻为了更好地理解，我们可以用一个快递分拣系统来比喻： 路由策略 就像是快递公司的总部规则： 规则决定了哪些地区的包裹信息（路由）可以被接收和发送到各个分拣中心（路由器）。 例如，“我们不接收来自A地区的包裹信息”，或者“所有发往B地区的包裹信息，都标记为高优先级”。 最终，每个分拣中心都形成了一张“我们能派送的区域表”（路由表）。 策略路由 就像是某个特定分拣中心的自定义流水线： 尽管总部的“区域表”上说“发往B地区的包裹都走陆路”，但这个分拣中心额外规定：“所有从X小区来的，发往B地区的包裹，全部走空运”。 这个规定凌驾于总部的“区域表”之上，它不看目的地是否相同，而是看更具体的来源等特征。 典型配置示例假设一个网络场景：路由器有两个出口，一个连接到ISP1 (10.1.1.1)，另一个连接到ISP2 (20.1.1.1)。 1. 路由策略场景目标：在运行BGP时，只从ISP1学习关于 192.168.0.0/16 网段的路由。 ! 创建一个前缀列表，定义我们感兴趣的路由ip prefix-list FROM-ISP1 permit 192.168.0.0/16! 创建一个Route-map来调用这个前缀列表route-map ROUTE-POLICY permit 10 match ip address prefix-list FROM-ISP1! 在BGP进程中，对来自ISP1邻居的路由应用这个策略router bgp 100 neighbor 10.1.1.1 route-map ROUTE-POLICY in 效果：只有 192.168.0.0/16 这条路由会被放入路由表，其他从ISP1发来的路由将被过滤掉。 2. 策略路由场景目标：将所有来自 172.16.1.0/24 网段的流量，强制发送到ISP2，即使路由表指出最佳路径是ISP1。 ! 创建一个ACL来匹配感兴趣的流量（基于源IP）access-list 100 permit ip 172.16.1.0 0.0.0.255 any! 创建一个Route-map来定义动作route-map PBR permit 10 match ip address 100 set ip next-hop 20.1.1.1 ! 强制设置下一跳为ISP2! 在接收到流量的入口接口上应用PBRinterface GigabitEthernet0/0 ip policy route-map PBR 效果：当数据包从 GigabitEthernet0/0 进入，且源IP是 172.16.1.0/24 时，路由器会忽略自己的路由表，直接将其转发给 20.1.1.1 (ISP2)。 总结 特性 策略路由 路由策略 核心 控制数据包路径 控制路由信息 对象 数据包 路由 优先级 高（覆盖路由表） 低（生成路由表） 资源消耗 高 低 适用场景 精细化的流量工程 路由协议的管理和优化 简单来说，路由策略是“管理地图”，而策略路由是“指挥司机”。前者决定了你手里地图上画了哪些路，后者则是在实际开车时，命令司机无视地图，直接开向某条特定的路。"},{"title":"探讨反掩码的作用","path":"/2025/10/19/探讨反掩码的作用/","content":"普通掩码（子网掩码）和反掩码虽然都使用32位二进制格式，但它们的设计目的和逻辑是完全相反的。普通掩码用于IP地址划分，用连续的1和0表示，而反掩码是匹配工具，用0和1表示要检查或忽略的位。 因此，在ACL和OSPF宣告这种需要“匹配”或“指定范围”的场景下，反掩码比普通掩码更灵活、更精确。 下面我们来详细解释为什么。 1. 核心概念：目的不同 普通掩码（子网掩码） 目的： 定义一个IP地址中哪部分是网络位，哪部分是主机位。 逻辑： 掩码中的 1 表示网络位，0 表示主机位。它必须是连续的1和0。 例子： 255.255.255.0 (/24) 表示前24位是网络地址，后8位是主机地址。它定义的是一个连续的、完整的IP地址段。 反掩码 目的： 作为一个通配符掩码，用来匹配一个或多个IP地址。 逻辑： 掩码中的 0 表示“必须精确匹配”，1 表示“不关心，可以任意”。 例子： 0.0.0.255 表示前24位必须精确匹配，后8位可以是任意值。 2. 为什么在ACL中使用反掩码？访问控制列表的核心功能是匹配数据包的源目标IP地址，并执行允许或拒绝操作。这种匹配通常不是针对单个主机，而是针对一个网段，甚至是多个不连续的IP。 场景1：匹配一个完整的子网 你想允许 192.168.1.0/24 这个网段的所有主机。 ACL语句： permit 192.168.1.0 0.0.0.255 解释： IP地址： 192.168.1.0 (这是一个代表网段的参考点) 反掩码： 0.0.0.255 (二进制为 00000000.00000000.00000000.11111111) 匹配规则：前三个八位组 (192.168.1) 必须精确匹配 (0)，最后一个八位组可以是任何值 (255)。所以它匹配从 192.168.1.0 到 192.168.1.255 的所有IP。 这里用普通掩码 255.255.255.0 是无法实现这种“匹配”逻辑的。 场景2：匹配一个特定主机 你想拒绝主机 192.168.1.10。 ACL语句： deny 192.168.1.10 0.0.0.0 解释： 反掩码全是 0，表示所有32位都必须精确匹配。这等同于 host 192.168.1.10 命令。 场景3：匹配不连续的IP（反掩码的超级优势） 假设你想匹配 192.168.1.1 和 192.168.1.3 这两个IP。用普通掩码无法定义一个包含这两个IP的连续网段。 ACL语句： permit 192.168.1.1 0.0.0.2 解释： IP地址： 192.168.1.1 (二进制最后8位: 000000**01**) 反掩码： 0.0.0.2 (二进制最后8位: 000000**10**) 匹配规则：前24位精确匹配，最后8位中，只有对应反掩码为 0 的位需要匹配。看最后一位： 第1位 (最低位)：反掩码是 0，必须匹配IP地址的 1。 第2位：反掩码是 1，不关心。 其他位都是 0，必须匹配IP地址的 0。 所以可能的组合是： ...00000001 (十进制 1) - 匹配 ...00000011 (十进制 3) - 匹配 这样就巧妙地匹配了两个不连续的IP。这是普通掩码绝对做不到的。 3. 为什么在OSPF宣告中使用反掩码？在OSPF中，使用 network 命令时，反掩码的作用是告诉路由器，哪些接口的IP地址应该被“宣告”到OSPF进程中。 场景： 你有一个路由器，接口1的IP是 10.1.1.1/24，接口2的IP是 172.16.1.1/24。你只想把 10.1.1.0/24 这个网段宣告到OSPF区域0。 OSPF配置： network 10.1.1.0 0.0.0.255 area 0 解释： 路由器会检查它所有接口的IP地址。 对于每个接口IP，用它和 network 命令中的 IP + 反掩码 进行运算。 如果 (接口IP) XOR (network命令中的IP) 然后 AND (反掩码) 的结果为 0，则该接口被激活OSPF。 简单理解就是：接口IP的前24位如果是 10.1.1，那么这个接口就会加入OSPF进程，并在区域0中宣告其连接的网段 10.1.1.0/24。 这里使用反掩码，同样是为了提供精确控制，让你可以灵活地选择将哪个精确的网段（甚至是不连续的网段）宣告到OSPF中，而不是只能宣告一个主类网络。 总结对比 特性 普通掩码（子网掩码） 反掩码（通配符掩码） 设计目的 定义一个IP地址的网络和主机部分。 匹配一个或多个IP地址。 逻辑 1 网络位， 0 主机位。 0 精确匹配， 1 不关心（任意）。 连续性 必须是连续的1和0。 可以是任意组合的0和1。 灵活性 较低，只能定义标准的、连续的IP网段。 极高，可以匹配单个主机、连续网段、甚至不连续的IP。 主要应用 IP地址规划、子网划分、路由器接口配置。 ACL、OSPFBGP的 network 命令、NAT等需要精确匹配的场景。 结论： 不是普通的掩码不能起作用，而是因为它“起作用”的方式（定义网络）与ACL和OSPF宣告所需要的“匹配”功能不匹配。反掩码凭借其“通配符”的特性，为网络匹配操作提供了无与伦比的灵活性和精确度，因此成为了这些场景下的标准选择。","tags":["网络工程师","计算机网络"]},{"title":"浅析路由的控制层面与转发层面","path":"/2025/10/19/浅析路由的控制层面与转发层面/","content":"一.关于控制层面和转发层面路由器的控制层面和转发层面。这个概念是现代路由器架构的基石，理解了它，就能理解路由器如何工作、如何进行故障排查以及SDN（软件定义网络）的革命性意义。 核心概念：一个形象的比喻为了更好地理解，我们可以把路由器比作一个城市的交通管理系统： 控制层面：相当于交通管理局。它负责制定全市的交通规则、绘制道路地图（路由表）、根据实时事故（网络拓扑变化）更新导航APP。它进行的是全局性的、智能的决策。 转发层面：相当于每个路口的交警或交通信号灯。他们不关心城市整体路况，只负责根据现有的交通规则和目的地指示牌，指挥每一辆到达路口的车（数据包）应该往哪个方向走。他们进行的是局部的、高速的、重复性的执行。 1. 控制层面控制层面是路由器的“大脑”，负责学习和生成路由信息，并最终构建出路由表。 主要功能： 运行路由协议： 与相邻的路由器通过OSPF、BGP、EIGRP等路由协议进行通信。 互相交换和学习网络拓扑信息（如链路状态、路径属性等）。 维护路由信息库： 将从各个路由协议学到的、以及直连路由、静态路由等所有路由信息存储在一个数据库中。 执行路由决策： 根据特定的算法（如SPF算法 for OSPF）或策略（如BGP路径属性），从RIB中选择出到达每个目标网络的最佳路径。 生成转发信息库： 将最终确定的最佳路径信息安装到路由表 中，这个表就是转发层面实际使用的“地图”。在高端路由器上，控制平面会将这个表优化后生成一个更适合硬件快速查找的表，即转发信息库，并下发给转发层面。 关键特点： 智能的、决策性的：它负责思考和计算。 基于CPU和软件：运行复杂的路由算法，消耗CPU和内存资源。 异步工作：路由更新和计算是事件驱动的（如链路updown），不是定时发生的。 全局视角：了解网络的整体拓扑结构。 2. 转发层面转发层面是路由器的“肌肉”，负责根据控制层面生成的FIB，对每一个到达的数据包执行转发操作。 主要功能： 数据包接收：在入接口接收数据链路层帧，解封装出IP数据包。 查找FIB：提取数据包中的目标IP地址，在FIB中进行最长前缀匹配查找，确定出接口和下一跳IP地址。 重写数据链路层头：根据ARP表或邻居发现协议，将下一跳IP地址解析为MAC地址，并重写数据帧的源目标MAC地址。 数据包发送：将重新封装好的数据帧从确定的出接口发送出去。 关键特点： 无状态的、执行性的：它不做决策，只执行命令。 基于专用硬件：为了达到线速转发，现代路由器使用ASIC、NPU 等专用芯片进行查找和转发，速度极快（纳秒级）。 同步工作：对每一个数据包都执行相同的、流水线式的操作。 局部视角：只关心当前数据包的目标地址和FIB中的对应条目，不关心网络全局。 两者关系总结 特性维度 控制层面 转发层面 功能 路由：学习和决策，生成“地图” 交换：查找和执行，按照“地图”行驶 处理对象 路由协议报文 用户数据包 工作频率 低频、异步 高频、同步（每个数据包） 性能关键 CPU、内存 吞吐量、延迟、丢包率 资源依赖 软件、通用处理器 专用硬件、ASICTCAM 视角 全局网络拓扑 单个数据包的目的地 关系流程：路由协议通信 - 控制层面计算最佳路径 - 更新路由表和FIB - 转发层面查询FIB - 转发数据包 故障排查中的应用理解这两个层面可以极大地帮助网络故障排查： 连通性故障：PC无法访问服务器。 检查控制层面：在沿途路由器上使用 show ip route server_ip 命令。如果路由表中没有相应的路由条目，问题出在控制层面（路由协议未学习到、静态路由缺失等）。 检查转发层面：如果路由表中有正确的路由条目，但数据包还是过不去，问题可能出在转发层面（ACL拦截、策略路由、硬件故障等）。 路径异常：数据包走了错误的路径。 这通常是控制层面的问题，因为路径选择是由控制层面决定的（如BGP策略配置错误、OSPF成本值设置不当）。 与SDN的关联软件定义网络（SDN）的核心思想正是将控制层面与转发层面彻底分离。 传统网络：每个路由器都集成了自己的控制层面和转发层面，是分布式的大脑。 SDN网络： 控制层面被集中到一个独立的、逻辑上的SDN控制器中。控制器拥有全网视图，并向所有交换机下发流表。 转发层面保留在交换机上（称为数据平面），但变得非常“笨”，它只负责根据控制器下发的流表 来转发数据包。 这种分离带来了网络的集中管理、灵活编程和自动化等巨大优势。 结论控制层面决定“去哪走”，转发层面负责“怎么走”。这两个层面各司其职，一个负责全局的、智能的路径计算，一个负责局部的、高速的数据包转发，共同构成了路由器高效、可靠工作的基础。理解它们的区别和联系，是掌握路由技术和现代网络架构的关键。 二.ACL与IP前缀列表中的应用理念那么，在ACL和IP前缀列表两大应用中，ACL可以用于数据过滤和网段匹配，IP前缀列表只可用于网段匹配。这两个哪些对应控制层面，哪些对应转发层面？ 我们首先需要理解ACL（访问控制列表）和IP前缀列表在网络设备中的常见应用场景。 ACL：通常用于过滤数据包，可以基于源目标IP、协议、端口等。它既可以用在控制层面过滤路由信息（如过滤路由更新），也可以用在前向转发层面过滤数据包。 IP前缀列表：通常用于匹配IP网段（即路由前缀），一般用于控制层面，例如在路由策略中匹配特定的路由前缀，从而进行路由的过滤或属性修改。 现在，问题问的是这两个工具分别对应控制层面和转发层面。注意，ACL可以用于两个层面，而IP前缀列表只用于控制层面。 具体来说： 在控制层面，ACL可以用于过滤路由更新（例如，在OSPF或BGP中，使用ACL来匹配路由前缀，从而决定接受或拒绝某些路由）。但ACL在控制层面的使用不如IP前缀列表灵活，因为ACL不能直接匹配前缀长度（掩码），而IP前缀列表可以同时匹配前缀和掩码长度。 在转发层面，ACL用于过滤数据包（例如，在接口上应用ACL来允许或拒绝数据包通过）。IP前缀列表一般不用于转发层面，因为它设计的目的就是为路由策略服务的。 因此，我们可以总结： ACL：既可用于控制层面（路由过滤），也可用于转发层面（数据包过滤）。 IP前缀列表：仅用于控制层面（路由过滤）。 所以，回答这个问题： 对应控制层面的有：ACL（部分功能）和IP前缀列表。 对应转发层面的有：ACL（部分功能）。 但是，问题表述是“这两个那些对应控制层面，那些对应转发层面”，所以我们分别说明： ACL：在控制层面和转发层面都有应用。 IP前缀列表：只用于控制层面。 注意：在具体设备上，ACL和IP前缀列表的应用可能略有不同，但这是通用概念。 三.各种路由协议的详细体现另一个问题，各种路由协议（RIP，IS-IS，OSPF，BGP等）体现的是路由的控制层面还是转发层面？ 先说结论：所有路由协议（RIP，IS-IS，OSPF，BGP等）本身都属于控制层面。 它们是控制层面最核心、最活跃的组成部分，是路由器“大脑”中进行思考和交流的部分。 详细分析我们可以把控制层面想象成一个公司的“战略决策部门”，而不同的路由协议就像是部门内部不同的沟通和决策机制。 为什么它们属于控制层面？ 处理的对象是路由信息，而非数据包： 路由协议之间互相发送和接收的是路由更新报文（例如OSPF的LSA、BGP的Update消息）。这些报文的内容是“我已知哪些网络，路径成本是多少”等信息。 它们不处理用户的真实数据流量（如你浏览的网页、下载的文件）。用户数据是由转发层面处理的。 核心功能是构建和更新路由表： 所有路由协议的最终目的，都是通过各自的算法（如RIP的跳数、OSPF的SPF算法、BGP的路径属性比较），计算出到达所有已知目标网络的最佳路径。 计算出的最优路径最终会被安装到路由器的路由表中。这个路由表就是控制层面输出给转发层面的“最终指令集”。 工作方式是异步和事件驱动的： 它们通常在后台运行，定期发送keepalive消息，或者在网络拓扑发生变化时（如链路故障）触发更新。这不是对每个数据包都进行的操作。 不同路由协议在控制层面的特点尽管都属于控制层面，但它们在控制层面内部扮演的角色和运作方式有所不同： 路由协议 在控制层面中的角色与特点 控制层面交互方式 RIP 一种简单的“距离矢量”协议。路由器之间互相告知“我到某网的距离是X跳”。 周期性地向邻居广播整个路由表。 OSPF 一种复杂的“链路状态”协议。路由器之间同步整个区域的网络拓扑地图，然后各自独立计算最短路径。 通过组播发送链路状态通告，只在拓扑变化时进行增量更新。 IS-IS 另一种“链路状态”协议，在机制上与OSPF类似，但源于OSI模型，通常用于大型运营商网络。 与OSPF类似，使用LSP进行链路状态信息的同步。 BGP 一种“路径矢量”协议，用于在不同自治系统之间交换路由信息。其决策基于丰富的策略和路径属性。 通过可靠的TCP会话与对等体建立连接，进行增量更新。 与控制层面和转发层面的关系 控制层面：路由协议作为核心引擎，通过互相通信，生成路由表（RIB），并最终生成转发信息库（FIB）。 转发层面：不运行任何路由协议。它只做一件事：当数据包到达时，查询控制层面下发的FIB，然后执行转发动作。 总结 路由协议是控制层面的核心引擎：没有它们，控制层面就无法自动学习路由，路由器就只能依靠手工配置的静态路由来工作。 它们为转发层面提供“导航地图”：路由协议辛勤工作的最终产物，就是一张详尽且最优的“路径地图”（FIB），转发层面则依赖这张地图来高效地转发每一个数据包。 所以，当您在想RIP、IS-IS、OSPF、BGP时，您应该立即联想到它们是在控制层面负责“路由决策”的智能协议。而IP转发、ACL过滤等操作，则是在转发层面负责“数据包搬运”的执行过程。 四.静态路由与默认路由的体现静态路由和默认路由也同样属于控制层面。 它们同样是控制层面用于“决策”和“生成路由表”的一种方式，只不过其“智能”的来源不同。 详细分析让我们回到那个“交通管理系统”的比喻： 动态路由协议（OSPFBGP等）：像是一个实时的交通信息网络。每个路由器（交通节点）自动与邻居交换路况信息，共同计算并实时更新出最优路径。这是分布式、自动的智能。 静态路由：则像是交通管理员手动绘制在地图上的固定路线。管理员明确指定：“要去往目的地A，必须从X路口出去。” 路由器无需与其他路由器通信，直接听从这条指令。 默认路由：是一种特殊的静态路由，它像是指向“主干道”或“高速公路”的通用指示牌，上面写着：“所有没有明确指示目的地的车辆，请全部驶入此路。” 它是一个捕获所有未知流量的最后手段。 为什么它们属于控制层面？ 它们直接影响路由表（RIB）的生成： 当您在路由器上输入 ip route 192.168.2.0 255.255.255.0 10.1.1.1 这条静态路由命令后，这条路径信息会直接被安装到路由表中。 控制层面的核心任务就是“构建路由表”。无论是通过动态协议学来的，还是通过手工配置输入的，都是路由条目的来源。 它们是转发层面的“指令”来源： 控制层面将静态路由和默认路由加入到路由表后，同样会将其最优路径下发到转发信息库（FIB） 中。 转发层面在转发数据包时，并不会区分这条路由是来自OSPF还是静态配置。它只是盲目地查询FIB并执行转发。 例如：一个去往 192.168.2.10 的数据包到达路由器，转发层面在FIB中查找到匹配的静态路由条目，然后就会从指定接口转发给下一跳 10.1.1.1。 它们参与控制层面的决策过程： 路由器可能会从多个来源学到通往同一目的地的路由（如同时从OSPF和静态路由学到）。这时，控制层面会根据管理距离 这个值来决策哪个来源更可信，并将最可信的路由安装到路由表中。 静态路由通常拥有一个很小的管理距离（例如1或更小），这意味着它比大多数动态路由协议（如OSPF的管理距离是110）更受信任。 对比总结 特性 动态路由协议 (OSPFBGP等) 静态路由 默认路由 本质 自动、分布式智能 手动、集中式智能 控制层面工作 与邻居通信、运行算法、计算路径 网络管理员直接输入路径信息 路由信息来源 其他路由器 本机配置（config） 开销与灵活性 占用CPU、内存资源；灵活，能自动适应拓扑变化 无运行时开销；不灵活，拓扑变化需手动修改 在控制层面的角色 自动路由发现与计算 手动路由注入 结论您可以这样理解控制层面的构成： 控制层面 动态路由协议（负责自动学习） + 静态默认路由（负责手动指定） + 其他来源（如直连路由） 它们共同协作，有时也相互竞争（通过管理距离），最终汇集成一张完整的“网络地图”——路由表。这张地图随后被交给转发层面去执行。 所以，无论是动态路由协议还是静态路由，它们都是控制层面用于回答“数据包应该往哪去？”这个核心问题的方法。它们的区别在于获取答案的方式是自动还是手动，而它们所属的逻辑层面是完全一致的。","tags":["网络工程师","计算机网络"]},{"title":"浅析静态路由与直连路由","path":"/2025/10/16/浅析静态路由与直连路由/","content":"一.关于直连路由 路由器访问直连网段时使用直连路由。直连路由的接口配置了IP地址并且处于up状态，直连路由会自动产生，不需要任何配置。 二.静态路由 静态路由一般用于小型网络规模，不能根据网络的变更进行动态路由学习。配置形式一般为：目标网段 目标网段掩码 下一跳地址（本地出接口） 三.缺省路由 缺省路由是静态路由的一种特殊形态，一般用在内网三层设备需要访问互联网。配置形式一般为：0.0.0.0 0.0.0.0 下一跳地址（本地出接口） 多说一句，个人其实一般习惯把缺省路由叫做默认路由，以便于理解。 关于“缺省”这个专有名词的翻译，之前还特意和AI讨论过这方面问题，关于“缺省”是否可以同义替换为“默认”这个词。以下是AI对此的分析： ### 一、为什么是“缺省”？—— 词源探秘“缺省”是一个典型的**意译词**，它翻译自英文术语 **“Default”**。要理解这个古怪的翻译，我们需要拆解一下“Default”在英文中的核心含义：- **De-**： 一个前缀，有“否定”、“离开”、“向下”的意思。- **-fault**： 来自拉丁语 *fallere*，意思是“欺骗、失败、辜负期望”。（和“fault”错误同源）所以，“Default”的本质是：**“由于（用户）未能做出（某个选择或提供某个信息），而由系统自动采用的一个预先设定好的（退而求其次的）选项或行为。”**中文译者当年在翻译时，抓住了这个“未能”和“缺失”的核心，将其拆解为：- **缺**： 缺失、缺乏、缺少。对应“未能提供”。- **省**： 省略、省去。对应“（用户）省略了操作”或“（系统）省去了判断”。因此，“缺省”直译过来就是 **“因缺失而省略”** 或 **“在用户缺位/未指定时，系统省去询问环节而采用的方案”** 。虽然逻辑上能自洽，但确实非常拗口，不符合日常语言习惯。相比之下，“默认”（默默地承认/认定）这个词就形象和自然得多。**结论：** 在绝大多数情况下，**“缺省” = “默认”**。你可以放心地在脑海里进行替换。------### 二、除了“缺省路由”，还有哪些地方会用到“缺省”？“缺省”这个概念在计算机科学中无处不在，只要有一个地方需要预设一个“保底”的、或“当用户不指定时”就启用的值或行为，就会用到它。以下是一些常见的例子：#### 1. 缺省路由这你已经提到了。它是路由表中的最后一条“保底”规则，当所有其他路由规则都不匹配目标IP地址时，数据包就会被发送到缺省路由所指向的**下一跳地址**（通常是网关路由器）。可以理解为“不知道去哪的数据包都往这儿送”。#### 2. 缺省网关这个概念和缺省路由紧密相关。**缺省网关**就是一个设备的**缺省路由所指的那个IP地址**。在你的电脑上，网络设置里填写的“默认网关”就是你这台电脑的缺省网关。你的电脑要访问互联网，所有非本地的流量都会先发给这个网关。#### 3. 缺省值这是最广泛的应用。指在用户没有显式提供值时，程序或系统自动使用的那个预设值。- **编程中**： 函数参数可以设置缺省值。例如 `function greet(name = Guest)`，如果你调用 `greet()` 不传参数，`name` 的缺省值就是 `Guest`。- **数据库中**： 可以为表的字段设置缺省值。例如一个 `users` 表的 `create_date` 字段，可以设置缺省值为 `CURRENT_TIMESTAMP`，这样当插入新数据没指定时间时，数据库会自动填入当前时间。- **软件设置中**： 软件的“恢复默认设置”功能，就是将所有配置重置为出厂时的**缺省值**。#### 4. 缺省配置 / 配置文件许多软件在启动时会加载一个 `default.conf` 或 `config.default.yml` 之类的**缺省配置文件**。如果用户没有创建自己的配置文件，或者自己的配置里缺少某些选项，系统就会使用这些缺省配置中的值。#### 5. 缺省构造函数在面向对象编程（如C++、Java、C#）中，指一个不需要提供任何参数的构造函数。当程序员没有为类编写任何构造函数时，编译器会自动生成一个缺省构造函数。#### 6. 缺省参数在函数调用或API请求中，如果某些参数是可选的，当调用者省略它们时，这些参数就会使用预先定义好的**缺省参数**。#### 7. 法律和金融领域的延伸甚至在计算机领域之外，“default”这个词也广泛使用，并同样被（生硬地）翻译为“缺省”。- **缺省判决**： 法律术语。指在庭审中，一方（通常是被告）未能出庭或未能答辩，法官据此作出的对其不利的判决。- **债务缺省**： 金融术语。指债务人未能履行偿还债务的合同义务，即“违约”。（这里的“缺省”和“违约”是同一个英文词“Default”）。### 总结与建议1. **直接理解**： 今后在任何计算机文献中看到“缺省”，请毫不犹豫地在心里将其替换为“默认”。你的理解是完全正确的。2. **知其所以然**： 了解“缺省”来自“Default”，并且其本意是“因用户缺失/省略操作而由系统采用的方案”，这能帮助你更深刻地理解这个概念，而不仅仅是死记硬背一个词。3. **沟通时灵活运用**： 在书面文档或正式场合，使用“缺省”是规范且专业的。但在日常口头交流中，说“默认路由”、“默认网关”所有人都能听懂，且更自然。这类似于很多人会把“URI”直接说成“网址”，虽然不精确但沟通效率高。","tags":["网络工程师","计算机网络"]},{"title":"Hello World","path":"/2025/10/16/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new My New Post More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment"},{"title":"[IS-IS]IS-IS路由协议基本概念","path":"/2025/10/13/IS-IS-IS-IS路由协议基本概念/","content":"IS-IS链路状态路由协议，采用Dijkstra（迪杰斯特拉）算法，路由优先级15。 IS-IS的地址结构由IDP（初始域）和DSP（域指定）组成，但是通常直接使用NET地址作为协议地址（NET地址包括区域ID、系统ID、固定字段）。 IS-IS使用cost作为路由度量， 一条IS-IS路径的cost等于本路由器到达目标网段。沿途的所有路由传递方向入接口的cost总和，cost值越小，路径越优。与OSPF不同的是，IS-IS接口的cost在缺省情况下并不与接口带宽相关（在实际部署时，IS-IS也支持根据带宽调整cost值），无论接口带宽多大，缺省时cost为10。 支持路由过滤，路由聚合，修改cost，默认路由下发，路由认证等路由优化功能。","tags":["网络工程师","计算机网络","路由协议","IS-IS"]},{"title":"[RIP]RIP路由协议基本概念","path":"/2025/10/13/RIP-RIP路由协议基本概念/","content":"RIP距离矢量路由协议，使用的路由算法是Bellman-Ford（贝尔曼-福特），以经过三层节点个数（跳数）为衡量路径最优的标准，经过节点最多不能超过15跳，16跳为目标不可达。 路由采用周期更新机制。 报文封装在传输层，基于UDP的520端口发送消息。 每个路由器只会学到邻居路由器的信息，不知道整个网络的拓扑结构。每次路由更新最多承载25条路由。 支持路由过滤，路由聚合（RIPv1不支持），修改跳数值，默认路由下发，路由认证等路由优化功能。","tags":["网络工程师","计算机网络","路由协议","RIP"]},{"title":"[OSPF]一篇文章讲清楚OSPF路由协议的七步邻接关系建立步骤","path":"/2025/10/11/OSPF-一篇文章讲清楚OSPF路由协议的七步邻接关系建立步骤/","content":"整个建立过程可以划分为以下几个关键状态，其流程如下图所示： flowchart TD A[Down状态br初始状态] -- B[Init状态br收到Hello包] B -- C[2-Way状态br在Hello包中看到自己的RID] C -- D[ExStart状态br主从协商] D -- E[Exchange状态br交换DBD摘要] E -- F[Loading状态br请求并加载LSA] F -- G[Full状态br完全邻接] 现在，我们来详细解释每一个状态： Down (失效状态) 描述: 这是邻接关系的初始状态。表示没有从邻居收到任何信息（Hello包）。 动作: 本地路由器会周期性地向外发送Hello包，尝试发现邻居。 Init (初始状态) 描述: 本地路由器收到了对端发来的Hello包，但Hello包中没有包含自己的Router ID (RID)。这意味着对方还没有收到我的Hello包，或者我的参数不符合它的要求。 动作: 继续交互Hello包。 2-Way (双向通信状态) 描述: 这是建立邻接关系的关键前提。本地路由器在收到的Hello包中，看到了自己的Router ID。这表明双向通信已经建立。 决策点: 在广播多路访问网络（如以太网） 中，DR（指定路由器）和BDR（备份指定路由器）将在此状态后与其他路由器继续建立邻接（FULL），而非DRBDR路由器之间会停留在此状态。 在点对点网络中，所有邻居都会继续向下一个状态发展。 ExStart (预启动状态) 描述: 这是邻接关系（而不仅仅是邻居关系）的真正开始。双方使用空的DBD（数据库描述）包来协商主从关系。 目的: 确定在接下来的数据交换过程中，由谁作为“主”设备来控制交换过程。RID更大的一方将成为主设备。 Exchange (交换状态) 描述: 主从关系协商完毕后，双方进入此状态。开始互相发送包含LSDB（链路状态数据库）摘要信息的DBD包。 目的: 通过交换“目录”，互相了解对方有哪些LSA（链路状态通告）是自己没有的。 Loading (加载状态) 描述: 在收到对端的DBD后，本地路由器会将自身的LSDB与收到的摘要进行对比。 动作: 如果发现自己缺少某条LSA，就会向对方发送LSR（链路状态请求）。 对方会回复LSU（链路状态更新） 来传递完整的LSA信息。 本地路由器收到LSU后，会发送LSAck（链路状态确认） 进行确认。 图中的 LSR, LSU, LSAck 报文就是在此状态交互的。 Full (完全邻接状态) 描述: 这是邻接关系建立的最终稳定状态。此时，双方路由器的LSDB已经完全同步。 意义: 达到此状态后，路由器才能基于完全同步的LSDB，使用SPF算法独立计算出一致且无环的路由表。 示意图中报文类型说明 Hello: 用于发现和维持邻居关系。 DD (Database Description Packet): 用于描述自己的LSDB摘要，在ExStart和Exchange状态交换。 LSR (Link State Request Packet): 用于请求完整的LSA。 LSU (Link State Update Packet): 用于发送完整的LSA。 LSAck (Link State Acknowledgment Packet): 用于确认收到LSU。 总结OSPF邻接关系的建立是一个严谨的“状态机”过程，从Down到Full，每一步都有特定的任务和报文交互。你的示意图完美地展示了这个完整的生命周期。","tags":["网络工程师","计算机网络","路由协议","OSPF"]},{"title":"[OSPF]OSPF路由协议基本概念","path":"/2025/10/11/OSPF-OSPF路由协议基本概念/","content":"OSPF链路状态路由协议，采用DIjkstra算法，协议本身不存在环路。报文封装在IP层，协议号89，使用组播224.0.0.5和224.0.0.6建立连接。","tags":["网络工程师","计算机网络","路由协议","OSPF"]},{"title":"[BGP]深入讨论BGP预防环路机制(3) BGP联盟","path":"/2025/10/04/BGP-深入讨论BGP预防环路机制-3-BGP联盟/","content":"好的，这是一个非常核心的BGP进阶概念。我们来详细拆解一下这句话：“BGP通过AS内部使用联盟，以此防止环路”。 为了理解它，我们需要分三步走： BGP的防环路基础机制 在单个AS内部（iBGP）遇到的问题 联盟如何解决这个问题并防止环路 1. BGP的防环路基础机制：AS_PATHBGP是一种“路径矢量”路由协议，它防环路的核心机制是 AS_PATH 属性。 工作原理：当BGP路由器向外部的AS通告一条路由时，会把自己的AS号 添加到AS_PATH列表的最前面。 环路检测：当一台BGP路由器收到一条路由更新时，它会检查AS_PATH列表。如果在这个列表中发现了自己的AS号，它就认为这条路由产生了环路，从而丢弃该路由。 举个例子：假设AS 100 - AS 200 - AS 300。当路由从AS 100传到AS 200时，AS_PATH是 100。当AS 200再传给AS 300时，AS_PATH变成 200 100。如果AS 300试图把这条路由再传回给AS 200，AS 200会在AS_PATH 300 200 100 中看到自己的AS号 200，于是它会拒绝接受这条路由，防止了环路。 2. 在单个AS内部（iBGP）遇到的问题在一个AS内部，路由器之间使用iBGP 来交换BGP路由信息。iBGP有一个非常重要的规则，叫做： “从一台iBGP对等体学到的路由，永远不会传递给另一台iBGP对等体。” 这被称为 BGP Split-Horizon。 为什么要有这个规则？因为在AS内部，没有AS号被添加到AS_PATH中！回想一下防环路机制，它是基于AS_PATH来检测的。如果在同一个AS内，路由器之间互相传递路由，AS_PATH不会改变，BGP就无法通过AS_PATH来检测环路。为了防止在AS内部产生路由环路，所以干脆定下这个“死规矩”：iBGP邻居之间传一次就够了，不许二次传播。 这个规则带来的问题：为了保证AS内所有BGP路由器都能学到完整的路由信息，所有运行iBGP的路由器之间必须形成全互联的邻居关系。这在一个大型AS中会带来巨大的管理和性能开销（比如有N台路由器，就需要建立 N*(N-1)2 个iBGP会话）。 3. 联盟如何解决这个问题并防止环路联盟（BGP Confederations） 就是为了解决上述“iBGP全互联”问题而设计的一种方法。 它的核心思想是： “化整为零”。把一个大的AS（我们称之为联盟AS）划分成多个小的、更容易管理的AS（我们称之为子AS 或 成员AS）。 具体做法： 划分：将原来的大AS 65000，划分为几个子AS，例如 AS 65001, AS 65002, AS 65003。 对外表现：对于联盟外部的BGP对等体来说，整个联盟仍然被看作一个单一的AS 65000。它们完全不知道内部被划分了。 内部运行：在联盟内部，这些子AS之间使用一种特殊的eBGP 来交换路由信息。注意，它不是标准的eBGP，而是经过修改的，我们称之为 ** Confederation eBGP**。 联盟如何防止环路？这里就是最关键的部分了。联盟通过引入两个概念来防止环路： a) AS_CONFED_SEQUENCE 这是一个类似于AS_PATH的BGP路径属性，但它只在联盟内部使用。 当路由在一个子AS（如AS 65001）内传播时，AS_PATH不会改变。 但当路由从一个子AS（AS 65001）传到另一个子AS（AS 65002）时，发出路由的子AS号（65001）会被添加到 AS_CONFED_SEQUENCE 这个属性中。 b) 联盟内部的环路检测在联盟内部，路由器会同时检查 AS_PATH 和 AS_CONFED_SEQUENCE。 如果在一台属于AS 65002的路由器收到的路由更新中，在 AS_CONFED_SEQUENCE 里看到了自己的子AS号 65002，它就会认为这条路由在联盟内部产生了环路，从而将其丢弃。 这样一来，联盟就在大的AS内部，重新创建了一个类似于外部AS之间的防环路机制。 工作流程与好处 流程： 子AS内部：使用iBGP，遵循iBGP的规则。 子AS之间：使用 Confederation eBGP。它允许像标准eBGP一样传递路由，从而打破了iBGP全互联的要求。你只需要在每个子AS的边界路由器之间建立eBGP对等体关系即可。 好处： 解决了全互联问题：大大减少了需要建立的iBGP会话数量。 防止了AS内部环路：通过AS_CONFED_SEQUENCE属性，在联盟内部实现了可靠的环路检测。 策略灵活性：可以在子AS之间应用类似于eBGP的路由策略，提供了更精细的控制。 总结 根本问题：iBGP因为AS_PATH在AS内不变，无法防环路，所以只能用“全互联”这个笨办法来规避环路，但这在大型网络中不可行。 联盟的解决方案：将大AS“伪装”成多个小AS的联合体。 防环路机制：在内部的小AS（子AS）之间通信时，使用一个新的、只在联盟内部有效的路径属性 AS_CONFED_SEQUENCE 来记录路径。路由器通过检查这个属性来判断是否在联盟内部形成了环路。 一个简单的比喻：把一个有1000人的大公司（大AS）重组，分成10个部门（子AS）。 以前：为了保证信息一致，要求这1000人两两之间都要直接沟通（全互联），这根本做不到。 现在：部门内部（iBGP）自由沟通。部门之间（Confed eBGP）只派代表（边界路由器）沟通，并且每次跨部门传递消息时，都会在内部备忘录（AS_CONFED_SEQUENCE）上盖章，如果一份文件转了一圈又回到本部门，一看备忘录就知道是循环了，直接扔掉。而对于公司外部的人来说，他们仍然只认为这是一个公司（联盟AS）。 那是不是可以说，BGP联盟仅适用于IBGP，而在EBGP上不可行？ 这是一个非常好的问题，它触及了BGP联盟设计的核心。 首先给出结论：这个说法完全正确，并且非常精准。我们可以这样来理解： BGP联盟本质上是一种用于“优化和改造大型AS内部iBGP网络”的技术。它不是为了在eBGP上使用，而是为了解决纯iBGP环境下的问题而诞生的。 下面我来详细解释为什么： 1. 根本目的：解决iBGP的难题正如我们之前讨论的，iBGP有两大核心问题： 防环路机制缺失：在AS内部传递时，AS_PATH不变，无法用AS_PATH防环。 全互联要求：导致管理复杂度和资源消耗巨大。 联盟就是为了直接解决这两个iBGP特有的问题而设计的。 如果一个AS很小，根本不需要iBGP全互联，那么联盟也就没有存在的必要。 2. 实现方式：在AS内部“模拟”eBGP联盟的实现手法非常巧妙：它在一个真实的AS内部，创建了多个逻辑上的“子AS”，然后在它们之间运行一种特殊的、经过修改的eBGP。 这里的关键点是： 对“外”：对于联盟之外的、真正的eBGP对等体来说，它们看到的仍然是一个单一的、完整的AS号。它们完全不知道这个AS内部被划分成了多个子AS。在与外部通信时，联盟AS的行为和一个普通AS没有任何区别。 对“内”：在联盟内部，子AS之间的行为类似于eBGP（比如可以正常传递路由，而不需要全互联），但又不是标准的eBGP（比如下一跳属性、LOCAL_PREF等属性在子AS间依然保持，不像标准eBGP那样默认重置）。 所以，联盟技术是将eBGP的某些机制“内化”为了一个解决iBGP问题的工具。 3. 为什么说它“在eBGP上不可行”？这个说法可以从两个层面理解： a) 从设计初衷和应用场景来看：联盟的设计目标就不是为了用于两个真正独立的、不同所属的AS 之间的eBGP连接。比如，你不可能告诉你的运营商：“我们在我们两个AS之间的eBGP链路上启用联盟吧。” 这是没有意义的，因为eBGP本身已经通过AS_PATH完美地解决了环路问题，并且不需要全互联。 b) 从技术细节来看：如果试图在两个真正的eBGP对等体之间使用联盟，会遇到根本性的矛盾： AS号表示：联盟使用的子AS号通常属于私有AS号范围（64512-65534）。在真正的eBGP会话中，这些私有AS号是不应该被通告给对方的。 路径属性：联盟内部使用的AS_CONFED_SEQUENCE路径属性，在传递给真正的eBGP对等体之前必须被移除。如果将它泄露给外部AS，会导致路由问题，因为外部AS无法理解这个属性。 失去意义：eBGP本身工作得很好，引入联盟机制不会带来任何好处，反而会破坏标准的防环路和工作机制。 总结与类比让我们用一个比喻来巩固理解： 一个大型公司 一个大的AS（例如AS 65000） 公司内部的部门（如市场部、技术部） 子AS（AS 65001， AS 65002） 公司与外部公司沟通 eBGP 公司内部的全员大会 iBGP全互联（效率低下） 联盟 公司重组，设立部门经理。部门内部自由沟通（子AS内的iBGP），部门经理之间开会沟通（子AS间的Confederation eBGP）。对外，公司仍然是一个整体。 结论： BGP联盟是一种专门为解决大型iBGP网络中的全互联和防环路问题而设计的技术。它通过在一个真实的AS内部引入类似eBGP的逻辑关系来实现这一目标，但它本身并不应用于两个独立AS之间的eBGP会话。 它是“用于iBGP的eBGP-like机制”，而不是“用于eBGP的技术”。 最后，让我们再对IBGP中的全互联，反射路由器RR，以及BGP联盟三大预防环路机制进行详细对比。 对比总览 特性维度 全互联 路由反射器 联盟 核心思想 最直接的方法，遵守基础规则 打破“不传递”规则：指定特定路由器（RR）来反射路由 化整为零：将大AS划分为小AS，内部使用“特殊eBGP” 扩展性 极差会话数呈O(N²)增长 优秀会话数呈O(N)线性增长 良好减少了全互联范围，但比RR稍复杂 配置与管理复杂度 低（概念简单）高（实际维护会话多） 中等需要精心设计RR和客户机的拓扑 高需要规划子AS，配置边界路由器 防环机制 BGP Split-Horizon（从iBGP学到的路由不传给其他iBGP对等体） Cluster_List 和 Originator_ID 属性 AS_CONFED_SEQUENCE 属性 路径可见性 AS_PATH保持原始状态，清晰明了 AS_PATH保持原始状态 对外隐藏内部子AS结构，AS_PATH中只显示联盟AS号 策略控制的灵活性 策略在所有路由器上对等应用 集中化策略可在RR上应用策略，影响其所有客户机 分布式策略可在子AS边界应用类似eBGP的策略，更精细 网络稳定性与故障域 无单点故障一个会话断开不影响其他会话 有单点故障风险一个RR故障会影响其所有客户机（可通过冗余缓解） 故障域隔离一个子AS的问题更容易被隔离在内部 迁移难度 NA（基准） 相对容易可以逐步部署，将部分路由器设为RR的客户机 相对困难通常需要规划停机时间，重新划分AS并配置边界 深入分析各自特点1. 全互联 优点： 简单可靠：概念上最简单，符合BGP最基础的设计。 无单点故障：没有中心节点，任何一个iBGP会话的中断只会影响直接相连的两个路由器。 缺点： 无法扩展：这是其致命弱点。当路由器数量超过几十台时，会话数量会变得难以管理，消耗大量内存和CPU资源。 适用场景： 小型网络或实验室环境。 作为衡量其他方案优劣的基准。 2. 路由反射器 优点： 极佳的扩展性：大幅减少了iBGP会话数量。是当前大型网络中最主流的解决方案。 易于部署和迁移：可以从现有全互联网络中逐步引入RR，无需大规模重构网络。 保持逻辑拓扑：整个AS在逻辑上仍然是一个统一的实体，对外部网络没有影响。 缺点： 可能引入单点故障：如果RR发生故障，其下所有客户机将无法学习到完整的BGP路由。解决方案是部署多个冗余的RR。 潜在的子最优路径：RR会向所有客户机反射最佳路径，但客户机到该路径的下一跳可能不是最优的，需要依赖IGP的收敛或开启“下一跳自我”功能。 配置复杂性：需要精心设计RR的层级（如分层RR）和Cluster，配置不当容易引起环路。 适用场景： 绝大多数中大型企业和服务提供商网络。是目前事实上的标准。 3. 联盟 优点： 天然的故障域隔离：将一个大的网络问题分解到多个子AS中，便于管理和故障排查。 策略灵活性强：在子AS边界，可以像使用eBGP一样应用丰富的路由策略（如MED、AS_PATH预挂等），提供了比RR更精细的控制粒度。 无单点故障：类似于全互联，在子AS内部是全互联或RR，但子AS之间是网状连接，没有中心化的反射器。 缺点： 配置和管理最复杂：需要规划子AS的划分、分配私有AS号，并配置所有子AS边界路由器。 迁移困难：从现有网络迁移到联盟架构通常需要详细的计划和可能的业务中断。 调试复杂度增加：在排查问题时，需要同时关注AS_PATH和AS_CONFED_SEQUENCE。 适用场景： 规模极其庞大、结构复杂且由多个独立管理区域组成的网络（例如超大型运营商、经历了多次合并的网络）。 对策略控制有极高要求的特殊场景。 组合使用在实际网络中，这三种方案并非互斥，经常被组合使用以发挥最大效益。 最常见的组合是：路由反射器 + 联盟 在一个超大型的联盟AS内，每个子AS的内部可能仍然很大。 此时，可以在每个子AS内部使用路由反射器来进一步减少iBGP会话数量。 这样既获得了联盟的故障隔离和策略灵活性，又享受了RR在子AS内部的扩展性优势。 总结 全互联是“教科书式”的基准，但不可用于生产大型网络。 路由反射器是当今的“主流选择”，在扩展性和易用性之间取得了最佳平衡。 联盟是“高级武器”，提供了最强的控制力和隔离性，但代价是极高的复杂性。 选择哪种方案取决于您的网络规模、增长预期、运维团队的技术能力和对网络控制力的具体要求。对于绝大多数网络而言，路由反射器都是首选方案。","tags":["网络工程师","计算机网络","BGP","路由协议"]},{"title":"[BGP]深入讨论BGP预防环路机制(2) EBGP","path":"/2025/10/04/BGP-深入讨论BGP预防环路机制-2-EBGP/","content":"当一台BGP路由器将一条路由通告给一个EBGP对等体是，它必须把自己的AS好添加到该路由AS_Path列表最前面。 BGP路由器在收到一条路由时，会检查其AS_Path属性：若在该列表中发现自己的AS号，则说明这条路由到过本AS，将会形成环路。路由器会直接丢弃该路由。 接下来深入讨论一个问题：EBGP可以和IBGP一样搞水平分割吗？ 直接的回答是：可以，但EBGP防环机制的核心和主要手段并不是传统意义上的“水平分割”，而是其特有的AS_PATH路径属性。 下面我们来详细解释： 1. 传统“水平分割”与EBGP 传统水平分割：在像RIP这样的距离矢量协议中，水平分割的规则是：“从一个接口学到的路由，不会再从同一个接口发出去”。这有效地防止了相邻路由器之间的环路。 EBGP的情况：EBGP对等体之间通常只有一条直连的物理链路或TCP连接。从这个角度看，EBGP会话本身就隐含了“水平分割”的特性——它不会把从某个EBGP对等体学来的路由，再发回给同一个对等体。因为那样做没有意义，对方本来就是这条路由的源头或中转站。 所以，从这个狭义的角度说，EBGP在直连的对等体之间，确实有类似水平分割的行为。 2. EBGP防环的核心机制：AS_PATH属性然而，EBGP面对的网络环境远比两个直连路由器复杂。环路可能发生在多个AS之间，而不仅仅是两个直连路由器之间。这时，传统的“水平分割”就完全不够用了。 EBGP防环的基石是 AS_PATH 属性。 它的规则非常简单而有效：当一台BGP路由器将一条路由通告给一个EBGP对等体时，它必须把自己的AS号添加到该路由的AS_PATH列表的最前面。 BGP路由器在收到一条路由时，会检查其AS_PATH属性： 如果在该列表中发现了自己的AS号，说明这条路由曾经经过本AS，形成了环路。 路由器会直接丢弃这条路由，认为它无效。 举例说明：假设有这样一个路径：AS 100 - AS 200 - AS 300 AS 100将路由 10.0.0.0/8 通告给AS 200。此时AS_PATH为 [100]。 AS 200收到后，将路由通告给AS 300。在发送前，它把自己的AS号200加进去，AS_PATH变为 [200, 100]。 AS 300收到路由，AS_PATH是 [200, 100]。 现在，如果AS 300错误地试图将这条路由再发回给AS 200，它在发送前会添加自己的AS号，AS_PATH变为 [300, 200, 100]。 当AS 200收到这条路由时，它检查AS_PATH，发现其中包含自己的AS号 200。于是AS 200立刻判定这条路由形成了环路，并将其丢弃。 这个机制完美地解决了在不同自治系统之间可能出现的任何环路问题。 3. IBGP的防环与“水平分割”作为对比，我们可以看一下IBGP的情况，这能更好地理解“水平分割”的概念。 在同一个AS内部，IBGP对等体之间也会传递路由。为了防止在AS内部产生环路，IBGP使用了一条非常重要的规则，这条规则非常类似于“水平分割”： 从一个IBGP对等体学到的路由，不会传递给其他IBGP对等体。 这意味着，在AS内部，IBGP路由器之间必须建立全互联的邻居关系，或者使用路由反射器联盟来规避这个规则。这正是为了防止在缺乏像AS_PATH这样的跨AS防环机制的情况下，路由在AS内部无休止地传递。 总结 协议场景 主要防环机制 是否使用传统“水平分割” RIP 水平分割、毒性逆转、最大跳数 是，核心机制之一 EBGP AS_PATH属性 在直连对等体间有类似行为，但不是主要机制 IBGP IBGP水平分割规则（不从IBGP学到的路由传给另一个IBGP） 是，这是其核心防环规则，但特指IBGP邻居间 结论：EBGP可以通过其会话特性在直连对等体间实现类似水平分割的效果，但其真正强大和核心的防环机制是 AS_PATH属性。而“水平分割”这一概念在BGP协议中，更明确地体现在 IBGP的防环规则 上。 换种说法，EBGP因为常用于广域网，所以在这里建立全互联，进而建立水平分割并不现实。 这正是网络协议设计中的一个经典权衡：理论上的理想方案 vs. 现实中的工程可行性。 我们可以从以下几个角度来深入理解为什么在EBGP场景下“建立全互联”不现实，从而导致它必须依赖 AS_PATH 而不是“IBGP式”的水平分割： 1. 规模与可扩展性 IBGP在一个AS内：一个自治系统（AS）内的路由器数量是有限的，可能是几十台、几百台。建立全互联的IBGP会话（会话数量公式：n*(n-1)2）虽然也有挑战，但通过路由反射器等技术可以管理。 EBGP在互联网上：互联网由数万个AS构成。如果要求所有AS之间都建立全互联的EBGP会话，那将是一个天文数字，无论在配置复杂度、TCP连接数量还是路由表维护上，都是完全不可能实现的。互联网的架构本身就是基于层级和互联的，而不是一个扁平的全互联网络。 2. 管理与策略控制 商业关系：AS之间存在复杂的商业关系（如供应商、客户、对等体）。一个AS需要根据商业合同，精确地控制它将哪些路由通告给哪个邻居。如果建立全互联，这种精细化的策略控制将无法实现。AS_PATH 属性本身就是一个强大的策略工具，网络工程师可以根据AS路径长度、经过的AS等信息来决定优选哪条路径。 管理域：每个AS都是一个独立的管理域。让一个AS的管理员去和互联网上所有其他AS的管理员协调建立BGP会话，在组织和安全上都是不可行的。 3. 地理与拓扑 物理距离：一个AS可能位于北京，而它的对等体可能位于伦敦或纽约。它们之间的通信需要经过多个中间网络。从物理和逻辑拓扑上看，它们根本不是“直连”的，也就不存在一个单一的“接口”来应用传统的水平分割规则。AS_PATH 记录了整个路径，完美地适应了这种多跳、跨地域的复杂环境。 总结对比让我们把这两种场景并置，就能清晰地看到设计哲学的差异： 场景 IBGP - 在一个AS内部 EBGP - 在整个互联网上 范围 单一管理域，规模有限 全球范围，数万个独立管理域 连接性 追求模拟全互联（通过物理全互联或路由反射器） 必然是多跳、部分互联的网状结构 防环机制 IBGP水平分割规则（因为拓扑可以模拟成全互联） AS_PATH属性（因为拓扑是网状，无法全互联） 核心思想 “我不知道这条路有没有环，所以我干脆不把它传回给可能知道它的人。” （基于会话的过滤） “让我看看这条路的历史记录，如果上面有我自己的脚印，那我就绕回来了。” （基于路径记录的检验） 所以，可以做如下总结：正是因为EBGP应用于广域网这种规模巨大、无法全互联的环境，才催生了 AS_PATH 这种更聪明、更可扩展的防环机制，而放弃了依赖全互联拓扑的传统“水平分割”思想。 这是一个为了适应现实世界复杂度而进行的卓越工程设计。","tags":["网络工程师","计算机网络","BGP","路由协议"]},{"title":"[BGP]深入讨论BGP预防环路机制(1) IBGP","path":"/2025/10/04/BGP-深入讨论BGP预防环路机制-1-IBGP/","content":"在AS内部，BGP路由只能传递一步。也就是说，从一个IBGP对等体学习到的路由，绝不会被传递给另一个IBGP对等体。（也就是IBGP的水平分割理念） 为什么要有这个原则？这个原则的核心目的是在自治系统内部防止BGP路由环路。 缺乏天然的防环机制： 在AS之间（EBGP），BGP使用著名的 AS_PATH 属性来防环。当一台BGP路由器看到自己的AS号出现在接收到的路由的AS_PATH中时，它就知道这是一个环路，从而拒绝该路由。 然而，在AS内部（IBGP），路由在传递时不会改变AS_PATH 属性。因为路由器都在同一个AS内，AS_PATH不会被追加。因此，AS_PATH这个强大的防环工具在AS内部失效了。 需要一个替代的防环机制： 由于失去了AS_PATH这个“指路明灯”，BGP设计者必须引入一个新的规则来防止路由在AS内部无休止地循环。这个规则就是 “IBGP水平分割”。 它通过切断IBGP路由的二次传播来从根本上杜绝环路。如果一条路由只能被“原始”接收，而不能被“转述”，那么它自然就无法形成环路。 基于此，IBGP中诞生了全互联与RR路由反射器两大设计理念。 我们先对于全互联进行讨论： BGP全互联 是指在同一个自治系统内，所有运行BGP的路由器都彼此两两建立IBGP对等体关系。 全互联的目的： 确保任何一台IBGP路由器从外部（通过EBGP）学到的路由，都能通过直接的IBGP会话传递给AS内的所有其他BGP路由器，而不会违反防环规则。 总结起来就是： “路由只能传递一步”（IBGP水平分割）是BGP的【设计规则原则】。 “全互联”是为了满足这条规则并同时实现路由全域可达，而不得不采用的【工程实现方案拓扑要求】。 做一个通俗的理解： 规则： “一个秘密，你只能告诉直接听你说话的人，不能让你听来的人再去传话。” 结果： “如果你想让你所有的朋友都知道这个秘密，你就必须亲自对每一个朋友都说一遍。” 全互联带来的后果与解决方案： 直接后果：为了实现全网路由可达，IBGP路由器之间必须建立全互联的邻居关系。意味着全员路由器之间都必须建立IBGP会话。 解决方案：路由反射器（RR） 就是为了打破这一原则而出现的。RR被特许可以违反IBGP水平分割规则，将路由“反射”给其他客户端，从而解决了全互联带来的可扩展性问题。 一句话概括路由反射器（RR）： BGP路由反射器（RR）的核心任务是解决在AS内部（IBGP）全互联需求带来的管理和扩展性问题。它允许一个BGP路由器将从某个IBGP对等体学来的路由，“反射”给其他的IBGP对等体，从而避免了所有路由器之间必须两两建立IBGP连接。 详细解释要理解RR为什么存在，我们需要先看没有它的时候是怎样的。 1. 问题背景：IBGP的全互联规则在同一个自治系统内部，路由器之间运行的是IBGP。BGP设计了一个非常重要的防环机制：一个路由器从IBGP对等体学到的路由，绝不会再通告给另一个IBGP对等体。 这个规则带来的直接后果就是：为了确保所有IBGP路由器都能学到完整的路由信息，它们之间必须建立全互联的TCP连接关系。 举个例子：如果一个AS内有10台路由器运行BGP，那么需要建立的IBGP连接数量是 n*(n-1)/2 10*9/2 = 45 条。这已经非常难以管理和维护了。 如果路由器数量增加到100台呢？连接数会达到4950条！这在工程上是不可行的。 2. 解决方案：路由反射器（RR）路由反射器就是为了打破上面那个“绝不通告”的规则而生的。它被允许将从一个IBGP对等体学到的路由，反射（重新通告）给其他特定的IBGP对等体。 这样，网络拓扑就可以从全互联变成一个中心辐射型 模型： 路由反射器：作为中心节点，它与所有其他客户端路由器建立IBGP连接。 客户端：只与RR建立IBGP连接，客户端之间不需要建立连接。 非客户端：在同一个AS内，既不是RR也不是客户端的路由器。它们之间以及它们与RR之间仍然需要全互联。（这是一个高级细节，但在小型RR设计中，可以认为所有路由器都是客户端） 引入RR后的例子：同样是10台路由器，我们指定1台作为RR，其余9台作为它的客户端。那么只需要建立 9 条IBGP连接（从RR到每个客户端各一条）即可。 3. RR是如何工作的？（核心规则）RR在反射路由时，遵循一套特定的规则来防止环路： 从非客户端学来的路由，反射给所有客户端。 例如，RR从一台非客户端路由器学到一条路由，它会将这条路由反射给它所有的客户端。 从客户端学来的路由，反射给所有非客户端和所有其他客户端（除了该路由的来源客户端）。 这是最常用的场景。客户端A通告一条路由给RR，RR会将其反射给所有其他客户端（B、C、D…）以及所有非客户端。 从EBGP对等体学来的路由，通告给所有客户端和非客户端。 这和普通的BGP路由器行为一致。 4. RR的优势 极大的可扩展性：将IBGP连接数从 O(n²) 降低到 O(n)，使得大型AS的构建成为可能。 简化配置和管理：不需要在每台路由器上配置和维护大量的IBGP对等体关系。 网络结构更清晰：形成了逻辑清晰的中心辐射型架构。 5. 需要注意的地方 单点故障：单一的RR会成为一个单点故障。因此，在实际网络中，通常会部署多个RR（集群） 来实现冗余。常见的做法是，将一对路由器作为RR，并让它们互为客户端。 并非最佳路径计算者：RR只是路由信息的传递者（反射器），它本身不一定是数据转发的必经之路。数据转发仍然基于IGP计算出的最短路径。 集群内与集群间：在更复杂的网络中，一个AS内可以有多个RR集群，RR之间通过非客户端关系或联盟等方式交换路由。 总结BGP路由反射器（RR）是一个为了解决IBGP全互联可扩展性难题而设计的“规则例外”机制。它通过指定一个中心节点来中继（反射）BGP路由信息，从而大幅减少了AS内部所需的IBGP连接数量，是现代大规模数据中心和运营商网络不可或缺的组件。 简单来说，它就像一个“广播站”，AS内部的路由器（客户端）只需要连接到这个广播站，就能收到所有其他路由器的路由信息，而不需要彼此直接相连。 全互联 vs. 路由反射器：特点对比下面这个表格清晰地展示了两者的核心区别。 特性维度 全互联 路由反射器 核心概念 遵守BGP基础防环规则：不向IBGP对等体传递从另一个IBGP对等体学来的路由。 打破BGP基础防环规则：允许将IBGP路由有选择地“反射”给其他IBGP对等体。 网络拓扑 网状网：所有路由器间两两互联。 中心辐射型：客户端只与中心（RR）连接，客户端间无需直接连接。 连接数量 O(n²)，随设备数量增长呈指数级增长。公式：n*(n-1)/2 O(n)，随设备数量线性增长。（假设所有路由器都是客户端） 可扩展性 极差 极佳 配置与管理 非常复杂且繁琐。每增加一台新路由器，都需要在所有现有路由器上添加配置。 相对简单。主要在RR上进行配置，客户端只需指向RR。 冗余性与可靠性 高。任何单台设备故障，不影响其他设备间的路由交换。 依赖RR的可靠性。单台RR是单点故障。需通过部署RR集群（如两台RR互为客户端）来实现冗余。 故障排查 相对直接，因为路径是端到端的。 稍显复杂，需要理解反射规则，可能引入隐藏的路径问题。 适用场景 小型网络，或BGP路由器数量很少（例如少于10台）的环境。 中大型网络、数据中心、运营商网络等任何需要运行大量BGP路由器的场景。 深入理解：为什么RR能解决全互联问题？关键在于RR引入了一套新的防环属性，代替了原始的“不通告”规则。 Originator_ID： 当RR反射一条路由时，它会将始发这条路由的路由器ID添加到该路径属性中。 如果一台路由器收到了一条路由，发现其中的Originator_ID与自己相同，它就知道这条路由是自己最初产生的，于是丢弃它，防止环路。 Cluster_ID： 每个RR及其客户端构成一个“集群”。每个集群有一个Cluster_ID（通常就是RR的路由器ID）。 当RR反射一条路由时，它会将自己的Cluster_ID添加到Cluster_List中。 如果一台RR收到一条路由，发现其中的Cluster_List包含自己的Cluster_ID，它就知道这条路由已经经过本集群了，于是丢弃它，防止集群间的环路。 正是通过这些新属性，RR才能在打破原始规则的同时，依然保证网络无环。 总结与类比你可以这样理解： 全互联：像一个全员大会。任何消息（路由）都必须由发起人亲自告诉会议室里的每一个人。每个人之间都必须有直接通话的线路（IBGP会话）。来一个新成员，就要给所有人都拉一条线。 路由反射器：像一个部门经理（RR）和团队成员（客户端）。 团队成员A有消息，只需要告诉经理。 经理负责将这个消息广播给团队里的所有其他成员（B、C、D…）。 团队成员之间不需要直接沟通。 这样极大地减少了沟通渠道，管理起来也方便。 结论：全互联是BGP最初设计的“理想化”模型，简单但不可扩展。而路由反射器是基于实际工程需求对BGP协议进行的“实用性”扩展，它通过引入新的防环机制，以中心化的架构完美解决了大规模网络下的可扩展性问题，是现代互联网骨干网的基石技术之一。 在当今的网络中，只要一个AS内的BGP路由器数量超过个位数，几乎无一例外都会使用路由反射器。","tags":["网络工程师","计算机网络","BGP","路由协议"]},{"title":"[BGP]如何深入理解BGP与其他路由协议的结合","path":"/2025/10/04/BGP-如何深入理解BGP与其他路由协议的结合/","content":"有一种说法，BGP与其他路由的结合，相当于在原有的路由路径上加了层立交桥。 这是个非常形象且准确的比喻。我们可以从几个层面来深入理解这句话的含义和它所体现的核心理念。 如何理解“BGP是路由世界里的立交桥”？想象一个城市的交通系统： 城市内部道路（IGP）： 你所在城市里的街道、主干道、环线，就好比内部网关协议，如 OSPF 或 EIGRP。 这些协议负责将数据包（车辆）在一个独立的网络（城市） 内部，从一点高效地送到另一点。它们关注的是最优路径，比如哪个路口转弯、走哪条路最快、避免拥堵（基于带宽、延迟等度量值）。 特点： 精细、快速、自动化，但管理范围有限，只在本“城市”（自治系统）内有效。 城市间高速公路（BGP）： 连接不同城市甚至不同国家的高速公路网，就好比边界网关协议（BGP）。 BGP不关心你在我这个“城市”里具体怎么走。它只关心：“哪个入口能上高速？” 和 “从哪个出口下高速能到达目标城市？”。这里的“入口”和“出口”就是自治系统的边界路由器。 立交桥（BGP与IGP的结合点）： “立交桥” 正是这个比喻的精髓所在。它指的是一个自治系统的边界路由器。这里是内部道路（IGP）和外部高速公路（BGP）的交汇点和转换点。 功能一：信息汇总与分发（上桥） 你的“城市”（自治系统）通过立交桥向外部高速公路（BGP）广播：“要来我这里，请从这个立交桥（我的AS号）下高速。” 它把内部复杂的街道信息（IGP路由）汇总成一个简单的、对外的指示牌（BGP路由）。 功能二：路径选择与引入（下桥） 当数据包从“高速公路”（BGP）来到你的“城市”边界时，它通过“立交桥”（边界路由器）下来。然后，这个数据包就交给了“城市内部交通系统”（IGP），由IGP负责根据内部道路情况，将其最终送达目的地。 一个简单的数据包旅程例子： 假设你想从“上海公司网络”（AS 65001）访问“北京数据中心”（AS 65002）。 上海市内行驶（OSPF）： 你的数据包首先通过公司内部的OSPF网络，路由到公司的边界路由器（立交桥）。 上立交桥，进入高速（BGP）： 边界路由器查看BGP路由表，发现要去AS 65002，最优路径是下一跳交给“运营商A”（AS 100）。于是数据包被送上BGP“高速公路”。 在高速上行驶（BGP）： 数据包在运营商A、B、C的骨干网（通过BGP互联）中传递，BGP负责在这些巨大的自治系统之间选择最佳路径（基于策略、AS_PATH长度等，而非速度）。 下立交桥，进入北京市内（OSPF）： 数据包到达“北京数据中心”（AS 65002）的边界路由器（另一个立交桥）。BGP的任务完成，数据包被交给数据中心内部的OSPF网络。 北京市内行驶（OSPF）： 数据中心内部的OSPF负责将数据包最终送达目标服务器。 所以，“加了一层立交桥”的含义是：在原有的、精细的内部路由（城市道路）之上，叠加了一个宏观的、策略性的域间路由系统（高速公路）。这个“立交桥”层（BGP）不取代底层（IGP），而是与之协同工作，共同构成了完整的互联网路由体系。 它体现了什么？这个比喻深刻地揭示了互联网路由架构的核心设计哲学： 分层与模块化设计： 这是最核心的体现。互联网是一个由无数自治系统组成的巨大网络，分层设计使得它易于管理、扩展和故障隔离。 IGP管“内政”：每个公司、机构可以自由选择和管理自己的内部路由，无需与外界协商。 BGP管“外交”：自治系统之间通过BGP建立对等关系，交换路由信息，但彼此不干涉内部事务。 这种“立交桥”式的结构，使得整个互联网能够“分而治之”，具备了极强的可扩展性。 策略与控制的分离： IGP的目标是“最快”：其决策基于技术指标（成本、延迟）。 BGP的目标是“最合适”：其决策 heavily 依赖于策略。比如，“我宁愿绕路也不经过竞争对手的网络”、“我优先选择付费更低的运营商作为出口”。立交桥（边界路由器）就是执行这些商业策略的关键节点。 可扩展性与稳定性： 如果没有BGP这层“立交桥”，让OSPF去管理整个互联网的路由，路由表将庞大到无法计算，任何局部网络的抖动都会引发全球路由震荡。 BGP通过聚合路由和基于AS_PATH的路由环路防止机制，极大地提升了全球网络的稳定性。一个城市内部修路（IGP路由变化），不会导致全国高速公路网（BGP）重新规划。 互联网的真实形态： 这个比喻准确地描绘了互联网并非一个平坦、统一的网络，而是一个由众多独立管理的“网络岛屿”（自治系统）通过“立交桥”（BGP对等点）连接起来的联盟。它本质上是“网络的网络”。 总结来说，“BGP相当于在原有路由路径上加了层立交桥”这个说法，完美地概括了互联网路由的分层、模块化和策略驱动的本质。它体现了将复杂的全局性问题（全球互联）分解为局部问题（内部路由）和边界问题（域间路由）的智慧，这正是互联网能够发展到今天如此巨大规模的关键所在。","tags":["网络工程师","计算机网络","BGP","路由协议"]},{"title":"[BGP]BGP路由协议详解","path":"/2025/10/04/BGP-BGP路由协议详解/","content":"BGP，边界网关协议，属于距离矢量路由协议，承载路由条目数量大，选路原则丰富，适用于自治域AS间的路由。 AS 边界路由相连成为EBGP对等体，AS内部路由只有建立IBGP对等体才可传递和接收BGP路由条目。IBGP的一大特点就是选路原则丰富，原则是由BGP路由属性决定的。 这里展开说下，BGP路由及属性是附带的。 无论传递什么样的路由，想要让其拥有BGP属性，就要让它成为BGP的路由。前提是设备要具有BGP的路径，这一条的前提又是需要建立BGP的邻居。 报文封装在传输层，基于TCP 179端口发送消息。 使用TCP端口，说明两个问题：(1)证明连接可靠。(2)TCP 位于传输层，建立于三层网络层之上，这说明其必须保证三层通信是通的。所以BGP协议的配置通常在实际操作中，会与其他类型的路由协议一起搭建。 再展开来说，BGP与其他类型路由的结合，相当于在原有路由路径的基础上加了层立交桥。","tags":["网络工程师","计算机网络","BGP","路由协议"]},{"title":"[BGP]简单理解IBGP与EBGP","path":"/2025/10/04/BGP-简单理解IBGP与EBGP/","content":"这是一个非常核心的网络问题，尤其是对于从事大规模网络运维和设计的人员。我们来详细、清晰地解析一下IBGP和EBGP。 核心概念一句话概括 EBGP： 运行于不同自治系统之间的BGP。可以理解为 “对外” 的协议。 IBGP： 运行于同一自治系统内部的BGP路由器之间。可以理解为 “对内” 的协议。 为了理解它们，首先必须明白什么是自治系统（AS）。一个AS通常是一个独立的网络管理域，比如一家大型公司、一个运营商或一个大学校园。它由一个统一的机构管理，并拥有统一的路由策略。每个AS都有一个全球唯一的编号，称为AS号。 相同点既然都叫BGP，它们必然共享BGP协议的基本特性： 协议本身相同：它们都使用BGP协议（通常是版本4），使用相同的报文类型（Open, Update, Keepalive, Notification），并建立在可靠的TCP连接之上（端口179）。 核心功能相同：它们的主要功能都是交换和维护网络可达性信息（即路由信息）。这些信息以“前缀+路径属性”的形式传递。 使用路径属性：它们都使用BGP路径属性（如AS_PATH, NEXT_HOP, LOCAL_PREF, MED等）来记录路径信息和实施路由策略。 不同点（这是关键）IBGP和EBGP的设计目标完全不同（一个对内，一个对外），这导致了它们在行为上有着根本性的区别。下表清晰地列出了它们的主要不同点： 特性 EBGP IBGP 运行位置 不同自治系统（AS）之间 同一自治系统（AS）内部 默认管理距离 20（更优先） 200（优先级较低） 下一跳行为 默认将下一跳修改为自己的出口IP 默认不修改下一跳 AS_PATH处理 将自己所在的AS号前置到AS_PATH中 不修改AS_PATH属性 环路防止机制 查看AS_PATH，如果收到路由的AS_PATH中包含自己的AS号，则拒绝该路由。 BGP水平分割规则：从IBGP对等体学到的路由，不会再传递给其他IBGP对等体。 全连接要求 通常不需要全连接，根据物理拓扑或策略建立即可。 通常需要逻辑上的全连接（或使用路由反射器联盟来解决），以避免因水平分割导致路由黑洞。 主要目的 在AS之间传递路由，实施域间路由策略。 在AS内部同步从EBGP学到的路由，确保AS内部所有BGP路由器拥有一致的出口路由信息。 详细解释关键不同点1. 默认管理距离 EBGP: 20 IBGP: 200 解释：当一台路由器从不同路由协议（如OSPF、EIGRP）或BGP的不同类型（EBGPIBGP）学到通往同一目的地的路由时，管理距离用于决定哪个路由源更可信。数值越小越优先。EBGP的20意味着它比大多数IGP（如OSPF的110）和IBGP都更可信。这很直观：从外部直接学来的路由通常比内部传递的路由更“原始”、更可靠。 2. 下一跳行为 EBGP：当路由器通过EBGP向另一个AS宣告一条路由时，它会将下一跳属性修改为自己的出口接口IP地址。这是告诉对方：“要来这个网络，请把数据包发给我这个地址。” IBGP：为了防止AS内部的路由器因为不知道如何到达下一跳而丢弃数据包，IBGP在传递从EBGP学来的路由时，默认保留原始的下一跳IP地址不变。这就要求AS内部的所有路由器（即使不运行BGP）都必须通过IGP（如OSPF、IS-IS）知道如何到达这个下一跳地址。这通常通过在网络中发布这个下一跳IP地址的路由来实现。 3. 环路防止机制 EBGP：非常简单直接。如果一台BGP路由器在收到路由的AS_PATH属性中看到了自己所在的AS号，它就认为这是一个环路，并丢弃该路由。 IBGP：BGP水平分割规则。这是一条关键规则：从一个IBGP对等体学到的路由，绝不会被传递给另一个IBGP对等体。这样做的原因是，IBGP不像IGP那样有自己的拓扑信息，它无法像OSPF一样通过SPF算法防环。如果没有这个规则，路由将在IBGP全连接网中无限循环。 4. 全连接要求 由于上述的IBGP水平分割规则，如果AS内有多台BGP路由器，它们之间必须建立全连接的IBGP对等体关系（逻辑上的全网状），否则路由将无法传递到所有BGP路由器。 解决方案：为了解决全网状连接扩展性差的问题，引入了两种技术： 路由反射器（RR）：指定一台或几台路由器作为RR，其他路由器作为RR客户端。客户端只与RR建立IBGP连接。RR可以反射路由，从而打破水平分割规则。 BGP联盟（Confederation）：将一个大的AS划分成几个小的私有AS，在私有AS之间运行“联盟内部的EBGP”，这个eBGP行为类似IBGP（如不修改AS_PATH等）。 一个生动的比喻把整个网络世界想象成一个由不同国家（AS）组成的世界。 EBGP 就像是国家之间的外交官。 他们负责与其他国家（AS）交换信息（路由）。 他们非常谨慎，每经过一个国家就在护照（AS_PATH）上盖一个章，如果发现护照上已经有自己国家的章，就拒绝入境（防环）。 他们明确告诉对方：“要找我们国家，请先联系我这个大使馆（修改下一跳）。” IBGP 就像是一个国家内部的政府通信系统。 他们负责将外交官（EBGP）带回来的信息，准确地同步给国家内部所有关键部门（AS内部的所有BGP路由器）。 为了防止内部消息混乱和谣言传播，他们规定：一个部门从另一个部门听来的消息，不能再传给第三个部门（水平分割）。这就要求所有部门必须直接与中央或其他所有部门建立直接联系（全连接），或者设立一个新闻中心（路由反射器）来统一发布消息。 他们告诉各部门：“要去那个外国，请直接联系最初接待我们外交官的那个大使馆（不修改下一跳），至于怎么去那个大使馆，你们看国内交通图（IGP）自己解决。” 总结理解IBGP和EBGP的关键在于牢记它们所处的信任边界不同。 EBGP处理的是不可信的域间关系，因此它的规则（修改下一跳、添加AS_PATH）都非常严格和谨慎，旨在明确路径、防止环路和实施策略。 IBGP处理的是可信的域内关系，因此它的设计目标是高效、无环地在内部同步外部路由信息，它的特殊规则（水平分割、不修改下一跳）都是为了在缺乏拓扑信息的背景下，安全地实现这一目标。 在实际网络中，一个典型的BGP路由器通常同时运行EBGP和IBGP：它通过EBGP与外部AS的对等体交换路由，然后通过IBGP将这些路由传递给AS内部的其他BGP路由器。","tags":["网络工程师","计算机网络","BGP","路由协议"]},{"title":"如何利用hexo在自己的博客发布文章","path":"/2025/09/29/如何利用hexo在自己的博客发布文章/","content":"书接上文 如何基于github搭建个人博客 | Hexo 博客搭建完成，可以正常访问了，下一步自然要做的就是，如何将自己编写的内容发布到博客上。 还是需要用到git，不过操作很简单。 第一步，进入我们本地的博客目录，然后使用git命令hexo new ‘xxx’ 比如我这篇博客的名称叫《如何利用hexo在自己的博客发布文章》，那么完整命令如下： hexo new 如何利用hexo在自己的博客发布文章 没关系，标题里面有中英文都可以，不影响。 运行之后，可以看到我们的本地博客目录下多了一个以刚才标题命名的markdown格式文件。 OK，我们点击进去编辑即可。 当然，markdown的本地编辑器这里更推荐采用Typora。 编写完成后，保存。 然后回到git，使用如下简单的两个命令 (1) hexo g 这一步是生成html文件 (2) hexo d 上传至github 两条命令执行完，再刷新我们的主页，就可以看到文章被推送到自己的博客了。","tags":["github","hexo"]},{"title":"如何基于github搭建个人博客","path":"/2025/09/22/如何基于github搭建个人博客/","content":"每个码农都有一个搭建个人博客的梦想。虽然现在写代码的机会比较少了，不过这个梦想依然在心中等待实现。拖了很久，最近因为工作和学习上的事情，打算搭建一个新的平台来记录一些内容当做笔记，简直没有比个人博客更适合的平台了。这下不能再拖了。 说干就干。通过网上查阅到的教程，一步一步实现个人博客搭建的功能。这里顺便把搭建的过程记录下来，正好当做新博客的第一篇内容，再适合不过了。 1.我们需要用到github，具体需要登录github页面以及在本地搭建git环境，并为git配置SSH key信息。这部分之前都已经完成了，步骤略。 2.我们需要在给电脑安装node.js 访问网址https://nodejs.org/en/download/ 点击Windows Installer(.msi)链接进行下载安装。 安装过程没有什么特殊操作，一路next即可。 安装好之后，可以在git bash终端输入命令node -v进行验证。 3.在本地安装Hexo 在git bash终端输入命令npm install hexo -g进行安装 显示安装完成后，可输入命令hexo -v进行验证 4.安装hexo依赖 在git bash终端输入命令npm install –save hexo-deployer-git 5.到这里基本的安装流程就已经结束了，下面开始博客目录的搭建 首先需要新建一个专门的本地保存博客的目录。比如就叫E:\\young\\fcbyoung\\ 在git bash终端进入这个目录，然后输入hexo init命令完成初始化。如图 同时我们可以看到就在我们创建的博客目录文件夹下也出现了一些新建内容 接下来使用hexo g命令，生成静态网页。完成后使用hexo s命令进行预览 两步都完成后，可以看到生成了一个http://localhost:4000/的链接 在浏览器访问此链接，可以打开一个本地页面 页面已生成，创建页面的第一步已经完成。 接下来我们需要借助github将网页运行上线。 6.在github页面，选择New repository，新建一个github仓库 注意：给仓库起名一定要遵循固定的格式，用户名.github.io 比如我的github用户名叫fcbyoung，那么我的新仓库名称就必须是fcbyoung.github.io 同时建议点击选中Add a README 其余没有什么需要特别注意的事项，设置好之后点击create即可。 接下来回到本地博客目录，找到_config.yml文件进行编辑，内容如下： deploy: type: git repo: git@github.com:fcbyoung/fcbyoung.github.io.git branch: main repo后面将自己的仓库地址附上 branch看自己的github仓库在哪个分支下。我的显示在main分支，所以这里就填main 设置好后，在git bash输入命令hexo d，将博客发布到github 顺利发布后，在浏览器地址栏输入自己的链接，即可成功访问","tags":["github","hexo"]}]